const isWindows = process.platform === 'win32' ||
    process.env.OSTYPE === 'cygwin' ||
    process.env.OSTYPE === 'msys'

const path = require('path')
const COLON = isWindows ? ';' : ':'
const isexe = require('isexe')

const getNotFoundError = (cmd) =>
  Object.assign(new Error(`not found: $***REMOVED***cmd***REMOVED***`), ***REMOVED*** code: 'ENOENT' ***REMOVED***)

const getPathInfo = (cmd, opt) => ***REMOVED***
  const colon = opt.colon || COLON

  // If it has a slash, then we don't bother searching the pathenv.
  // just check the file itself, and that's it.
  const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? ['']
    : (
      [
        // windows always checks the cwd first
        ...(isWindows ? [process.cwd()] : []),
        ...(opt.path || process.env.PATH ||
          /* istanbul ignore next: very unusual */ '').split(colon),
      ]
    )
  const pathExtExe = isWindows
    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'
    : ''
  const pathExt = isWindows ? pathExtExe.split(colon) : ['']

  if (isWindows) ***REMOVED***
    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')
      pathExt.unshift('')
***REMOVED***

  return ***REMOVED***
    pathEnv,
    pathExt,
    pathExtExe,
***REMOVED***
***REMOVED***

const which = (cmd, opt, cb) => ***REMOVED***
  if (typeof opt === 'function') ***REMOVED***
    cb = opt
    opt = ***REMOVED******REMOVED***
***REMOVED***
  if (!opt)
    opt = ***REMOVED******REMOVED***

  const ***REMOVED*** pathEnv, pathExt, pathExtExe ***REMOVED*** = getPathInfo(cmd, opt)
  const found = []

  const step = i => new Promise((resolve, reject) => ***REMOVED***
    if (i === pathEnv.length)
      return opt.all && found.length ? resolve(found)
        : reject(getNotFoundError(cmd))

    const ppRaw = pathEnv[i]
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw

    const pCmd = path.join(pathPart, cmd)
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
      : pCmd

    resolve(subStep(p, i, 0))
***REMOVED***)

  const subStep = (p, i, ii) => new Promise((resolve, reject) => ***REMOVED***
    if (ii === pathExt.length)
      return resolve(step(i + 1))
    const ext = pathExt[ii]
    isexe(p + ext, ***REMOVED*** pathExt: pathExtExe ***REMOVED***, (er, is) => ***REMOVED***
      if (!er && is) ***REMOVED***
        if (opt.all)
          found.push(p + ext)
        else
          return resolve(p + ext)
  ***REMOVED***
      return resolve(subStep(p, i, ii + 1))
***REMOVED***)
***REMOVED***)

  return cb ? step(0).then(res => cb(null, res), cb) : step(0)
***REMOVED***

const whichSync = (cmd, opt) => ***REMOVED***
  opt = opt || ***REMOVED******REMOVED***

  const ***REMOVED*** pathEnv, pathExt, pathExtExe ***REMOVED*** = getPathInfo(cmd, opt)
  const found = []

  for (let i = 0; i < pathEnv.length; i ++) ***REMOVED***
    const ppRaw = pathEnv[i]
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw

    const pCmd = path.join(pathPart, cmd)
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
      : pCmd

    for (let j = 0; j < pathExt.length; j ++) ***REMOVED***
      const cur = p + pathExt[j]
      try ***REMOVED***
        const is = isexe.sync(cur, ***REMOVED*** pathExt: pathExtExe ***REMOVED***)
        if (is) ***REMOVED***
          if (opt.all)
            found.push(cur)
          else
            return cur
    ***REMOVED***
  ***REMOVED*** catch (ex) ***REMOVED******REMOVED***
***REMOVED***
***REMOVED***

  if (opt.all && found.length)
    return found

  if (opt.nothrow)
    return null

  throw getNotFoundError(cmd)
***REMOVED***

module.exports = which
which.sync = whichSync
