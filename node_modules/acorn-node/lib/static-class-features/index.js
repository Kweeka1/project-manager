/* Generated by `npm run build`, do not edit! */

"use strict"

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g

var acorn = require("acorn")
var tt = acorn.tokTypes

function maybeParseFieldValue(field) ***REMOVED***
  if (this.eat(tt.eq)) ***REMOVED***
    var oldInFieldValue = this._inStaticFieldValue
    this._inStaticFieldValue = true
    field.value = this.parseExpression()
    this._inStaticFieldValue = oldInFieldValue
***REMOVED*** else ***REMOVED*** field.value = null ***REMOVED***
***REMOVED***

var privateClassElements = require("../private-class-elements")

module.exports = function(Parser) ***REMOVED***
  var ExtendedParser = privateClassElements(Parser)

  return /*@__PURE__*/(function (ExtendedParser) ***REMOVED***
    function anonymous () ***REMOVED***
      ExtendedParser.apply(this, arguments);
***REMOVED***

    if ( ExtendedParser ) anonymous.__proto__ = ExtendedParser;
    anonymous.prototype = Object.create( ExtendedParser && ExtendedParser.prototype );
    anonymous.prototype.constructor = anonymous;

    anonymous.prototype.parseClassElement = function parseClassElement (_constructorAllowsSuper) ***REMOVED***
      var this$1 = this;

      if (this.eat(tt.semi)) ***REMOVED*** return null ***REMOVED***

      var node = this.startNode()

      var tryContextual = function (k, noLineBreak) ***REMOVED***
        if (typeof noLineBreak == "undefined") ***REMOVED*** noLineBreak = false ***REMOVED***
        var start = this$1.start, startLoc = this$1.startLoc
        if (!this$1.eatContextual(k)) ***REMOVED*** return false ***REMOVED***
        if (this$1.type !== tt.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) ***REMOVED*** return true ***REMOVED***
        if (node.key) ***REMOVED*** this$1.unexpected() ***REMOVED***
        node.computed = false
        node.key = this$1.startNodeAt(start, startLoc)
        node.key.name = k
        this$1.finishNode(node.key, "Identifier")
        return false
  ***REMOVED***

      node.static = tryContextual("static")
      if (!node.static) ***REMOVED*** return ExtendedParser.prototype.parseClassElement.apply(this, arguments) ***REMOVED***

      var isGenerator = this.eat(tt.star)
      var isAsync = false
      if (!isGenerator) ***REMOVED***
        // Special-case for `async`, since `parseClassMember` currently looks
        // for `(` to determine whether `async` is a method name
        if (this.options.ecmaVersion >= 8 && this.isContextual("async")) ***REMOVED***
          skipWhiteSpace.lastIndex = this.pos
          var skip = skipWhiteSpace.exec(this.input)
          var next = this.input.charAt(this.pos + skip[0].length)
          if (next === ";" || next === "=") ***REMOVED***
            node.key = this.parseIdent(true)
            node.computed = false
            maybeParseFieldValue.call(this, node)
            this.finishNode(node, "FieldDefinition")
            this.semicolon()
            return node
      ***REMOVED*** else if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) ***REMOVED***
            isAsync = true
            isGenerator = this.options.ecmaVersion >= 9 && this.eat(tt.star)
      ***REMOVED***
    ***REMOVED*** else if (tryContextual("get")) ***REMOVED***
          node.kind = "get"
    ***REMOVED*** else if (tryContextual("set")) ***REMOVED***
          node.kind = "set"
    ***REMOVED***
  ***REMOVED***
      if (this.type === this.privateNameToken) ***REMOVED***
        this.parsePrivateClassElementName(node)
        if (this.type !== tt.parenL) ***REMOVED***
          if (node.key.name === "prototype") ***REMOVED***
            this.raise(node.key.start, "Classes may not have a private static property named prototype")
      ***REMOVED***
          maybeParseFieldValue.call(this, node)
          this.finishNode(node, "FieldDefinition")
          this.semicolon()
          return node
    ***REMOVED***
  ***REMOVED*** else if (!node.key) ***REMOVED***
        this.parsePropertyName(node)
        if ((node.key.name || node.key.value) === "prototype" && !node.computed) ***REMOVED***
          this.raise(node.key.start, "Classes may not have a static property named prototype")
    ***REMOVED***
  ***REMOVED***
      if (!node.kind) ***REMOVED*** node.kind = "method" ***REMOVED***
      this.parseClassMethod(node, isGenerator, isAsync)
      if (!node.kind && (node.key.name || node.key.value) === "constructor" && !node.computed) ***REMOVED***
        this.raise(node.key.start, "Classes may not have a static field named constructor")
  ***REMOVED***
      if (node.kind === "get" && node.value.params.length !== 0) ***REMOVED***
        this.raiseRecoverable(node.value.start, "getter should have no params")
  ***REMOVED***
      if (node.kind === "set" && node.value.params.length !== 1) ***REMOVED***
        this.raiseRecoverable(node.value.start, "setter should have exactly one param")
  ***REMOVED***
      if (node.kind === "set" && node.value.params[0].type === "RestElement") ***REMOVED***
        this.raiseRecoverable(node.value.params[0].start, "Setter cannot use rest params")
  ***REMOVED***

      return node

***REMOVED***;

    // Parse public static fields
    anonymous.prototype.parseClassMethod = function parseClassMethod (method, isGenerator, isAsync, _allowsDirectSuper) ***REMOVED***
      if (isGenerator || isAsync || method.kind != "method" || !method.static || this.options.ecmaVersion < 8 || this.type == tt.parenL) ***REMOVED***
        return ExtendedParser.prototype.parseClassMethod.apply(this, arguments)
  ***REMOVED***
      maybeParseFieldValue.call(this, method)
      delete method.kind
      method = this.finishNode(method, "FieldDefinition")
      this.semicolon()
      return method
***REMOVED***;

    // Prohibit arguments in class field initializers
    anonymous.prototype.parseIdent = function parseIdent (liberal, isBinding) ***REMOVED***
      var ident = ExtendedParser.prototype.parseIdent.call(this, liberal, isBinding)
      if (this._inStaticFieldValue && ident.name == "arguments") ***REMOVED*** this.raise(ident.start, "A static class field initializer may not contain arguments") ***REMOVED***
      return ident
***REMOVED***;

    return anonymous;
***REMOVED***(ExtendedParser))
***REMOVED***
