/* Generated by `npm run build`, do not edit! */

"use strict"

var acorn = require("acorn")
if (false) ***REMOVED***
  throw new Error(("acorn-private-class-elements requires acorn@^6.1.0, not " + (acorn.version)))
***REMOVED***
var tt = acorn.tokTypes
var TokenType = acorn.TokenType

module.exports = function(Parser) ***REMOVED***
  // Only load this plugin once.
  if (Parser.prototype.parsePrivateName) ***REMOVED***
    return Parser
***REMOVED***

  // Make sure `Parser` comes from the same acorn as our `tt`,
  // otherwise the comparisons fail.
  var cur = Parser
  while (cur && cur !== acorn.Parser) ***REMOVED***
    cur = cur.__proto__
***REMOVED***
  if (cur !== acorn.Parser) ***REMOVED***
    throw new Error("acorn-private-class-elements does not support mixing different acorn copies")
***REMOVED***

  Parser = /*@__PURE__*/(function (Parser) ***REMOVED***
    function Parser_ () ***REMOVED***
      Parser.apply(this, arguments);
***REMOVED***

    if ( Parser ) Parser_.__proto__ = Parser;
    Parser_.prototype = Object.create( Parser && Parser.prototype );
    Parser_.prototype.constructor = Parser_;

    Parser_.prototype._branch = function _branch () ***REMOVED***
      this.__branch = this.__branch || new Parser(***REMOVED***ecmaVersion: this.options.ecmaVersion***REMOVED***, this.input)
      this.__branch.end = this.end
      this.__branch.pos = this.pos
      this.__branch.type = this.type
      this.__branch.value = this.value
      this.__branch.containsEsc = this.containsEsc
      return this.__branch
***REMOVED***;

    Parser_.prototype.parsePrivateClassElementName = function parsePrivateClassElementName (element) ***REMOVED***
      element.computed = false
      element.key = this.parsePrivateName()
      if (element.key.name == "constructor") ***REMOVED*** this.raise(element.key.start, "Classes may not have a private element named constructor") ***REMOVED***
      var accept = ***REMOVED***get: "set", set: "get"***REMOVED***[element.kind]
      var privateBoundNames = this._privateBoundNamesStack[this._privateBoundNamesStack.length - 1]
      if (Object.prototype.hasOwnProperty.call(privateBoundNames, element.key.name) && privateBoundNames[element.key.name] !== accept) ***REMOVED***
        this.raise(element.start, "Duplicate private element")
  ***REMOVED***
      privateBoundNames[element.key.name] = element.kind || true
      delete this._unresolvedPrivateNamesStack[this._unresolvedPrivateNamesStack.length - 1][element.key.name]
      return element.key
***REMOVED***;

    Parser_.prototype.parsePrivateName = function parsePrivateName () ***REMOVED***
      var node = this.startNode()
      node.name = this.value
      this.next()
      this.finishNode(node, "PrivateName")
      if (this.options.allowReserved == "never") ***REMOVED*** this.checkUnreserved(node) ***REMOVED***
      return node
***REMOVED***;

    // Parse # token
    Parser_.prototype.getTokenFromCode = function getTokenFromCode (code) ***REMOVED***
      if (code === 35) ***REMOVED***
        ++this.pos
        var word = this.readWord1()
        return this.finishToken(this.privateNameToken, word)
  ***REMOVED***
      return Parser.prototype.getTokenFromCode.call(this, code)
***REMOVED***;

    // Manage stacks and check for undeclared private names
    Parser_.prototype.parseClass = function parseClass (node, isStatement) ***REMOVED***
      this._privateBoundNamesStack = this._privateBoundNamesStack || []
      var privateBoundNames = Object.create(this._privateBoundNamesStack[this._privateBoundNamesStack.length - 1] || null)
      this._privateBoundNamesStack.push(privateBoundNames)
      this._unresolvedPrivateNamesStack = this._unresolvedPrivateNamesStack || []
      var unresolvedPrivateNames = Object.create(null)
      this._unresolvedPrivateNamesStack.push(unresolvedPrivateNames)
      var _return = Parser.prototype.parseClass.call(this, node, isStatement)
      this._privateBoundNamesStack.pop()
      this._unresolvedPrivateNamesStack.pop()
      if (!this._unresolvedPrivateNamesStack.length) ***REMOVED***
        var names = Object.keys(unresolvedPrivateNames)
        if (names.length) ***REMOVED***
          names.sort(function (n1, n2) ***REMOVED*** return unresolvedPrivateNames[n1] - unresolvedPrivateNames[n2]; ***REMOVED***)
          this.raise(unresolvedPrivateNames[names[0]], "Usage of undeclared private name")
    ***REMOVED***
  ***REMOVED*** else ***REMOVED*** Object.assign(this._unresolvedPrivateNamesStack[this._unresolvedPrivateNamesStack.length - 1], unresolvedPrivateNames) ***REMOVED***
      return _return
***REMOVED***;

    // Parse private element access
    Parser_.prototype.parseSubscript = function parseSubscript (base, startPos, startLoc, noCalls, maybeAsyncArrow) ***REMOVED***
      if (!this.eat(tt.dot)) ***REMOVED***
        return Parser.prototype.parseSubscript.call(this, base, startPos, startLoc, noCalls, maybeAsyncArrow)
  ***REMOVED***
      var node = this.startNodeAt(startPos, startLoc)
      node.object = base
      node.computed = false
      if (this.type == this.privateNameToken) ***REMOVED***
        node.property = this.parsePrivateName()
        if (!this._privateBoundNamesStack.length || !this._privateBoundNamesStack[this._privateBoundNamesStack.length - 1][node.property.name]) ***REMOVED***
          this._unresolvedPrivateNamesStack[this._unresolvedPrivateNamesStack.length - 1][node.property.name] = node.property.start
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
        node.property = this.parseIdent(true)
  ***REMOVED***
      return this.finishNode(node, "MemberExpression")
***REMOVED***;

    // Prohibit delete of private class elements
    Parser_.prototype.parseMaybeUnary = function parseMaybeUnary (refDestructuringErrors, sawUnary) ***REMOVED***
      var _return = Parser.prototype.parseMaybeUnary.call(this, refDestructuringErrors, sawUnary)
      if (_return.operator == "delete") ***REMOVED***
        if (_return.argument.type == "MemberExpression" && _return.argument.property.type == "PrivateName") ***REMOVED***
          this.raise(_return.start, "Private elements may not be deleted")
    ***REMOVED***
  ***REMOVED***
      return _return
***REMOVED***;

    return Parser_;
***REMOVED***(Parser))
  Parser.prototype.privateNameToken = new TokenType("privateName")
  return Parser
***REMOVED***
