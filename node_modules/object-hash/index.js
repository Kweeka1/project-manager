'use strict';

var crypto = require('crypto');

/**
 * Exported function
 *
 * Options:
 *
 *  - `algorithm` hash algo to be used by this instance: *'sha1', 'md5'
 *  - `excludeValues` ***REMOVED***true|*false***REMOVED*** hash object keys, values ignored
 *  - `encoding` hash encoding, supports 'buffer', '*hex', 'binary', 'base64'
 *  - `ignoreUnknown` ***REMOVED***true|*false***REMOVED*** ignore unknown object types
 *  - `replacer` optional function that replaces values before hashing
 *  - `respectFunctionProperties` ***REMOVED****true|false***REMOVED*** consider function properties when hashing
 *  - `respectFunctionNames` ***REMOVED****true|false***REMOVED*** consider 'name' property of functions for hashing
 *  - `respectType` ***REMOVED****true|false***REMOVED*** Respect special properties (prototype, constructor)
 *    when hashing to distinguish between types
 *  - `unorderedArrays` ***REMOVED***true|*false***REMOVED*** Sort all arrays before hashing
 *  - `unorderedSets` ***REMOVED****true|false***REMOVED*** Sort `Set` and `Map` instances before hashing
 *  * = default
 *
 * @param ***REMOVED***object***REMOVED*** object value to hash
 * @param ***REMOVED***object***REMOVED*** options hashing options
 * @return ***REMOVED***string***REMOVED*** hash value
 * @api public
 */
exports = module.exports = objectHash;

function objectHash(object, options)***REMOVED***
  options = applyDefaults(object, options);

  return hash(object, options);
***REMOVED***

/**
 * Exported sugar methods
 *
 * @param ***REMOVED***object***REMOVED*** object value to hash
 * @return ***REMOVED***string***REMOVED*** hash value
 * @api public
 */
exports.sha1 = function(object)***REMOVED***
  return objectHash(object);
***REMOVED***;
exports.keys = function(object)***REMOVED***
  return objectHash(object, ***REMOVED***excludeValues: true, algorithm: 'sha1', encoding: 'hex'***REMOVED***);
***REMOVED***;
exports.MD5 = function(object)***REMOVED***
  return objectHash(object, ***REMOVED***algorithm: 'md5', encoding: 'hex'***REMOVED***);
***REMOVED***;
exports.keysMD5 = function(object)***REMOVED***
  return objectHash(object, ***REMOVED***algorithm: 'md5', encoding: 'hex', excludeValues: true***REMOVED***);
***REMOVED***;

// Internals
var hashes = crypto.getHashes ? crypto.getHashes().slice() : ['sha1', 'md5'];
hashes.push('passthrough');
var encodings = ['buffer', 'hex', 'binary', 'base64'];

function applyDefaults(object, sourceOptions)***REMOVED***
  sourceOptions = sourceOptions || ***REMOVED******REMOVED***;

  // create a copy rather than mutating
  var options = ***REMOVED******REMOVED***;
  options.algorithm = sourceOptions.algorithm || 'sha1';
  options.encoding = sourceOptions.encoding || 'hex';
  options.excludeValues = sourceOptions.excludeValues ? true : false;
  options.algorithm = options.algorithm.toLowerCase();
  options.encoding = options.encoding.toLowerCase();
  options.ignoreUnknown = sourceOptions.ignoreUnknown !== true ? false : true; // default to false
  options.respectType = sourceOptions.respectType === false ? false : true; // default to true
  options.respectFunctionNames = sourceOptions.respectFunctionNames === false ? false : true;
  options.respectFunctionProperties = sourceOptions.respectFunctionProperties === false ? false : true;
  options.unorderedArrays = sourceOptions.unorderedArrays !== true ? false : true; // default to false
  options.unorderedSets = sourceOptions.unorderedSets === false ? false : true; // default to false
  options.unorderedObjects = sourceOptions.unorderedObjects === false ? false : true; // default to true
  options.replacer = sourceOptions.replacer || undefined;
  options.excludeKeys = sourceOptions.excludeKeys || undefined;

  if(typeof object === 'undefined') ***REMOVED***
    throw new Error('Object argument required.');
***REMOVED***

  // if there is a case-insensitive match in the hashes list, accept it
  // (i.e. SHA256 for sha256)
  for (var i = 0; i < hashes.length; ++i) ***REMOVED***
    if (hashes[i].toLowerCase() === options.algorithm.toLowerCase()) ***REMOVED***
      options.algorithm = hashes[i];
***REMOVED***
***REMOVED***

  if(hashes.indexOf(options.algorithm) === -1)***REMOVED***
    throw new Error('Algorithm "' + options.algorithm + '"  not supported. ' +
      'supported values: ' + hashes.join(', '));
***REMOVED***

  if(encodings.indexOf(options.encoding) === -1 &&
     options.algorithm !== 'passthrough')***REMOVED***
    throw new Error('Encoding "' + options.encoding + '"  not supported. ' +
      'supported values: ' + encodings.join(', '));
***REMOVED***

  return options;
***REMOVED***

/** Check if the given function is a native function */
function isNativeFunction(f) ***REMOVED***
  if ((typeof f) !== 'function') ***REMOVED***
    return false;
***REMOVED***
  var exp = /^function\s+\w*\s*\(\s*\)\s****REMOVED***\s+\[native code\]\s+***REMOVED***$/i;
  return exp.exec(Function.prototype.toString.call(f)) != null;
***REMOVED***

function hash(object, options) ***REMOVED***
  var hashingStream;

  if (options.algorithm !== 'passthrough') ***REMOVED***
    hashingStream = crypto.createHash(options.algorithm);
***REMOVED*** else ***REMOVED***
    hashingStream = new PassThrough();
***REMOVED***

  if (typeof hashingStream.write === 'undefined') ***REMOVED***
    hashingStream.write = hashingStream.update;
    hashingStream.end   = hashingStream.update;
***REMOVED***

  var hasher = typeHasher(options, hashingStream);
  hasher.dispatch(object);
  if (!hashingStream.update) ***REMOVED***
    hashingStream.end('');
***REMOVED***

  if (hashingStream.digest) ***REMOVED***
    return hashingStream.digest(options.encoding === 'buffer' ? undefined : options.encoding);
***REMOVED***

  var buf = hashingStream.read();
  if (options.encoding === 'buffer') ***REMOVED***
    return buf;
***REMOVED***

  return buf.toString(options.encoding);
***REMOVED***

/**
 * Expose streaming API
 *
 * @param ***REMOVED***object***REMOVED*** object  Value to serialize
 * @param ***REMOVED***object***REMOVED*** options  Options, as for hash()
 * @param ***REMOVED***object***REMOVED*** stream  A stream to write the serializiation to
 * @api public
 */
exports.writeToStream = function(object, options, stream) ***REMOVED***
  if (typeof stream === 'undefined') ***REMOVED***
    stream = options;
    options = ***REMOVED******REMOVED***;
***REMOVED***

  options = applyDefaults(object, options);

  return typeHasher(options, stream).dispatch(object);
***REMOVED***;

function typeHasher(options, writeTo, context)***REMOVED***
  context = context || [];
  var write = function(str) ***REMOVED***
    if (writeTo.update) ***REMOVED***
      return writeTo.update(str, 'utf8');
***REMOVED*** else ***REMOVED***
      return writeTo.write(str, 'utf8');
***REMOVED***
***REMOVED***;

  return ***REMOVED***
    dispatch: function(value)***REMOVED***
      if (options.replacer) ***REMOVED***
        value = options.replacer(value);
  ***REMOVED***

      var type = typeof value;
      if (value === null) ***REMOVED***
        type = 'null';
  ***REMOVED***

      //console.log("[DEBUG] Dispatch: ", value, "->", type, " -> ", "_" + type);

      return this['_' + type](value);
***REMOVED***,
    _object: function(object) ***REMOVED***
      var pattern = (/\[object (.*)\]/i);
      var objString = Object.prototype.toString.call(object);
      var objType = pattern.exec(objString);
      if (!objType) ***REMOVED*** // object type did not match [object ...]
        objType = 'unknown:[' + objString + ']';
  ***REMOVED*** else ***REMOVED***
        objType = objType[1]; // take only the class name
  ***REMOVED***

      objType = objType.toLowerCase();

      var objectNumber = null;

      if ((objectNumber = context.indexOf(object)) >= 0) ***REMOVED***
        return this.dispatch('[CIRCULAR:' + objectNumber + ']');
  ***REMOVED*** else ***REMOVED***
        context.push(object);
  ***REMOVED***

      if (typeof Buffer !== 'undefined' && Buffer.isBuffer && Buffer.isBuffer(object)) ***REMOVED***
        write('buffer:');
        return write(object);
  ***REMOVED***

      if(objType !== 'object' && objType !== 'function' && objType !== 'asyncfunction') ***REMOVED***
        if(this['_' + objType]) ***REMOVED***
          this['_' + objType](object);
    ***REMOVED*** else if (options.ignoreUnknown) ***REMOVED***
          return write('[' + objType + ']');
    ***REMOVED*** else ***REMOVED***
          throw new Error('Unknown object type "' + objType + '"');
    ***REMOVED***
  ***REMOVED***else***REMOVED***
        var keys = Object.keys(object);
        if (options.unorderedObjects) ***REMOVED***
          keys = keys.sort();
    ***REMOVED***
        // Make sure to incorporate special properties, so
        // Types with different prototypes will produce
        // a different hash and objects derived from
        // different functions (`new Foo`, `new Bar`) will
        // produce different hashes.
        // We never do this for native functions since some
        // seem to break because of that.
        if (options.respectType !== false && !isNativeFunction(object)) ***REMOVED***
          keys.splice(0, 0, 'prototype', '__proto__', 'constructor');
    ***REMOVED***

        if (options.excludeKeys) ***REMOVED***
          keys = keys.filter(function(key) ***REMOVED*** return !options.excludeKeys(key); ***REMOVED***);
    ***REMOVED***

        write('object:' + keys.length + ':');
        var self = this;
        return keys.forEach(function(key)***REMOVED***
          self.dispatch(key);
          write(':');
          if(!options.excludeValues) ***REMOVED***
            self.dispatch(object[key]);
      ***REMOVED***
          write(',');
    ***REMOVED***);
  ***REMOVED***
***REMOVED***,
    _array: function(arr, unordered)***REMOVED***
      unordered = typeof unordered !== 'undefined' ? unordered :
        options.unorderedArrays !== false; // default to options.unorderedArrays

      var self = this;
      write('array:' + arr.length + ':');
      if (!unordered || arr.length <= 1) ***REMOVED***
        return arr.forEach(function(entry) ***REMOVED***
          return self.dispatch(entry);
    ***REMOVED***);
  ***REMOVED***

      // the unordered case is a little more complicated:
      // since there is no canonical ordering on objects,
      // i.e. ***REMOVED***a:1***REMOVED*** < ***REMOVED***a:2***REMOVED*** and ***REMOVED***a:1***REMOVED*** > ***REMOVED***a:2***REMOVED*** are both false,
      // we first serialize each entry using a PassThrough stream
      // before sorting.
      // also: we can’t use the same context array for all entries
      // since the order of hashing should *not* matter. instead,
      // we keep track of the additions to a copy of the context array
      // and add all of them to the global context array when we’re done
      var contextAdditions = [];
      var entries = arr.map(function(entry) ***REMOVED***
        var strm = new PassThrough();
        var localContext = context.slice(); // make copy
        var hasher = typeHasher(options, strm, localContext);
        hasher.dispatch(entry);
        // take only what was added to localContext and append it to contextAdditions
        contextAdditions = contextAdditions.concat(localContext.slice(context.length));
        return strm.read().toString();
  ***REMOVED***);
      context = context.concat(contextAdditions);
      entries.sort();
      return this._array(entries, false);
***REMOVED***,
    _date: function(date)***REMOVED***
      return write('date:' + date.toJSON());
***REMOVED***,
    _symbol: function(sym)***REMOVED***
      return write('symbol:' + sym.toString());
***REMOVED***,
    _error: function(err)***REMOVED***
      return write('error:' + err.toString());
***REMOVED***,
    _boolean: function(bool)***REMOVED***
      return write('bool:' + bool.toString());
***REMOVED***,
    _string: function(string)***REMOVED***
      write('string:' + string.length + ':');
      write(string.toString());
***REMOVED***,
    _function: function(fn)***REMOVED***
      write('fn:');
      if (isNativeFunction(fn)) ***REMOVED***
        this.dispatch('[native]');
  ***REMOVED*** else ***REMOVED***
        this.dispatch(fn.toString());
  ***REMOVED***

      if (options.respectFunctionNames !== false) ***REMOVED***
        // Make sure we can still distinguish native functions
        // by their name, otherwise String and Function will
        // have the same hash
        this.dispatch("function-name:" + String(fn.name));
  ***REMOVED***

      if (options.respectFunctionProperties) ***REMOVED***
        this._object(fn);
  ***REMOVED***
***REMOVED***,
    _number: function(number)***REMOVED***
      return write('number:' + number.toString());
***REMOVED***,
    _xml: function(xml)***REMOVED***
      return write('xml:' + xml.toString());
***REMOVED***,
    _null: function() ***REMOVED***
      return write('Null');
***REMOVED***,
    _undefined: function() ***REMOVED***
      return write('Undefined');
***REMOVED***,
    _regexp: function(regex)***REMOVED***
      return write('regex:' + regex.toString());
***REMOVED***,
    _uint8array: function(arr)***REMOVED***
      write('uint8array:');
      return this.dispatch(Array.prototype.slice.call(arr));
***REMOVED***,
    _uint8clampedarray: function(arr)***REMOVED***
      write('uint8clampedarray:');
      return this.dispatch(Array.prototype.slice.call(arr));
***REMOVED***,
    _int8array: function(arr)***REMOVED***
      write('int8array:');
      return this.dispatch(Array.prototype.slice.call(arr));
***REMOVED***,
    _uint16array: function(arr)***REMOVED***
      write('uint16array:');
      return this.dispatch(Array.prototype.slice.call(arr));
***REMOVED***,
    _int16array: function(arr)***REMOVED***
      write('int16array:');
      return this.dispatch(Array.prototype.slice.call(arr));
***REMOVED***,
    _uint32array: function(arr)***REMOVED***
      write('uint32array:');
      return this.dispatch(Array.prototype.slice.call(arr));
***REMOVED***,
    _int32array: function(arr)***REMOVED***
      write('int32array:');
      return this.dispatch(Array.prototype.slice.call(arr));
***REMOVED***,
    _float32array: function(arr)***REMOVED***
      write('float32array:');
      return this.dispatch(Array.prototype.slice.call(arr));
***REMOVED***,
    _float64array: function(arr)***REMOVED***
      write('float64array:');
      return this.dispatch(Array.prototype.slice.call(arr));
***REMOVED***,
    _arraybuffer: function(arr)***REMOVED***
      write('arraybuffer:');
      return this.dispatch(new Uint8Array(arr));
***REMOVED***,
    _url: function(url) ***REMOVED***
      return write('url:' + url.toString(), 'utf8');
***REMOVED***,
    _map: function(map) ***REMOVED***
      write('map:');
      var arr = Array.from(map);
      return this._array(arr, options.unorderedSets !== false);
***REMOVED***,
    _set: function(set) ***REMOVED***
      write('set:');
      var arr = Array.from(set);
      return this._array(arr, options.unorderedSets !== false);
***REMOVED***,
    _file: function(file) ***REMOVED***
      write('file:');
      return this.dispatch([file.name, file.size, file.type, file.lastModfied]);
***REMOVED***,
    _blob: function() ***REMOVED***
      if (options.ignoreUnknown) ***REMOVED***
        return write('[blob]');
  ***REMOVED***

      throw Error('Hashing Blob objects is currently not supported\n' +
        '(see https://github.com/puleos/object-hash/issues/26)\n' +
        'Use "options.replacer" or "options.ignoreUnknown"\n');
***REMOVED***,
    _domwindow: function() ***REMOVED*** return write('domwindow'); ***REMOVED***,
    _bigint: function(number)***REMOVED***
      return write('bigint:' + number.toString());
***REMOVED***,
    /* Node.js standard native objects */
    _process: function() ***REMOVED*** return write('process'); ***REMOVED***,
    _timer: function() ***REMOVED*** return write('timer'); ***REMOVED***,
    _pipe: function() ***REMOVED*** return write('pipe'); ***REMOVED***,
    _tcp: function() ***REMOVED*** return write('tcp'); ***REMOVED***,
    _udp: function() ***REMOVED*** return write('udp'); ***REMOVED***,
    _tty: function() ***REMOVED*** return write('tty'); ***REMOVED***,
    _statwatcher: function() ***REMOVED*** return write('statwatcher'); ***REMOVED***,
    _securecontext: function() ***REMOVED*** return write('securecontext'); ***REMOVED***,
    _connection: function() ***REMOVED*** return write('connection'); ***REMOVED***,
    _zlib: function() ***REMOVED*** return write('zlib'); ***REMOVED***,
    _context: function() ***REMOVED*** return write('context'); ***REMOVED***,
    _nodescript: function() ***REMOVED*** return write('nodescript'); ***REMOVED***,
    _httpparser: function() ***REMOVED*** return write('httpparser'); ***REMOVED***,
    _dataview: function() ***REMOVED*** return write('dataview'); ***REMOVED***,
    _signal: function() ***REMOVED*** return write('signal'); ***REMOVED***,
    _fsevent: function() ***REMOVED*** return write('fsevent'); ***REMOVED***,
    _tlswrap: function() ***REMOVED*** return write('tlswrap'); ***REMOVED***,
***REMOVED***;
***REMOVED***

// Mini-implementation of stream.PassThrough
// We are far from having need for the full implementation, and we can
// make assumptions like "many writes, then only one final read"
// and we can ignore encoding specifics
function PassThrough() ***REMOVED***
  return ***REMOVED***
    buf: '',

    write: function(b) ***REMOVED***
      this.buf += b;
***REMOVED***,

    end: function(b) ***REMOVED***
      this.buf += b;
***REMOVED***,

    read: function() ***REMOVED***
      return this.buf;
***REMOVED***
***REMOVED***;
***REMOVED***
