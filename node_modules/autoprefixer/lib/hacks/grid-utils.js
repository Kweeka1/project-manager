let parser = require('postcss-value-parser')
let list = require('postcss').list

let uniq = require('../utils').uniq
let escapeRegexp = require('../utils').escapeRegexp
let splitSelector = require('../utils').splitSelector

function convert(value) ***REMOVED***
  if (
    value &&
    value.length === 2 &&
    value[0] === 'span' &&
    parseInt(value[1], 10) > 0
  ) ***REMOVED***
    return [false, parseInt(value[1], 10)]
***REMOVED***

  if (value && value.length === 1 && parseInt(value[0], 10) > 0) ***REMOVED***
    return [parseInt(value[0], 10), false]
***REMOVED***

  return [false, false]
***REMOVED***

exports.translate = translate

function translate(values, startIndex, endIndex) ***REMOVED***
  let startValue = values[startIndex]
  let endValue = values[endIndex]

  if (!startValue) ***REMOVED***
    return [false, false]
***REMOVED***

  let [start, spanStart] = convert(startValue)
  let [end, spanEnd] = convert(endValue)

  if (start && !endValue) ***REMOVED***
    return [start, false]
***REMOVED***

  if (spanStart && end) ***REMOVED***
    return [end - spanStart, spanStart]
***REMOVED***

  if (start && spanEnd) ***REMOVED***
    return [start, spanEnd]
***REMOVED***

  if (start && end) ***REMOVED***
    return [start, end - start]
***REMOVED***

  return [false, false]
***REMOVED***

exports.parse = parse

function parse(decl) ***REMOVED***
  let node = parser(decl.value)

  let values = []
  let current = 0
  values[current] = []

  for (let i of node.nodes) ***REMOVED***
    if (i.type === 'div') ***REMOVED***
      current += 1
      values[current] = []
***REMOVED*** else if (i.type === 'word') ***REMOVED***
      values[current].push(i.value)
***REMOVED***
***REMOVED***

  return values
***REMOVED***

exports.insertDecl = insertDecl

function insertDecl(decl, prop, value) ***REMOVED***
  if (value && !decl.parent.some(i => i.prop === `-ms-$***REMOVED***prop***REMOVED***`)) ***REMOVED***
    decl.cloneBefore(***REMOVED***
      prop: `-ms-$***REMOVED***prop***REMOVED***`,
      value: value.toString()
***REMOVED***)
***REMOVED***
***REMOVED***

// Track transforms

exports.prefixTrackProp = prefixTrackProp

function prefixTrackProp(***REMOVED*** prop, prefix ***REMOVED***) ***REMOVED***
  return prefix + prop.replace('template-', '')
***REMOVED***

function transformRepeat(***REMOVED*** nodes ***REMOVED***, ***REMOVED*** gap ***REMOVED***) ***REMOVED***
  let ***REMOVED*** count, size ***REMOVED*** = nodes.reduce(
    (result, node) => ***REMOVED***
      if (node.type === 'div' && node.value === ',') ***REMOVED***
        result.key = 'size'
  ***REMOVED*** else ***REMOVED***
        result[result.key].push(parser.stringify(node))
  ***REMOVED***
      return result
***REMOVED***,
    ***REMOVED***
      key: 'count',
      size: [],
      count: []
***REMOVED***
  )

  // insert gap values
  if (gap) ***REMOVED***
    size = size.filter(i => i.trim())
    let val = []
    for (let i = 1; i <= count; i++) ***REMOVED***
      size.forEach((item, index) => ***REMOVED***
        if (index > 0 || i > 1) ***REMOVED***
          val.push(gap)
    ***REMOVED***
        val.push(item)
  ***REMOVED***)
***REMOVED***

    return val.join(' ')
***REMOVED***

  return `($***REMOVED***size.join('')***REMOVED***)[$***REMOVED***count.join('')***REMOVED***]`
***REMOVED***

exports.prefixTrackValue = prefixTrackValue

function prefixTrackValue(***REMOVED*** value, gap ***REMOVED***) ***REMOVED***
  let result = parser(value).nodes.reduce((nodes, node) => ***REMOVED***
    if (node.type === 'function' && node.value === 'repeat') ***REMOVED***
      return nodes.concat(***REMOVED***
        type: 'word',
        value: transformRepeat(node, ***REMOVED*** gap ***REMOVED***)
  ***REMOVED***)
***REMOVED***
    if (gap && node.type === 'space') ***REMOVED***
      return nodes.concat(
        ***REMOVED***
          type: 'space',
          value: ' '
    ***REMOVED***,
        ***REMOVED***
          type: 'word',
          value: gap
    ***REMOVED***,
        node
      )
***REMOVED***
    return nodes.concat(node)
***REMOVED*** [])

  return parser.stringify(result)
***REMOVED***

// Parse grid-template-areas

let DOTS = /^\.+$/

function track(start, end) ***REMOVED***
  return ***REMOVED*** start, end, span: end - start ***REMOVED***
***REMOVED***

function getColumns(line) ***REMOVED***
  return line.trim().split(/\s+/g)
***REMOVED***

exports.parseGridAreas = parseGridAreas

function parseGridAreas(***REMOVED*** rows, gap ***REMOVED***) ***REMOVED***
  return rows.reduce((areas, line, rowIndex) => ***REMOVED***
    if (gap.row) rowIndex *= 2

    if (line.trim() === '') return areas

    getColumns(line).forEach((area, columnIndex) => ***REMOVED***
      if (DOTS.test(area)) return

      if (gap.column) columnIndex *= 2

      if (typeof areas[area] === 'undefined') ***REMOVED***
        areas[area] = ***REMOVED***
          column: track(columnIndex + 1, columnIndex + 2),
          row: track(rowIndex + 1, rowIndex + 2)
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
        let ***REMOVED*** column, row ***REMOVED*** = areas[area]

        column.start = Math.min(column.start, columnIndex + 1)
        column.end = Math.max(column.end, columnIndex + 2)
        column.span = column.end - column.start

        row.start = Math.min(row.start, rowIndex + 1)
        row.end = Math.max(row.end, rowIndex + 2)
        row.span = row.end - row.start
  ***REMOVED***
***REMOVED***)

    return areas
***REMOVED*** ***REMOVED******REMOVED***)
***REMOVED***

// Parse grid-template

function testTrack(node) ***REMOVED***
  return node.type === 'word' && /^\[.+]$/.test(node.value)
***REMOVED***

function verifyRowSize(result) ***REMOVED***
  if (result.areas.length > result.rows.length) ***REMOVED***
    result.rows.push('auto')
***REMOVED***
  return result
***REMOVED***

exports.parseTemplate = parseTemplate

function parseTemplate(***REMOVED*** decl, gap ***REMOVED***) ***REMOVED***
  let gridTemplate = parser(decl.value).nodes.reduce(
    (result, node) => ***REMOVED***
      let ***REMOVED*** type, value ***REMOVED*** = node

      if (testTrack(node) || type === 'space') return result

      // area
      if (type === 'string') ***REMOVED***
        result = verifyRowSize(result)
        result.areas.push(value)
  ***REMOVED***

      // values and function
      if (type === 'word' || type === 'function') ***REMOVED***
        result[result.key].push(parser.stringify(node))
  ***REMOVED***

      // divider(/)
      if (type === 'div' && value === '/') ***REMOVED***
        result.key = 'columns'
        result = verifyRowSize(result)
  ***REMOVED***

      return result
***REMOVED***,
    ***REMOVED***
      key: 'rows',
      columns: [],
      rows: [],
      areas: []
***REMOVED***
  )

  return ***REMOVED***
    areas: parseGridAreas(***REMOVED***
      rows: gridTemplate.areas,
      gap
***REMOVED***),
    columns: prefixTrackValue(***REMOVED***
      value: gridTemplate.columns.join(' '),
      gap: gap.column
***REMOVED***),
    rows: prefixTrackValue(***REMOVED***
      value: gridTemplate.rows.join(' '),
      gap: gap.row
***REMOVED***)
***REMOVED***
***REMOVED***

// Insert parsed grid areas

/**
 * Get an array of -ms- prefixed props and values
 * @param  ***REMOVED***Object***REMOVED*** [area] area object with column and row data
 * @param  ***REMOVED***Boolean***REMOVED*** [addRowSpan] should we add grid-column-row value?
 * @param  ***REMOVED***Boolean***REMOVED*** [addColumnSpan] should we add grid-column-span value?
 * @return ***REMOVED***Array<Object>***REMOVED***
 */
function getMSDecls(area, addRowSpan = false, addColumnSpan = false) ***REMOVED***
  let result = [
    ***REMOVED***
      prop: '-ms-grid-row',
      value: String(area.row.start)
***REMOVED***
  ]
  if (area.row.span > 1 || addRowSpan) ***REMOVED***
    result.push(***REMOVED***
      prop: '-ms-grid-row-span',
      value: String(area.row.span)
***REMOVED***)
***REMOVED***
  result.push(***REMOVED***
    prop: '-ms-grid-column',
    value: String(area.column.start)
***REMOVED***)
  if (area.column.span > 1 || addColumnSpan) ***REMOVED***
    result.push(***REMOVED***
      prop: '-ms-grid-column-span',
      value: String(area.column.span)
***REMOVED***)
***REMOVED***
  return result
***REMOVED***

function getParentMedia(parent) ***REMOVED***
  if (parent.type === 'atrule' && parent.name === 'media') ***REMOVED***
    return parent
***REMOVED***
  if (!parent.parent) ***REMOVED***
    return false
***REMOVED***
  return getParentMedia(parent.parent)
***REMOVED***

/**
 * change selectors for rules with duplicate grid-areas.
 * @param  ***REMOVED***Array<Rule>***REMOVED*** rules
 * @param  ***REMOVED***Array<String>***REMOVED*** templateSelectors
 * @return ***REMOVED***Array<Rule>***REMOVED*** rules with changed selectors
 */
function changeDuplicateAreaSelectors(ruleSelectors, templateSelectors) ***REMOVED***
  ruleSelectors = ruleSelectors.map(selector => ***REMOVED***
    let selectorBySpace = list.space(selector)
    let selectorByComma = list.comma(selector)

    if (selectorBySpace.length > selectorByComma.length) ***REMOVED***
      selector = selectorBySpace.slice(-1).join('')
***REMOVED***
    return selector
***REMOVED***)

  return ruleSelectors.map(ruleSelector => ***REMOVED***
    let newSelector = templateSelectors.map((tplSelector, index) => ***REMOVED***
      let space = index === 0 ? '' : ' '
      return `$***REMOVED***space***REMOVED***$***REMOVED***tplSelector***REMOVED*** > $***REMOVED***ruleSelector***REMOVED***`
***REMOVED***)

    return newSelector
***REMOVED***)
***REMOVED***

/**
 * check if selector of rules are equal
 * @param  ***REMOVED***Rule***REMOVED*** ruleA
 * @param  ***REMOVED***Rule***REMOVED*** ruleB
 * @return ***REMOVED***Boolean***REMOVED***
 */
function selectorsEqual(ruleA, ruleB) ***REMOVED***
  return ruleA.selectors.some(sel => ***REMOVED***
    return ruleB.selectors.includes(sel)
***REMOVED***)
***REMOVED***

/**
 * Parse data from all grid-template(-areas) declarations
 * @param  ***REMOVED***Root***REMOVED*** css css root
 * @return ***REMOVED***Object***REMOVED*** parsed data
 */
function parseGridTemplatesData(css) ***REMOVED***
  let parsed = []

  // we walk through every grid-template(-areas) declaration and store
  // data with the same area names inside the item
  css.walkDecls(/grid-template(-areas)?$/, d => ***REMOVED***
    let rule = d.parent
    let media = getParentMedia(rule)
    let gap = getGridGap(d)
    let inheritedGap = inheritGridGap(d, gap)
    let ***REMOVED*** areas ***REMOVED*** = parseTemplate(***REMOVED*** decl: d, gap: inheritedGap || gap ***REMOVED***)
    let areaNames = Object.keys(areas)

    // skip node if it doesn't have areas
    if (areaNames.length === 0) ***REMOVED***
      return true
***REMOVED***

    // check parsed array for item that include the same area names
    // return index of that item
    let index = parsed.reduce((acc, ***REMOVED*** allAreas ***REMOVED***, idx) => ***REMOVED***
      let hasAreas = allAreas && areaNames.some(area => allAreas.includes(area))
      return hasAreas ? idx : acc
***REMOVED***, null)

    if (index !== null) ***REMOVED***
      // index is found, add the grid-template data to that item
      let ***REMOVED*** allAreas, rules ***REMOVED*** = parsed[index]

      // check if rule has no duplicate area names
      let hasNoDuplicates = rules.some(r => ***REMOVED***
        return r.hasDuplicates === false && selectorsEqual(r, rule)
  ***REMOVED***)

      let duplicatesFound = false

      // check need to gather all duplicate area names
      let duplicateAreaNames = rules.reduce((acc, r) => ***REMOVED***
        if (!r.params && selectorsEqual(r, rule)) ***REMOVED***
          duplicatesFound = true
          return r.duplicateAreaNames
    ***REMOVED***
        if (!duplicatesFound) ***REMOVED***
          areaNames.forEach(name => ***REMOVED***
            if (r.areas[name]) ***REMOVED***
              acc.push(name)
        ***REMOVED***
      ***REMOVED***)
    ***REMOVED***
        return uniq(acc)
  ***REMOVED***, [])

      // update grid-row/column-span values for areas with duplicate
      // area names. @see #1084 and #1146
      rules.forEach(r => ***REMOVED***
        areaNames.forEach(name => ***REMOVED***
          let area = r.areas[name]
          if (area && area.row.span !== areas[name].row.span) ***REMOVED***
            areas[name].row.updateSpan = true
      ***REMOVED***

          if (area && area.column.span !== areas[name].column.span) ***REMOVED***
            areas[name].column.updateSpan = true
      ***REMOVED***
    ***REMOVED***)
  ***REMOVED***)

      parsed[index].allAreas = uniq([...allAreas, ...areaNames])
      parsed[index].rules.push(***REMOVED***
        hasDuplicates: !hasNoDuplicates,
        params: media.params,
        selectors: rule.selectors,
        node: rule,
        duplicateAreaNames,
        areas
  ***REMOVED***)
***REMOVED*** else ***REMOVED***
      // index is NOT found, push the new item to the parsed array
      parsed.push(***REMOVED***
        allAreas: areaNames,
        areasCount: 0,
        rules: [
          ***REMOVED***
            hasDuplicates: false,
            duplicateRules: [],
            params: media.params,
            selectors: rule.selectors,
            node: rule,
            duplicateAreaNames: [],
            areas
      ***REMOVED***
        ]
  ***REMOVED***)
***REMOVED***

    return undefined
***REMOVED***)

  return parsed
***REMOVED***

/**
 * insert prefixed grid-area declarations
 * @param  ***REMOVED***Root***REMOVED***  css css root
 * @param  ***REMOVED***Function***REMOVED*** isDisabled check if the rule is disabled
 * @return ***REMOVED***void***REMOVED***
 */
exports.insertAreas = insertAreas

function insertAreas(css, isDisabled) ***REMOVED***
  // parse grid-template declarations
  let gridTemplatesData = parseGridTemplatesData(css)

  // return undefined if no declarations found
  if (gridTemplatesData.length === 0) ***REMOVED***
    return undefined
***REMOVED***

  // we need to store the rules that we will insert later
  let rulesToInsert = ***REMOVED******REMOVED***

  css.walkDecls('grid-area', gridArea => ***REMOVED***
    let gridAreaRule = gridArea.parent
    let hasPrefixedRow = gridAreaRule.first.prop === '-ms-grid-row'
    let gridAreaMedia = getParentMedia(gridAreaRule)

    if (isDisabled(gridArea)) ***REMOVED***
      return undefined
***REMOVED***

    let gridAreaRuleIndex = css.index(gridAreaMedia || gridAreaRule)

    let value = gridArea.value
    // found the data that matches grid-area identifier
    let data = gridTemplatesData.filter(d => d.allAreas.includes(value))[0]

    if (!data) ***REMOVED***
      return true
***REMOVED***

    let lastArea = data.allAreas[data.allAreas.length - 1]
    let selectorBySpace = list.space(gridAreaRule.selector)
    let selectorByComma = list.comma(gridAreaRule.selector)
    let selectorIsComplex =
      selectorBySpace.length > 1 &&
      selectorBySpace.length > selectorByComma.length

    // prevent doubling of prefixes
    if (hasPrefixedRow) ***REMOVED***
      return false
***REMOVED***

    // create the empty object with the key as the last area name
    // e.g if we have templates with "a b c" values, "c" will be the last area
    if (!rulesToInsert[lastArea]) ***REMOVED***
      rulesToInsert[lastArea] = ***REMOVED******REMOVED***
***REMOVED***

    let lastRuleIsSet = false

    // walk through every grid-template rule data
    for (let rule of data.rules) ***REMOVED***
      let area = rule.areas[value]
      let hasDuplicateName = rule.duplicateAreaNames.includes(value)

      // if we can't find the area name, update lastRule and continue
      if (!area) ***REMOVED***
        let lastRule = rulesToInsert[lastArea].lastRule
        let lastRuleIndex
        if (lastRule) ***REMOVED***
          lastRuleIndex = css.index(lastRule)
    ***REMOVED*** else ***REMOVED***
          /* c8 ignore next 2 */
          lastRuleIndex = -1
    ***REMOVED***

        if (gridAreaRuleIndex > lastRuleIndex) ***REMOVED***
          rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule
    ***REMOVED***
        continue
  ***REMOVED***

      // for grid-templates inside media rule we need to create empty
      // array to push prefixed grid-area rules later
      if (rule.params && !rulesToInsert[lastArea][rule.params]) ***REMOVED***
        rulesToInsert[lastArea][rule.params] = []
  ***REMOVED***

      if ((!rule.hasDuplicates || !hasDuplicateName) && !rule.params) ***REMOVED***
        // grid-template has no duplicates and not inside media rule

        getMSDecls(area, false, false)
          .reverse()
          .forEach(i =>
            gridAreaRule.prepend(
              Object.assign(i, ***REMOVED***
                raws: ***REMOVED***
                  between: gridArea.raws.between
            ***REMOVED***
          ***REMOVED***)
            )
          )

        rulesToInsert[lastArea].lastRule = gridAreaRule
        lastRuleIsSet = true
  ***REMOVED*** else if (rule.hasDuplicates && !rule.params && !selectorIsComplex) ***REMOVED***
        // grid-template has duplicates and not inside media rule
        let cloned = gridAreaRule.clone()
        cloned.removeAll()

        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)
          .reverse()
          .forEach(i =>
            cloned.prepend(
              Object.assign(i, ***REMOVED***
                raws: ***REMOVED***
                  between: gridArea.raws.between
            ***REMOVED***
          ***REMOVED***)
            )
          )

        cloned.selectors = changeDuplicateAreaSelectors(
          cloned.selectors,
          rule.selectors
        )

        if (rulesToInsert[lastArea].lastRule) ***REMOVED***
          rulesToInsert[lastArea].lastRule.after(cloned)
    ***REMOVED***
        rulesToInsert[lastArea].lastRule = cloned
        lastRuleIsSet = true
  ***REMOVED*** else if (
        rule.hasDuplicates &&
        !rule.params &&
        selectorIsComplex &&
        gridAreaRule.selector.includes(rule.selectors[0])
      ) ***REMOVED***
        // grid-template has duplicates and not inside media rule
        // and the selector is complex
        gridAreaRule.walkDecls(/-ms-grid-(row|column)/, d => d.remove())
        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)
          .reverse()
          .forEach(i =>
            gridAreaRule.prepend(
              Object.assign(i, ***REMOVED***
                raws: ***REMOVED***
                  between: gridArea.raws.between
            ***REMOVED***
          ***REMOVED***)
            )
          )
  ***REMOVED*** else if (rule.params) ***REMOVED***
        // grid-template is inside media rule
        // if we're inside media rule, we need to store prefixed rules
        // inside rulesToInsert object to be able to preserve the order of media
        // rules and merge them easily
        let cloned = gridAreaRule.clone()
        cloned.removeAll()

        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)
          .reverse()
          .forEach(i =>
            cloned.prepend(
              Object.assign(i, ***REMOVED***
                raws: ***REMOVED***
                  between: gridArea.raws.between
            ***REMOVED***
          ***REMOVED***)
            )
          )

        if (rule.hasDuplicates && hasDuplicateName) ***REMOVED***
          cloned.selectors = changeDuplicateAreaSelectors(
            cloned.selectors,
            rule.selectors
          )
    ***REMOVED***

        cloned.raws = rule.node.raws

        if (css.index(rule.node.parent) > gridAreaRuleIndex) ***REMOVED***
          // append the prefixed rules right inside media rule
          // with grid-template
          rule.node.parent.append(cloned)
    ***REMOVED*** else ***REMOVED***
          // store the rule to insert later
          rulesToInsert[lastArea][rule.params].push(cloned)
    ***REMOVED***

        // set new rule as last rule ONLY if we didn't set lastRule for
        // this grid-area before
        if (!lastRuleIsSet) ***REMOVED***
          rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule
    ***REMOVED***
  ***REMOVED***
***REMOVED***

    return undefined
***REMOVED***)

  // append stored rules inside the media rules
  Object.keys(rulesToInsert).forEach(area => ***REMOVED***
    let data = rulesToInsert[area]
    let lastRule = data.lastRule
    Object.keys(data)
      .reverse()
      .filter(p => p !== 'lastRule')
      .forEach(params => ***REMOVED***
        if (data[params].length > 0 && lastRule) ***REMOVED***
          lastRule.after(***REMOVED*** name: 'media', params ***REMOVED***)
          lastRule.next().append(data[params])
    ***REMOVED***
  ***REMOVED***)
***REMOVED***)

  return undefined
***REMOVED***

/**
 * Warn user if grid area identifiers are not found
 * @param  ***REMOVED***Object***REMOVED*** areas
 * @param  ***REMOVED***Declaration***REMOVED*** decl
 * @param  ***REMOVED***Result***REMOVED*** result
 * @return ***REMOVED***void***REMOVED***
 */
exports.warnMissedAreas = warnMissedAreas

function warnMissedAreas(areas, decl, result) ***REMOVED***
  let missed = Object.keys(areas)

  decl.root().walkDecls('grid-area', gridArea => ***REMOVED***
    missed = missed.filter(e => e !== gridArea.value)
***REMOVED***)

  if (missed.length > 0) ***REMOVED***
    decl.warn(result, 'Can not find grid areas: ' + missed.join(', '))
***REMOVED***

  return undefined
***REMOVED***

/**
 * compare selectors with grid-area rule and grid-template rule
 * show warning if grid-template selector is not found
 * (this function used for grid-area rule)
 * @param  ***REMOVED***Declaration***REMOVED*** decl
 * @param  ***REMOVED***Result***REMOVED*** result
 * @return ***REMOVED***void***REMOVED***
 */
exports.warnTemplateSelectorNotFound = warnTemplateSelectorNotFound

function warnTemplateSelectorNotFound(decl, result) ***REMOVED***
  let rule = decl.parent
  let root = decl.root()
  let duplicatesFound = false

  // slice selector array. Remove the last part (for comparison)
  let slicedSelectorArr = list
    .space(rule.selector)
    .filter(str => str !== '>')
    .slice(0, -1)

  // we need to compare only if selector is complex.
  // e.g '.grid-cell' is simple, but '.parent > .grid-cell' is complex
  if (slicedSelectorArr.length > 0) ***REMOVED***
    let gridTemplateFound = false
    let foundAreaSelector = null

    root.walkDecls(/grid-template(-areas)?$/, d => ***REMOVED***
      let parent = d.parent
      let templateSelectors = parent.selectors

      let ***REMOVED*** areas ***REMOVED*** = parseTemplate(***REMOVED*** decl: d, gap: getGridGap(d) ***REMOVED***)
      let hasArea = areas[decl.value]

      // find the the matching selectors
      for (let tplSelector of templateSelectors) ***REMOVED***
        if (gridTemplateFound) ***REMOVED***
          break
    ***REMOVED***
        let tplSelectorArr = list.space(tplSelector).filter(str => str !== '>')

        gridTemplateFound = tplSelectorArr.every(
          (item, idx) => item === slicedSelectorArr[idx]
        )
  ***REMOVED***

      if (gridTemplateFound || !hasArea) ***REMOVED***
        return true
  ***REMOVED***

      if (!foundAreaSelector) ***REMOVED***
        foundAreaSelector = parent.selector
  ***REMOVED***

      // if we found the duplicate area with different selector
      if (foundAreaSelector && foundAreaSelector !== parent.selector) ***REMOVED***
        duplicatesFound = true
  ***REMOVED***

      return undefined
***REMOVED***)

    // warn user if we didn't find template
    if (!gridTemplateFound && duplicatesFound) ***REMOVED***
      decl.warn(
        result,
        'Autoprefixer cannot find a grid-template ' +
          `containing the duplicate grid-area "$***REMOVED***decl.value***REMOVED***" ` +
          `with full selector matching: $***REMOVED***slicedSelectorArr.join(' ')***REMOVED***`
      )
***REMOVED***
***REMOVED***
***REMOVED***

/**
 * warn user if both grid-area and grid-(row|column)
 * declarations are present in the same rule
 * @param  ***REMOVED***Declaration***REMOVED*** decl
 * @param  ***REMOVED***Result***REMOVED*** result
 * @return ***REMOVED***void***REMOVED***
 */
exports.warnIfGridRowColumnExists = warnIfGridRowColumnExists

function warnIfGridRowColumnExists(decl, result) ***REMOVED***
  let rule = decl.parent
  let decls = []
  rule.walkDecls(/^grid-(row|column)/, d => ***REMOVED***
    if (
      !d.prop.endsWith('-end') &&
      !d.value.startsWith('span') &&
      !d.prop.endsWith('-gap')
    ) ***REMOVED***
      decls.push(d)
***REMOVED***
***REMOVED***)
  if (decls.length > 0) ***REMOVED***
    decls.forEach(d => ***REMOVED***
      d.warn(
        result,
        'You already have a grid-area declaration present in the rule. ' +
          `You should use either grid-area or $***REMOVED***d.prop***REMOVED***, not both`
      )
***REMOVED***)
***REMOVED***

  return undefined
***REMOVED***

// Gap utils

exports.getGridGap = getGridGap

function getGridGap(decl) ***REMOVED***
  let gap = ***REMOVED******REMOVED***

  // try to find gap
  let testGap = /^(grid-)?((row|column)-)?gap$/
  decl.parent.walkDecls(testGap, (***REMOVED*** prop, value ***REMOVED***) => ***REMOVED***
    if (/^(grid-)?gap$/.test(prop)) ***REMOVED***
      let [row, , column] = parser(value).nodes

      gap.row = row && parser.stringify(row)
      gap.column = column ? parser.stringify(column) : gap.row
***REMOVED***
    if (/^(grid-)?row-gap$/.test(prop)) gap.row = value
    if (/^(grid-)?column-gap$/.test(prop)) gap.column = value
***REMOVED***)

  return gap
***REMOVED***

/**
 * parse media parameters (for example 'min-width: 500px')
 * @param  ***REMOVED***String***REMOVED*** params parameter to parse
 * @return ***REMOVED******REMOVED***
 */
function parseMediaParams(params) ***REMOVED***
  if (!params) ***REMOVED***
    return []
***REMOVED***
  let parsed = parser(params)
  let prop
  let value

  parsed.walk(node => ***REMOVED***
    if (node.type === 'word' && /min|max/g.test(node.value)) ***REMOVED***
      prop = node.value
***REMOVED*** else if (node.value.includes('px')) ***REMOVED***
      value = parseInt(node.value.replace(/\D/g, ''))
***REMOVED***
***REMOVED***)

  return [prop, value]
***REMOVED***

/**
 * Compare the selectors and decide if we
 * need to inherit gap from compared selector or not.
 * @type ***REMOVED***String***REMOVED*** selA
 * @type ***REMOVED***String***REMOVED*** selB
 * @return ***REMOVED***Boolean***REMOVED***
 */
function shouldInheritGap(selA, selB) ***REMOVED***
  let result

  // get arrays of selector split in 3-deep array
  let splitSelectorArrA = splitSelector(selA)
  let splitSelectorArrB = splitSelector(selB)

  if (splitSelectorArrA[0].length < splitSelectorArrB[0].length) ***REMOVED***
    // abort if selectorA has lower descendant specificity then selectorB
    // (e.g '.grid' and '.hello .world .grid')
    return false
***REMOVED*** else if (splitSelectorArrA[0].length > splitSelectorArrB[0].length) ***REMOVED***
    // if selectorA has higher descendant specificity then selectorB
    // (e.g '.foo .bar .grid' and '.grid')

    let idx = splitSelectorArrA[0].reduce((res, [item], index) => ***REMOVED***
      let firstSelectorPart = splitSelectorArrB[0][0][0]
      if (item === firstSelectorPart) ***REMOVED***
        return index
  ***REMOVED***
      return false
***REMOVED***, false)

    if (idx) ***REMOVED***
      result = splitSelectorArrB[0].every((arr, index) => ***REMOVED***
        return arr.every(
          (part, innerIndex) =>
            // because selectorA has more space elements, we need to slice
            // selectorA array by 'idx' number to compare them
            splitSelectorArrA[0].slice(idx)[index][innerIndex] === part
        )
  ***REMOVED***)
***REMOVED***
***REMOVED*** else ***REMOVED***
    // if selectorA has the same descendant specificity as selectorB
    // this condition covers cases such as: '.grid.foo.bar' and '.grid'
    result = splitSelectorArrB.some(byCommaArr => ***REMOVED***
      return byCommaArr.every((bySpaceArr, index) => ***REMOVED***
        return bySpaceArr.every(
          (part, innerIndex) => splitSelectorArrA[0][index][innerIndex] === part
        )
  ***REMOVED***)
***REMOVED***)
***REMOVED***

  return result
***REMOVED***
/**
 * inherit grid gap values from the closest rule above
 * with the same selector
 * @param  ***REMOVED***Declaration***REMOVED*** decl
 * @param  ***REMOVED***Object***REMOVED*** gap gap values
 * @return ***REMOVED***Object | Boolean***REMOVED*** return gap values or false (if not found)
 */
exports.inheritGridGap = inheritGridGap

function inheritGridGap(decl, gap) ***REMOVED***
  let rule = decl.parent
  let mediaRule = getParentMedia(rule)
  let root = rule.root()

  // get an array of selector split in 3-deep array
  let splitSelectorArr = splitSelector(rule.selector)

  // abort if the rule already has gaps
  if (Object.keys(gap).length > 0) ***REMOVED***
    return false
***REMOVED***

  // e.g ['min-width']
  let [prop] = parseMediaParams(mediaRule.params)

  let lastBySpace = splitSelectorArr[0]

  // get escaped value from the selector
  // if we have '.grid-2.foo.bar' selector, will be '\.grid\-2'
  let escaped = escapeRegexp(lastBySpace[lastBySpace.length - 1][0])

  let regexp = new RegExp(`($***REMOVED***escaped***REMOVED***$)|($***REMOVED***escaped***REMOVED***[,.])`)

  // find the closest rule with the same selector
  let closestRuleGap
  root.walkRules(regexp, r => ***REMOVED***
    let gridGap

    // abort if are checking the same rule
    if (rule.toString() === r.toString()) ***REMOVED***
      return false
***REMOVED***

    // find grid-gap values
    r.walkDecls('grid-gap', d => (gridGap = getGridGap(d)))

    // skip rule without gaps
    if (!gridGap || Object.keys(gridGap).length === 0) ***REMOVED***
      return true
***REMOVED***

    // skip rules that should not be inherited from
    if (!shouldInheritGap(rule.selector, r.selector)) ***REMOVED***
      return true
***REMOVED***

    let media = getParentMedia(r)
    if (media) ***REMOVED***
      // if we are inside media, we need to check that media props match
      // e.g ('min-width' === 'min-width')
      let propToCompare = parseMediaParams(media.params)[0]
      if (propToCompare === prop) ***REMOVED***
        closestRuleGap = gridGap
        return true
  ***REMOVED***
***REMOVED*** else ***REMOVED***
      closestRuleGap = gridGap
      return true
***REMOVED***

    return undefined
***REMOVED***)

  // if we find the closest gap object
  if (closestRuleGap && Object.keys(closestRuleGap).length > 0) ***REMOVED***
    return closestRuleGap
***REMOVED***
  return false
***REMOVED***

exports.warnGridGap = warnGridGap

function warnGridGap(***REMOVED*** gap, hasColumns, decl, result ***REMOVED***) ***REMOVED***
  let hasBothGaps = gap.row && gap.column
  if (!hasColumns && (hasBothGaps || (gap.column && !gap.row))) ***REMOVED***
    delete gap.column
    decl.warn(
      result,
      'Can not implement grid-gap without grid-template-columns'
    )
***REMOVED***
***REMOVED***

/**
 * normalize the grid-template-rows/columns values
 * @param  ***REMOVED***String***REMOVED*** str grid-template-rows/columns value
 * @return ***REMOVED***Array***REMOVED*** normalized array with values
 * @example
 * let normalized = normalizeRowColumn('1fr repeat(2, 20px 50px) 1fr')
 * normalized // <= ['1fr', '20px', '50px', '20px', '50px', '1fr']
 */
function normalizeRowColumn(str) ***REMOVED***
  let normalized = parser(str).nodes.reduce((result, node) => ***REMOVED***
    if (node.type === 'function' && node.value === 'repeat') ***REMOVED***
      let key = 'count'

      let [count, value] = node.nodes.reduce(
        (acc, n) => ***REMOVED***
          if (n.type === 'word' && key === 'count') ***REMOVED***
            acc[0] = Math.abs(parseInt(n.value))
            return acc
      ***REMOVED***
          if (n.type === 'div' && n.value === ',') ***REMOVED***
            key = 'value'
            return acc
      ***REMOVED***
          if (key === 'value') ***REMOVED***
            acc[1] += parser.stringify(n)
      ***REMOVED***
          return acc
    ***REMOVED***,
        [0, '']
      )

      if (count) ***REMOVED***
        for (let i = 0; i < count; i++) ***REMOVED***
          result.push(value)
    ***REMOVED***
  ***REMOVED***

      return result
***REMOVED***
    if (node.type === 'space') ***REMOVED***
      return result
***REMOVED***
    return result.concat(parser.stringify(node))
***REMOVED*** [])

  return normalized
***REMOVED***

exports.autoplaceGridItems = autoplaceGridItems

/**
 * Autoplace grid items
 * @param ***REMOVED***Declaration***REMOVED*** decl
 * @param ***REMOVED***Result***REMOVED*** result
 * @param ***REMOVED***Object***REMOVED*** gap gap values
 * @param ***REMOVED***String***REMOVED*** autoflowValue grid-auto-flow value
 * @return ***REMOVED***void***REMOVED***
 * @see https://github.com/postcss/autoprefixer/issues/1148
 */
function autoplaceGridItems(decl, result, gap, autoflowValue = 'row') ***REMOVED***
  let ***REMOVED*** parent ***REMOVED*** = decl

  let rowDecl = parent.nodes.find(i => i.prop === 'grid-template-rows')
  let rows = normalizeRowColumn(rowDecl.value)
  let columns = normalizeRowColumn(decl.value)

  // Build array of area names with dummy values. If we have 3 columns and
  // 2 rows, filledRows will be equal to ['1 2 3', '4 5 6']
  let filledRows = rows.map((_, rowIndex) => ***REMOVED***
    return Array.from(
      ***REMOVED*** length: columns.length ***REMOVED***,
      (v, k) => k + rowIndex * columns.length + 1
    ).join(' ')
***REMOVED***)

  let areas = parseGridAreas(***REMOVED*** rows: filledRows, gap ***REMOVED***)
  let keys = Object.keys(areas)
  let items = keys.map(i => areas[i])

  // Change the order of cells if grid-auto-flow value is 'column'
  if (autoflowValue.includes('column')) ***REMOVED***
    items = items.sort((a, b) => a.column.start - b.column.start)
***REMOVED***

  // Insert new rules
  items.reverse().forEach((item, index) => ***REMOVED***
    let ***REMOVED*** column, row ***REMOVED*** = item
    let nodeSelector = parent.selectors
      .map(sel => sel + ` > *:nth-child($***REMOVED***keys.length - index***REMOVED***)`)
      .join(', ')

    // create new rule
    let node = parent.clone().removeAll()

    // change rule selector
    node.selector = nodeSelector

    // insert prefixed row/column values
    node.append(***REMOVED*** prop: '-ms-grid-row', value: row.start ***REMOVED***)
    node.append(***REMOVED*** prop: '-ms-grid-column', value: column.start ***REMOVED***)

    // insert rule
    parent.after(node)
***REMOVED***)

  return undefined
***REMOVED***
