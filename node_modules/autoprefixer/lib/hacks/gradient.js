let parser = require('postcss-value-parser')
let range = require('normalize-range')

let OldValue = require('../old-value')
let Value = require('../value')
let utils = require('../utils')

let IS_DIRECTION = /top|left|right|bottom/gi

class Gradient extends Value ***REMOVED***
  /**
   * Change degrees for webkit prefix
   */
  replace(string, prefix) ***REMOVED***
    let ast = parser(string)
    for (let node of ast.nodes) ***REMOVED***
      if (node.type === 'function' && node.value === this.name) ***REMOVED***
        node.nodes = this.newDirection(node.nodes)
        node.nodes = this.normalize(node.nodes)
        if (prefix === '-webkit- old') ***REMOVED***
          let changes = this.oldWebkit(node)
          if (!changes) ***REMOVED***
            return false
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
          node.nodes = this.convertDirection(node.nodes)
          node.value = prefix + node.value
    ***REMOVED***
  ***REMOVED***
***REMOVED***
    return ast.toString()
***REMOVED***

  /**
   * Replace first token
   */
  replaceFirst(params, ...words) ***REMOVED***
    let prefix = words.map(i => ***REMOVED***
      if (i === ' ') ***REMOVED***
        return ***REMOVED*** type: 'space', value: i ***REMOVED***
  ***REMOVED***
      return ***REMOVED*** type: 'word', value: i ***REMOVED***
***REMOVED***)
    return prefix.concat(params.slice(1))
***REMOVED***

  /**
   * Convert angle unit to deg
   */
  normalizeUnit(str, full) ***REMOVED***
    let num = parseFloat(str)
    let deg = (num / full) * 360
    return `$***REMOVED***deg***REMOVED***deg`
***REMOVED***

  /**
   * Normalize angle
   */
  normalize(nodes) ***REMOVED***
    if (!nodes[0]) return nodes

    if (/-?\d+(.\d+)?grad/.test(nodes[0].value)) ***REMOVED***
      nodes[0].value = this.normalizeUnit(nodes[0].value, 400)
***REMOVED*** else if (/-?\d+(.\d+)?rad/.test(nodes[0].value)) ***REMOVED***
      nodes[0].value = this.normalizeUnit(nodes[0].value, 2 * Math.PI)
***REMOVED*** else if (/-?\d+(.\d+)?turn/.test(nodes[0].value)) ***REMOVED***
      nodes[0].value = this.normalizeUnit(nodes[0].value, 1)
***REMOVED*** else if (nodes[0].value.includes('deg')) ***REMOVED***
      let num = parseFloat(nodes[0].value)
      num = range.wrap(0, 360, num)
      nodes[0].value = `$***REMOVED***num***REMOVED***deg`
***REMOVED***

    if (nodes[0].value === '0deg') ***REMOVED***
      nodes = this.replaceFirst(nodes, 'to', ' ', 'top')
***REMOVED*** else if (nodes[0].value === '90deg') ***REMOVED***
      nodes = this.replaceFirst(nodes, 'to', ' ', 'right')
***REMOVED*** else if (nodes[0].value === '180deg') ***REMOVED***
      nodes = this.replaceFirst(nodes, 'to', ' ', 'bottom')
***REMOVED*** else if (nodes[0].value === '270deg') ***REMOVED***
      nodes = this.replaceFirst(nodes, 'to', ' ', 'left')
***REMOVED***

    return nodes
***REMOVED***

  /**
   * Replace old direction to new
   */
  newDirection(params) ***REMOVED***
    if (params[0].value === 'to') ***REMOVED***
      return params
***REMOVED***
    IS_DIRECTION.lastIndex = 0 // reset search index of global regexp
    if (!IS_DIRECTION.test(params[0].value)) ***REMOVED***
      return params
***REMOVED***

    params.unshift(
      ***REMOVED***
        type: 'word',
        value: 'to'
  ***REMOVED***,
      ***REMOVED***
        type: 'space',
        value: ' '
  ***REMOVED***
    )

    for (let i = 2; i < params.length; i++) ***REMOVED***
      if (params[i].type === 'div') ***REMOVED***
        break
  ***REMOVED***
      if (params[i].type === 'word') ***REMOVED***
        params[i].value = this.revertDirection(params[i].value)
  ***REMOVED***
***REMOVED***

    return params
***REMOVED***

  /**
   * Look for at word
   */
  isRadial(params) ***REMOVED***
    let state = 'before'
    for (let param of params) ***REMOVED***
      if (state === 'before' && param.type === 'space') ***REMOVED***
        state = 'at'
  ***REMOVED*** else if (state === 'at' && param.value === 'at') ***REMOVED***
        state = 'after'
  ***REMOVED*** else if (state === 'after' && param.type === 'space') ***REMOVED***
        return true
  ***REMOVED*** else if (param.type === 'div') ***REMOVED***
        break
  ***REMOVED*** else ***REMOVED***
        state = 'before'
  ***REMOVED***
***REMOVED***
    return false
***REMOVED***

  /**
   * Change new direction to old
   */
  convertDirection(params) ***REMOVED***
    if (params.length > 0) ***REMOVED***
      if (params[0].value === 'to') ***REMOVED***
        this.fixDirection(params)
  ***REMOVED*** else if (params[0].value.includes('deg')) ***REMOVED***
        this.fixAngle(params)
  ***REMOVED*** else if (this.isRadial(params)) ***REMOVED***
        this.fixRadial(params)
  ***REMOVED***
***REMOVED***
    return params
***REMOVED***

  /**
   * Replace `to top left` to `bottom right`
   */
  fixDirection(params) ***REMOVED***
    params.splice(0, 2)

    for (let param of params) ***REMOVED***
      if (param.type === 'div') ***REMOVED***
        break
  ***REMOVED***
      if (param.type === 'word') ***REMOVED***
        param.value = this.revertDirection(param.value)
  ***REMOVED***
***REMOVED***
***REMOVED***

  /**
   * Add 90 degrees
   */
  fixAngle(params) ***REMOVED***
    let first = params[0].value
    first = parseFloat(first)
    first = Math.abs(450 - first) % 360
    first = this.roundFloat(first, 3)
    params[0].value = `$***REMOVED***first***REMOVED***deg`
***REMOVED***

  /**
   * Fix radial direction syntax
   */
  fixRadial(params) ***REMOVED***
    let first = []
    let second = []
    let a, b, c, i, next

    for (i = 0; i < params.length - 2; i++) ***REMOVED***
      a = params[i]
      b = params[i + 1]
      c = params[i + 2]
      if (a.type === 'space' && b.value === 'at' && c.type === 'space') ***REMOVED***
        next = i + 3
        break
  ***REMOVED*** else ***REMOVED***
        first.push(a)
  ***REMOVED***
***REMOVED***

    let div
    for (i = next; i < params.length; i++) ***REMOVED***
      if (params[i].type === 'div') ***REMOVED***
        div = params[i]
        break
  ***REMOVED*** else ***REMOVED***
        second.push(params[i])
  ***REMOVED***
***REMOVED***

    params.splice(0, i, ...second, div, ...first)
***REMOVED***

  revertDirection(word) ***REMOVED***
    return Gradient.directions[word.toLowerCase()] || word
***REMOVED***

  /**
   * Round float and save digits under dot
   */
  roundFloat(float, digits) ***REMOVED***
    return parseFloat(float.toFixed(digits))
***REMOVED***

  /**
   * Convert to old webkit syntax
   */
  oldWebkit(node) ***REMOVED***
    let ***REMOVED*** nodes ***REMOVED*** = node
    let string = parser.stringify(node.nodes)

    if (this.name !== 'linear-gradient') ***REMOVED***
      return false
***REMOVED***
    if (nodes[0] && nodes[0].value.includes('deg')) ***REMOVED***
      return false
***REMOVED***
    if (
      string.includes('px') ||
      string.includes('-corner') ||
      string.includes('-side')
    ) ***REMOVED***
      return false
***REMOVED***

    let params = [[]]
    for (let i of nodes) ***REMOVED***
      params[params.length - 1].push(i)
      if (i.type === 'div' && i.value === ',') ***REMOVED***
        params.push([])
  ***REMOVED***
***REMOVED***

    this.oldDirection(params)
    this.colorStops(params)

    node.nodes = []
    for (let param of params) ***REMOVED***
      node.nodes = node.nodes.concat(param)
***REMOVED***

    node.nodes.unshift(
      ***REMOVED*** type: 'word', value: 'linear' ***REMOVED***,
      this.cloneDiv(node.nodes)
    )
    node.value = '-webkit-gradient'

    return true
***REMOVED***

  /**
   * Change direction syntax to old webkit
   */
  oldDirection(params) ***REMOVED***
    let div = this.cloneDiv(params[0])

    if (params[0][0].value !== 'to') ***REMOVED***
      return params.unshift([
        ***REMOVED*** type: 'word', value: Gradient.oldDirections.bottom ***REMOVED***,
        div
      ])
***REMOVED*** else ***REMOVED***
      let words = []
      for (let node of params[0].slice(2)) ***REMOVED***
        if (node.type === 'word') ***REMOVED***
          words.push(node.value.toLowerCase())
    ***REMOVED***
  ***REMOVED***

      words = words.join(' ')
      let old = Gradient.oldDirections[words] || words

      params[0] = [***REMOVED*** type: 'word', value: old ***REMOVED***, div]
      return params[0]
***REMOVED***
***REMOVED***

  /**
   * Get div token from exists parameters
   */
  cloneDiv(params) ***REMOVED***
    for (let i of params) ***REMOVED***
      if (i.type === 'div' && i.value === ',') ***REMOVED***
        return i
  ***REMOVED***
***REMOVED***
    return ***REMOVED*** type: 'div', value: ',', after: ' ' ***REMOVED***
***REMOVED***

  /**
   * Change colors syntax to old webkit
   */
  colorStops(params) ***REMOVED***
    let result = []
    for (let i = 0; i < params.length; i++) ***REMOVED***
      let pos
      let param = params[i]
      let item
      if (i === 0) ***REMOVED***
        continue
  ***REMOVED***

      let color = parser.stringify(param[0])
      if (param[1] && param[1].type === 'word') ***REMOVED***
        pos = param[1].value
  ***REMOVED*** else if (param[2] && param[2].type === 'word') ***REMOVED***
        pos = param[2].value
  ***REMOVED***

      let stop
      if (i === 1 && (!pos || pos === '0%')) ***REMOVED***
        stop = `from($***REMOVED***color***REMOVED***)`
  ***REMOVED*** else if (i === params.length - 1 && (!pos || pos === '100%')) ***REMOVED***
        stop = `to($***REMOVED***color***REMOVED***)`
  ***REMOVED*** else if (pos) ***REMOVED***
        stop = `color-stop($***REMOVED***pos***REMOVED***, $***REMOVED***color***REMOVED***)`
  ***REMOVED*** else ***REMOVED***
        stop = `color-stop($***REMOVED***color***REMOVED***)`
  ***REMOVED***

      let div = param[param.length - 1]
      params[i] = [***REMOVED*** type: 'word', value: stop ***REMOVED***]
      if (div.type === 'div' && div.value === ',') ***REMOVED***
        item = params[i].push(div)
  ***REMOVED***
      result.push(item)
***REMOVED***
    return result
***REMOVED***

  /**
   * Remove old WebKit gradient too
   */
  old(prefix) ***REMOVED***
    if (prefix === '-webkit-') ***REMOVED***
      let type = this.name === 'linear-gradient' ? 'linear' : 'radial'
      let string = '-gradient'
      let regexp = utils.regexp(
        `-webkit-($***REMOVED***type***REMOVED***-gradient|gradient\\(\\s*$***REMOVED***type***REMOVED***)`,
        false
      )

      return new OldValue(this.name, prefix + this.name, string, regexp)
***REMOVED*** else ***REMOVED***
      return super.old(prefix)
***REMOVED***
***REMOVED***

  /**
   * Do not add non-webkit prefixes for list-style and object
   */
  add(decl, prefix) ***REMOVED***
    let p = decl.prop
    if (p.includes('mask')) ***REMOVED***
      if (prefix === '-webkit-' || prefix === '-webkit- old') ***REMOVED***
        return super.add(decl, prefix)
  ***REMOVED***
***REMOVED*** else if (
      p === 'list-style' ||
      p === 'list-style-image' ||
      p === 'content'
    ) ***REMOVED***
      if (prefix === '-webkit-' || prefix === '-webkit- old') ***REMOVED***
        return super.add(decl, prefix)
  ***REMOVED***
***REMOVED*** else ***REMOVED***
      return super.add(decl, prefix)
***REMOVED***
    return undefined
***REMOVED***
***REMOVED***

Gradient.names = [
  'linear-gradient',
  'repeating-linear-gradient',
  'radial-gradient',
  'repeating-radial-gradient'
]

Gradient.directions = ***REMOVED***
  top: 'bottom',
  left: 'right',
  bottom: 'top',
  right: 'left'
***REMOVED***

// Direction to replace
Gradient.oldDirections = ***REMOVED***
  'top': 'left bottom, left top',
  'left': 'right top, left top',
  'bottom': 'left top, left bottom',
  'right': 'left top, right top',

  'top right': 'left bottom, right top',
  'top left': 'right bottom, left top',
  'right top': 'left bottom, right top',
  'right bottom': 'left top, right bottom',
  'bottom right': 'left top, right bottom',
  'bottom left': 'right top, left bottom',
  'left top': 'right bottom, left top',
  'left bottom': 'right top, left bottom'
***REMOVED***

module.exports = Gradient
