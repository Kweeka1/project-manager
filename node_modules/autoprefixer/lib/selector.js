let ***REMOVED*** list ***REMOVED*** = require('postcss')

let OldSelector = require('./old-selector')
let Prefixer = require('./prefixer')
let Browsers = require('./browsers')
let utils = require('./utils')

class Selector extends Prefixer ***REMOVED***
  constructor(name, prefixes, all) ***REMOVED***
    super(name, prefixes, all)
    this.regexpCache = new Map()
***REMOVED***

  /**
   * Is rule selectors need to be prefixed
   */
  check(rule) ***REMOVED***
    if (rule.selector.includes(this.name)) ***REMOVED***
      return !!rule.selector.match(this.regexp())
***REMOVED***

    return false
***REMOVED***

  /**
   * Return prefixed version of selector
   */
  prefixed(prefix) ***REMOVED***
    return this.name.replace(/^(\W*)/, `$1$***REMOVED***prefix***REMOVED***`)
***REMOVED***

  /**
   * Lazy loadRegExp for name
   */
  regexp(prefix) ***REMOVED***
    if (!this.regexpCache.has(prefix)) ***REMOVED***
      let name = prefix ? this.prefixed(prefix) : this.name
      this.regexpCache.set(
        prefix,
        new RegExp(`(^|[^:"'=])$***REMOVED***utils.escapeRegexp(name)***REMOVED***`, 'gi')
      )
***REMOVED***

    return this.regexpCache.get(prefix)
***REMOVED***

  /**
   * All possible prefixes
   */
  possible() ***REMOVED***
    return Browsers.prefixes()
***REMOVED***

  /**
   * Return all possible selector prefixes
   */
  prefixeds(rule) ***REMOVED***
    if (rule._autoprefixerPrefixeds) ***REMOVED***
      if (rule._autoprefixerPrefixeds[this.name]) ***REMOVED***
        return rule._autoprefixerPrefixeds
  ***REMOVED***
***REMOVED*** else ***REMOVED***
      rule._autoprefixerPrefixeds = ***REMOVED******REMOVED***
***REMOVED***

    let prefixeds = ***REMOVED******REMOVED***
    if (rule.selector.includes(',')) ***REMOVED***
      let ruleParts = list.comma(rule.selector)
      let toProcess = ruleParts.filter(el => el.includes(this.name))

      for (let prefix of this.possible()) ***REMOVED***
        prefixeds[prefix] = toProcess
          .map(el => this.replace(el, prefix))
          .join(', ')
  ***REMOVED***
***REMOVED*** else ***REMOVED***
      for (let prefix of this.possible()) ***REMOVED***
        prefixeds[prefix] = this.replace(rule.selector, prefix)
  ***REMOVED***
***REMOVED***

    rule._autoprefixerPrefixeds[this.name] = prefixeds
    return rule._autoprefixerPrefixeds
***REMOVED***

  /**
   * Is rule already prefixed before
   */
  already(rule, prefixeds, prefix) ***REMOVED***
    let index = rule.parent.index(rule) - 1

    while (index >= 0) ***REMOVED***
      let before = rule.parent.nodes[index]

      if (before.type !== 'rule') ***REMOVED***
        return false
  ***REMOVED***

      let some = false
      for (let key in prefixeds[this.name]) ***REMOVED***
        let prefixed = prefixeds[this.name][key]
        if (before.selector === prefixed) ***REMOVED***
          if (prefix === key) ***REMOVED***
            return true
      ***REMOVED*** else ***REMOVED***
            some = true
            break
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
      if (!some) ***REMOVED***
        return false
  ***REMOVED***

      index -= 1
***REMOVED***

    return false
***REMOVED***

  /**
   * Replace selectors by prefixed one
   */
  replace(selector, prefix) ***REMOVED***
    return selector.replace(this.regexp(), `$1$***REMOVED***this.prefixed(prefix)***REMOVED***`)
***REMOVED***

  /**
   * Clone and add prefixes for at-rule
   */
  add(rule, prefix) ***REMOVED***
    let prefixeds = this.prefixeds(rule)

    if (this.already(rule, prefixeds, prefix)) ***REMOVED***
      return
***REMOVED***

    let cloned = this.clone(rule, ***REMOVED*** selector: prefixeds[this.name][prefix] ***REMOVED***)
    rule.parent.insertBefore(rule, cloned)
***REMOVED***

  /**
   * Return function to fast find prefixed selector
   */
  old(prefix) ***REMOVED***
    return new OldSelector(this, prefix)
***REMOVED***
***REMOVED***

module.exports = Selector
