let vendor = require('./vendor')
let Declaration = require('./declaration')
let Resolution = require('./resolution')
let Transition = require('./transition')
let Processor = require('./processor')
let Supports = require('./supports')
let Browsers = require('./browsers')
let Selector = require('./selector')
let AtRule = require('./at-rule')
let Value = require('./value')
let utils = require('./utils')
let hackFullscreen = require('./hacks/fullscreen')
let hackPlaceholder = require('./hacks/placeholder')
let hackPlaceholderShown = require('./hacks/placeholder-shown')
let hackFileSelectorButton = require('./hacks/file-selector-button')
let hackFlex = require('./hacks/flex')
let hackOrder = require('./hacks/order')
let hackFilter = require('./hacks/filter')
let hackGridEnd = require('./hacks/grid-end')
let hackAnimation = require('./hacks/animation')
let hackFlexFlow = require('./hacks/flex-flow')
let hackFlexGrow = require('./hacks/flex-grow')
let hackFlexWrap = require('./hacks/flex-wrap')
let hackGridArea = require('./hacks/grid-area')
let hackPlaceSelf = require('./hacks/place-self')
let hackGridStart = require('./hacks/grid-start')
let hackAlignSelf = require('./hacks/align-self')
let hackAppearance = require('./hacks/appearance')
let hackFlexBasis = require('./hacks/flex-basis')
let hackMaskBorder = require('./hacks/mask-border')
let hackMaskComposite = require('./hacks/mask-composite')
let hackAlignItems = require('./hacks/align-items')
let hackUserSelect = require('./hacks/user-select')
let hackFlexShrink = require('./hacks/flex-shrink')
let hackBreakProps = require('./hacks/break-props')
let hackWritingMode = require('./hacks/writing-mode')
let hackBorderImage = require('./hacks/border-image')
let hackAlignContent = require('./hacks/align-content')
let hackBorderRadius = require('./hacks/border-radius')
let hackBlockLogical = require('./hacks/block-logical')
let hackGridTemplate = require('./hacks/grid-template')
let hackInlineLogical = require('./hacks/inline-logical')
let hackGridRowAlign = require('./hacks/grid-row-align')
let hackTransformDecl = require('./hacks/transform-decl')
let hackFlexDirection = require('./hacks/flex-direction')
let hackImageRendering = require('./hacks/image-rendering')
let hackBackdropFilter = require('./hacks/backdrop-filter')
let hackBackgroundClip = require('./hacks/background-clip')
let hackTextDecoration = require('./hacks/text-decoration')
let hackJustifyContent = require('./hacks/justify-content')
let hackBackgroundSize = require('./hacks/background-size')
let hackGridRowColumn = require('./hacks/grid-row-column')
let hackGridRowsColumns = require('./hacks/grid-rows-columns')
let hackGridColumnAlign = require('./hacks/grid-column-align')
let hackPrintColorAdjust = require('./hacks/print-color-adjust')
let hackOverscrollBehavior = require('./hacks/overscroll-behavior')
let hackGridTemplateAreas = require('./hacks/grid-template-areas')
let hackTextEmphasisPosition = require('./hacks/text-emphasis-position')
let hackTextDecorationSkipInk = require('./hacks/text-decoration-skip-ink')
let hackGradient = require('./hacks/gradient')
let hackIntrinsic = require('./hacks/intrinsic')
let hackPixelated = require('./hacks/pixelated')
let hackImageSet = require('./hacks/image-set')
let hackCrossFade = require('./hacks/cross-fade')
let hackDisplayFlex = require('./hacks/display-flex')
let hackDisplayGrid = require('./hacks/display-grid')
let hackFilterValue = require('./hacks/filter-value')
let hackAutofill = require('./hacks/autofill')

Selector.hack(hackAutofill)
Selector.hack(hackFullscreen)
Selector.hack(hackPlaceholder)
Selector.hack(hackPlaceholderShown)
Selector.hack(hackFileSelectorButton)
Declaration.hack(hackFlex)
Declaration.hack(hackOrder)
Declaration.hack(hackFilter)
Declaration.hack(hackGridEnd)
Declaration.hack(hackAnimation)
Declaration.hack(hackFlexFlow)
Declaration.hack(hackFlexGrow)
Declaration.hack(hackFlexWrap)
Declaration.hack(hackGridArea)
Declaration.hack(hackPlaceSelf)
Declaration.hack(hackGridStart)
Declaration.hack(hackAlignSelf)
Declaration.hack(hackAppearance)
Declaration.hack(hackFlexBasis)
Declaration.hack(hackMaskBorder)
Declaration.hack(hackMaskComposite)
Declaration.hack(hackAlignItems)
Declaration.hack(hackUserSelect)
Declaration.hack(hackFlexShrink)
Declaration.hack(hackBreakProps)
Declaration.hack(hackWritingMode)
Declaration.hack(hackBorderImage)
Declaration.hack(hackAlignContent)
Declaration.hack(hackBorderRadius)
Declaration.hack(hackBlockLogical)
Declaration.hack(hackGridTemplate)
Declaration.hack(hackInlineLogical)
Declaration.hack(hackGridRowAlign)
Declaration.hack(hackTransformDecl)
Declaration.hack(hackFlexDirection)
Declaration.hack(hackImageRendering)
Declaration.hack(hackBackdropFilter)
Declaration.hack(hackBackgroundClip)
Declaration.hack(hackTextDecoration)
Declaration.hack(hackJustifyContent)
Declaration.hack(hackBackgroundSize)
Declaration.hack(hackGridRowColumn)
Declaration.hack(hackGridRowsColumns)
Declaration.hack(hackGridColumnAlign)
Declaration.hack(hackOverscrollBehavior)
Declaration.hack(hackGridTemplateAreas)
Declaration.hack(hackPrintColorAdjust)
Declaration.hack(hackTextEmphasisPosition)
Declaration.hack(hackTextDecorationSkipInk)
Value.hack(hackGradient)
Value.hack(hackIntrinsic)
Value.hack(hackPixelated)
Value.hack(hackImageSet)
Value.hack(hackCrossFade)
Value.hack(hackDisplayFlex)
Value.hack(hackDisplayGrid)
Value.hack(hackFilterValue)

let declsCache = new Map()

class Prefixes ***REMOVED***
  constructor(data, browsers, options = ***REMOVED******REMOVED***) ***REMOVED***
    this.data = data
    this.browsers = browsers
    this.options = options
    ;[this.add, this.remove] = this.preprocess(this.select(this.data))
    this.transition = new Transition(this)
    this.processor = new Processor(this)
***REMOVED***

  /**
   * Return clone instance to remove all prefixes
   */
  cleaner() ***REMOVED***
    if (this.cleanerCache) ***REMOVED***
      return this.cleanerCache
***REMOVED***

    if (this.browsers.selected.length) ***REMOVED***
      let empty = new Browsers(this.browsers.data, [])
      this.cleanerCache = new Prefixes(this.data, empty, this.options)
***REMOVED*** else ***REMOVED***
      return this
***REMOVED***

    return this.cleanerCache
***REMOVED***

  /**
   * Select prefixes from data, which is necessary for selected browsers
   */
  select(list) ***REMOVED***
    let selected = ***REMOVED*** add: ***REMOVED******REMOVED***, remove: ***REMOVED******REMOVED*** ***REMOVED***

    for (let name in list) ***REMOVED***
      let data = list[name]
      let add = data.browsers.map(i => ***REMOVED***
        let params = i.split(' ')
        return ***REMOVED***
          browser: `$***REMOVED***params[0]***REMOVED*** $***REMOVED***params[1]***REMOVED***`,
          note: params[2]
    ***REMOVED***
  ***REMOVED***)

      let notes = add
        .filter(i => i.note)
        .map(i => `$***REMOVED***this.browsers.prefix(i.browser)***REMOVED*** $***REMOVED***i.note***REMOVED***`)
      notes = utils.uniq(notes)

      add = add
        .filter(i => this.browsers.isSelected(i.browser))
        .map(i => ***REMOVED***
          let prefix = this.browsers.prefix(i.browser)
          if (i.note) ***REMOVED***
            return `$***REMOVED***prefix***REMOVED*** $***REMOVED***i.note***REMOVED***`
      ***REMOVED*** else ***REMOVED***
            return prefix
      ***REMOVED***
    ***REMOVED***)
      add = this.sort(utils.uniq(add))

      if (this.options.flexbox === 'no-2009') ***REMOVED***
        add = add.filter(i => !i.includes('2009'))
  ***REMOVED***

      let all = data.browsers.map(i => this.browsers.prefix(i))
      if (data.mistakes) ***REMOVED***
        all = all.concat(data.mistakes)
  ***REMOVED***
      all = all.concat(notes)
      all = utils.uniq(all)

      if (add.length) ***REMOVED***
        selected.add[name] = add
        if (add.length < all.length) ***REMOVED***
          selected.remove[name] = all.filter(i => !add.includes(i))
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
        selected.remove[name] = all
  ***REMOVED***
***REMOVED***

    return selected
***REMOVED***

  /**
   * Sort vendor prefixes
   */
  sort(prefixes) ***REMOVED***
    return prefixes.sort((a, b) => ***REMOVED***
      let aLength = utils.removeNote(a).length
      let bLength = utils.removeNote(b).length

      if (aLength === bLength) ***REMOVED***
        return b.length - a.length
  ***REMOVED*** else ***REMOVED***
        return bLength - aLength
  ***REMOVED***
***REMOVED***)
***REMOVED***

  /**
   * Cache prefixes data to fast CSS processing
   */
  preprocess(selected) ***REMOVED***
    let add = ***REMOVED***
      'selectors': [],
      '@supports': new Supports(Prefixes, this)
***REMOVED***
    for (let name in selected.add) ***REMOVED***
      let prefixes = selected.add[name]
      if (name === '@keyframes' || name === '@viewport') ***REMOVED***
        add[name] = new AtRule(name, prefixes, this)
  ***REMOVED*** else if (name === '@resolution') ***REMOVED***
        add[name] = new Resolution(name, prefixes, this)
  ***REMOVED*** else if (this.data[name].selector) ***REMOVED***
        add.selectors.push(Selector.load(name, prefixes, this))
  ***REMOVED*** else ***REMOVED***
        let props = this.data[name].props

        if (props) ***REMOVED***
          let value = Value.load(name, prefixes, this)
          for (let prop of props) ***REMOVED***
            if (!add[prop]) ***REMOVED***
              add[prop] = ***REMOVED*** values: [] ***REMOVED***
        ***REMOVED***
            add[prop].values.push(value)
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
          let values = (add[name] && add[name].values) || []
          add[name] = Declaration.load(name, prefixes, this)
          add[name].values = values
    ***REMOVED***
  ***REMOVED***
***REMOVED***

    let remove = ***REMOVED*** selectors: [] ***REMOVED***
    for (let name in selected.remove) ***REMOVED***
      let prefixes = selected.remove[name]
      if (this.data[name].selector) ***REMOVED***
        let selector = Selector.load(name, prefixes)
        for (let prefix of prefixes) ***REMOVED***
          remove.selectors.push(selector.old(prefix))
    ***REMOVED***
  ***REMOVED*** else if (name === '@keyframes' || name === '@viewport') ***REMOVED***
        for (let prefix of prefixes) ***REMOVED***
          let prefixed = `@$***REMOVED***prefix***REMOVED***$***REMOVED***name.slice(1)***REMOVED***`
          remove[prefixed] = ***REMOVED*** remove: true ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else if (name === '@resolution') ***REMOVED***
        remove[name] = new Resolution(name, prefixes, this)
  ***REMOVED*** else ***REMOVED***
        let props = this.data[name].props
        if (props) ***REMOVED***
          let value = Value.load(name, [], this)
          for (let prefix of prefixes) ***REMOVED***
            let old = value.old(prefix)
            if (old) ***REMOVED***
              for (let prop of props) ***REMOVED***
                if (!remove[prop]) ***REMOVED***
                  remove[prop] = ***REMOVED******REMOVED***
            ***REMOVED***
                if (!remove[prop].values) ***REMOVED***
                  remove[prop].values = []
            ***REMOVED***
                remove[prop].values.push(old)
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
          for (let p of prefixes) ***REMOVED***
            let olds = this.decl(name).old(name, p)
            if (name === 'align-self') ***REMOVED***
              let a = add[name] && add[name].prefixes
              if (a) ***REMOVED***
                if (p === '-webkit- 2009' && a.includes('-webkit-')) ***REMOVED***
                  continue
            ***REMOVED*** else if (p === '-webkit-' && a.includes('-webkit- 2009')) ***REMOVED***
                  continue
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
            for (let prefixed of olds) ***REMOVED***
              if (!remove[prefixed]) ***REMOVED***
                remove[prefixed] = ***REMOVED******REMOVED***
          ***REMOVED***
              remove[prefixed].remove = true
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

    return [add, remove]
***REMOVED***

  /**
   * Declaration loader with caching
   */
  decl(prop) ***REMOVED***
    if (!declsCache.has(prop)) ***REMOVED***
      declsCache.set(prop, Declaration.load(prop))
***REMOVED***

    return declsCache.get(prop)
***REMOVED***

  /**
   * Return unprefixed version of property
   */
  unprefixed(prop) ***REMOVED***
    let value = this.normalize(vendor.unprefixed(prop))
    if (value === 'flex-direction') ***REMOVED***
      value = 'flex-flow'
***REMOVED***
    return value
***REMOVED***

  /**
   * Normalize prefix for remover
   */
  normalize(prop) ***REMOVED***
    return this.decl(prop).normalize(prop)
***REMOVED***

  /**
   * Return prefixed version of property
   */
  prefixed(prop, prefix) ***REMOVED***
    prop = vendor.unprefixed(prop)
    return this.decl(prop).prefixed(prop, prefix)
***REMOVED***

  /**
   * Return values, which must be prefixed in selected property
   */
  values(type, prop) ***REMOVED***
    let data = this[type]

    let global = data['*'] && data['*'].values
    let values = data[prop] && data[prop].values

    if (global && values) ***REMOVED***
      return utils.uniq(global.concat(values))
***REMOVED*** else ***REMOVED***
      return global || values || []
***REMOVED***
***REMOVED***

  /**
   * Group declaration by unprefixed property to check them
   */
  group(decl) ***REMOVED***
    let rule = decl.parent
    let index = rule.index(decl)
    let ***REMOVED*** length ***REMOVED*** = rule.nodes
    let unprefixed = this.unprefixed(decl.prop)

    let checker = (step, callback) => ***REMOVED***
      index += step
      while (index >= 0 && index < length) ***REMOVED***
        let other = rule.nodes[index]
        if (other.type === 'decl') ***REMOVED***
          if (step === -1 && other.prop === unprefixed) ***REMOVED***
            if (!Browsers.withPrefix(other.value)) ***REMOVED***
              break
        ***REMOVED***
      ***REMOVED***

          if (this.unprefixed(other.prop) !== unprefixed) ***REMOVED***
            break
      ***REMOVED*** else if (callback(other) === true) ***REMOVED***
            return true
      ***REMOVED***

          if (step === +1 && other.prop === unprefixed) ***REMOVED***
            if (!Browsers.withPrefix(other.value)) ***REMOVED***
              break
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

        index += step
  ***REMOVED***
      return false
***REMOVED***

    return ***REMOVED***
      up(callback) ***REMOVED***
        return checker(-1, callback)
  ***REMOVED***,
      down(callback) ***REMOVED***
        return checker(+1, callback)
  ***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***

module.exports = Prefixes
