let featureQueries = require('caniuse-lite/data/features/css-featurequeries.js')
let ***REMOVED*** feature ***REMOVED*** = require('caniuse-lite')
let ***REMOVED*** parse ***REMOVED*** = require('postcss')

let Browsers = require('./browsers')
let brackets = require('./brackets')
let Value = require('./value')
let utils = require('./utils')

let data = feature(featureQueries)

let supported = []
for (let browser in data.stats) ***REMOVED***
  let versions = data.stats[browser]
  for (let version in versions) ***REMOVED***
    let support = versions[version]
    if (/y/.test(support)) ***REMOVED***
      supported.push(browser + ' ' + version)
***REMOVED***
***REMOVED***
***REMOVED***

class Supports ***REMOVED***
  constructor(Prefixes, all) ***REMOVED***
    this.Prefixes = Prefixes
    this.all = all
***REMOVED***

  /**
   * Return prefixer only with @supports supported browsers
   */
  prefixer() ***REMOVED***
    if (this.prefixerCache) ***REMOVED***
      return this.prefixerCache
***REMOVED***

    let filtered = this.all.browsers.selected.filter(i => ***REMOVED***
      return supported.includes(i)
***REMOVED***)

    let browsers = new Browsers(
      this.all.browsers.data,
      filtered,
      this.all.options
    )
    this.prefixerCache = new this.Prefixes(
      this.all.data,
      browsers,
      this.all.options
    )
    return this.prefixerCache
***REMOVED***

  /**
   * Parse string into declaration property and value
   */
  parse(str) ***REMOVED***
    let parts = str.split(':')
    let prop = parts[0]
    let value = parts[1]
    if (!value) value = ''
    return [prop.trim(), value.trim()]
***REMOVED***

  /**
   * Create virtual rule to process it by prefixer
   */
  virtual(str) ***REMOVED***
    let [prop, value] = this.parse(str)
    let rule = parse('a***REMOVED******REMOVED***').first
    rule.append(***REMOVED*** prop, value, raws: ***REMOVED*** before: '' ***REMOVED*** ***REMOVED***)
    return rule
***REMOVED***

  /**
   * Return array of Declaration with all necessary prefixes
   */
  prefixed(str) ***REMOVED***
    let rule = this.virtual(str)
    if (this.disabled(rule.first)) ***REMOVED***
      return rule.nodes
***REMOVED***

    let result = ***REMOVED*** warn: () => null ***REMOVED***

    let prefixer = this.prefixer().add[rule.first.prop]
    prefixer && prefixer.process && prefixer.process(rule.first, result)

    for (let decl of rule.nodes) ***REMOVED***
      for (let value of this.prefixer().values('add', rule.first.prop)) ***REMOVED***
        value.process(decl)
  ***REMOVED***
      Value.save(this.all, decl)
***REMOVED***

    return rule.nodes
***REMOVED***

  /**
   * Return true if brackets node is "not" word
   */
  isNot(node) ***REMOVED***
    return typeof node === 'string' && /not\s*/i.test(node)
***REMOVED***

  /**
   * Return true if brackets node is "or" word
   */
  isOr(node) ***REMOVED***
    return typeof node === 'string' && /\s*or\s*/i.test(node)
***REMOVED***

  /**
   * Return true if brackets node is (prop: value)
   */
  isProp(node) ***REMOVED***
    return (
      typeof node === 'object' &&
      node.length === 1 &&
      typeof node[0] === 'string'
    )
***REMOVED***

  /**
   * Return true if prefixed property has no unprefixed
   */
  isHack(all, unprefixed) ***REMOVED***
    let check = new RegExp(`(\\(|\\s)$***REMOVED***utils.escapeRegexp(unprefixed)***REMOVED***:`)
    return !check.test(all)
***REMOVED***

  /**
   * Return true if we need to remove node
   */
  toRemove(str, all) ***REMOVED***
    let [prop, value] = this.parse(str)
    let unprefixed = this.all.unprefixed(prop)

    let cleaner = this.all.cleaner()

    if (
      cleaner.remove[prop] &&
      cleaner.remove[prop].remove &&
      !this.isHack(all, unprefixed)
    ) ***REMOVED***
      return true
***REMOVED***

    for (let checker of cleaner.values('remove', unprefixed)) ***REMOVED***
      if (checker.check(value)) ***REMOVED***
        return true
  ***REMOVED***
***REMOVED***

    return false
***REMOVED***

  /**
   * Remove all unnecessary prefixes
   */
  remove(nodes, all) ***REMOVED***
    let i = 0
    while (i < nodes.length) ***REMOVED***
      if (
        !this.isNot(nodes[i - 1]) &&
        this.isProp(nodes[i]) &&
        this.isOr(nodes[i + 1])
      ) ***REMOVED***
        if (this.toRemove(nodes[i][0], all)) ***REMOVED***
          nodes.splice(i, 2)
          continue
    ***REMOVED***

        i += 2
        continue
  ***REMOVED***

      if (typeof nodes[i] === 'object') ***REMOVED***
        nodes[i] = this.remove(nodes[i], all)
  ***REMOVED***

      i += 1
***REMOVED***
    return nodes
***REMOVED***

  /**
   * Clean brackets with one child
   */
  cleanBrackets(nodes) ***REMOVED***
    return nodes.map(i => ***REMOVED***
      if (typeof i !== 'object') ***REMOVED***
        return i
  ***REMOVED***

      if (i.length === 1 && typeof i[0] === 'object') ***REMOVED***
        return this.cleanBrackets(i[0])
  ***REMOVED***

      return this.cleanBrackets(i)
***REMOVED***)
***REMOVED***

  /**
   * Add " or " between properties and convert it to brackets format
   */
  convert(progress) ***REMOVED***
    let result = ['']
    for (let i of progress) ***REMOVED***
      result.push([`$***REMOVED***i.prop***REMOVED***: $***REMOVED***i.value***REMOVED***`])
      result.push(' or ')
***REMOVED***
    result[result.length - 1] = ''
    return result
***REMOVED***

  /**
   * Compress value functions into a string nodes
   */
  normalize(nodes) ***REMOVED***
    if (typeof nodes !== 'object') ***REMOVED***
      return nodes
***REMOVED***

    nodes = nodes.filter(i => i !== '')

    if (typeof nodes[0] === 'string') ***REMOVED***
      let firstNode = nodes[0].trim()

      if (
        firstNode.includes(':') ||
        firstNode === 'selector' ||
        firstNode === 'not selector'
      ) ***REMOVED***
        return [brackets.stringify(nodes)]
  ***REMOVED***
***REMOVED***
    return nodes.map(i => this.normalize(i))
***REMOVED***

  /**
   * Add prefixes
   */
  add(nodes, all) ***REMOVED***
    return nodes.map(i => ***REMOVED***
      if (this.isProp(i)) ***REMOVED***
        let prefixed = this.prefixed(i[0])
        if (prefixed.length > 1) ***REMOVED***
          return this.convert(prefixed)
    ***REMOVED***

        return i
  ***REMOVED***

      if (typeof i === 'object') ***REMOVED***
        return this.add(i, all)
  ***REMOVED***

      return i
***REMOVED***)
***REMOVED***

  /**
   * Add prefixed declaration
   */
  process(rule) ***REMOVED***
    let ast = brackets.parse(rule.params)
    ast = this.normalize(ast)
    ast = this.remove(ast, rule.params)
    ast = this.add(ast, rule.params)
    ast = this.cleanBrackets(ast)
    rule.params = brackets.stringify(ast)
***REMOVED***

  /**
   * Check global options
   */
  disabled(node) ***REMOVED***
    if (!this.all.options.grid) ***REMOVED***
      if (node.prop === 'display' && node.value.includes('grid')) ***REMOVED***
        return true
  ***REMOVED***
      if (node.prop.includes('grid') || node.prop === 'justify-items') ***REMOVED***
        return true
  ***REMOVED***
***REMOVED***

    if (this.all.options.flexbox === false) ***REMOVED***
      if (node.prop === 'display' && node.value.includes('flex')) ***REMOVED***
        return true
  ***REMOVED***
      let other = ['order', 'justify-content', 'align-items', 'align-content']
      if (node.prop.includes('flex') || other.includes(node.prop)) ***REMOVED***
        return true
  ***REMOVED***
***REMOVED***

    return false
***REMOVED***
***REMOVED***

module.exports = Supports
