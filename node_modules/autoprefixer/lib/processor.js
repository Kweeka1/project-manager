let parser = require('postcss-value-parser')

let Value = require('./value')
let insertAreas = require('./hacks/grid-utils').insertAreas

const OLD_LINEAR = /(^|[^-])linear-gradient\(\s*(top|left|right|bottom)/i
const OLD_RADIAL = /(^|[^-])radial-gradient\(\s*\d+(\w*|%)\s+\d+(\w*|%)\s*,/i
const IGNORE_NEXT = /(!\s*)?autoprefixer:\s*ignore\s+next/i
const GRID_REGEX = /(!\s*)?autoprefixer\s*grid:\s*(on|off|(no-)?autoplace)/i

const SIZES = [
  'width',
  'height',
  'min-width',
  'max-width',
  'min-height',
  'max-height',
  'inline-size',
  'min-inline-size',
  'max-inline-size',
  'block-size',
  'min-block-size',
  'max-block-size'
]

function hasGridTemplate(decl) ***REMOVED***
  return decl.parent.some(
    i => i.prop === 'grid-template' || i.prop === 'grid-template-areas'
  )
***REMOVED***

function hasRowsAndColumns(decl) ***REMOVED***
  let hasRows = decl.parent.some(i => i.prop === 'grid-template-rows')
  let hasColumns = decl.parent.some(i => i.prop === 'grid-template-columns')
  return hasRows && hasColumns
***REMOVED***

class Processor ***REMOVED***
  constructor(prefixes) ***REMOVED***
    this.prefixes = prefixes
***REMOVED***

  /**
   * Add necessary prefixes
   */
  add(css, result) ***REMOVED***
    // At-rules
    let resolution = this.prefixes.add['@resolution']
    let keyframes = this.prefixes.add['@keyframes']
    let viewport = this.prefixes.add['@viewport']
    let supports = this.prefixes.add['@supports']

    css.walkAtRules(rule => ***REMOVED***
      if (rule.name === 'keyframes') ***REMOVED***
        if (!this.disabled(rule, result)) ***REMOVED***
          return keyframes && keyframes.process(rule)
    ***REMOVED***
  ***REMOVED*** else if (rule.name === 'viewport') ***REMOVED***
        if (!this.disabled(rule, result)) ***REMOVED***
          return viewport && viewport.process(rule)
    ***REMOVED***
  ***REMOVED*** else if (rule.name === 'supports') ***REMOVED***
        if (
          this.prefixes.options.supports !== false &&
          !this.disabled(rule, result)
        ) ***REMOVED***
          return supports.process(rule)
    ***REMOVED***
  ***REMOVED*** else if (rule.name === 'media' && rule.params.includes('-resolution')) ***REMOVED***
        if (!this.disabled(rule, result)) ***REMOVED***
          return resolution && resolution.process(rule)
    ***REMOVED***
  ***REMOVED***

      return undefined
***REMOVED***)

    // Selectors
    css.walkRules(rule => ***REMOVED***
      if (this.disabled(rule, result)) return undefined

      return this.prefixes.add.selectors.map(selector => ***REMOVED***
        return selector.process(rule, result)
  ***REMOVED***)
***REMOVED***)

    function insideGrid(decl) ***REMOVED***
      return decl.parent.nodes.some(node => ***REMOVED***
        if (node.type !== 'decl') return false
        let displayGrid =
          node.prop === 'display' && /(inline-)?grid/.test(node.value)
        let gridTemplate = node.prop.startsWith('grid-template')
        let gridGap = /^grid-([A-z]+-)?gap/.test(node.prop)
        return displayGrid || gridTemplate || gridGap
  ***REMOVED***)
***REMOVED***
    function insideFlex(decl) ***REMOVED***
      return decl.parent.some(node => ***REMOVED***
        return node.prop === 'display' && /(inline-)?flex/.test(node.value)
  ***REMOVED***)
***REMOVED***

    let gridPrefixes =
      this.gridStatus(css, result) &&
      this.prefixes.add['grid-area'] &&
      this.prefixes.add['grid-area'].prefixes

    css.walkDecls(decl => ***REMOVED***
      if (this.disabledDecl(decl, result)) return undefined

      let parent = decl.parent
      let prop = decl.prop
      let value = decl.value

      if (prop === 'color-adjust') ***REMOVED***
        result.warn(
          'Replace color-adjust to print-color-adjust. ' +
            'The color-adjust shorthand is currently deprecated.',
          ***REMOVED*** node: decl ***REMOVED***
        )
  ***REMOVED*** else if (prop === 'grid-row-span') ***REMOVED***
        result.warn(
          'grid-row-span is not part of final Grid Layout. Use grid-row.',
          ***REMOVED*** node: decl ***REMOVED***
        )
        return undefined
  ***REMOVED*** else if (prop === 'grid-column-span') ***REMOVED***
        result.warn(
          'grid-column-span is not part of final Grid Layout. Use grid-column.',
          ***REMOVED*** node: decl ***REMOVED***
        )
        return undefined
  ***REMOVED*** else if (prop === 'display' && value === 'box') ***REMOVED***
        result.warn(
          'You should write display: flex by final spec ' +
            'instead of display: box',
          ***REMOVED*** node: decl ***REMOVED***
        )
        return undefined
  ***REMOVED*** else if (prop === 'text-emphasis-position') ***REMOVED***
        if (value === 'under' || value === 'over') ***REMOVED***
          result.warn(
            'You should use 2 values for text-emphasis-position ' +
              'For example, `under left` instead of just `under`.',
            ***REMOVED*** node: decl ***REMOVED***
          )
    ***REMOVED***
  ***REMOVED*** else if (
        /^(align|justify|place)-(items|content)$/.test(prop) &&
        insideFlex(decl)
      ) ***REMOVED***
        if (value === 'start' || value === 'end') ***REMOVED***
          result.warn(
            `$***REMOVED***value***REMOVED*** value has mixed support, consider using ` +
              `flex-$***REMOVED***value***REMOVED*** instead`,
            ***REMOVED*** node: decl ***REMOVED***
          )
    ***REMOVED***
  ***REMOVED*** else if (prop === 'text-decoration-skip' && value === 'ink') ***REMOVED***
        result.warn(
          'Replace text-decoration-skip: ink to ' +
            'text-decoration-skip-ink: auto, because spec had been changed',
          ***REMOVED*** node: decl ***REMOVED***
        )
  ***REMOVED*** else ***REMOVED***
        if (gridPrefixes && this.gridStatus(decl, result)) ***REMOVED***
          if (decl.value === 'subgrid') ***REMOVED***
            result.warn('IE does not support subgrid', ***REMOVED*** node: decl ***REMOVED***)
      ***REMOVED***
          if (/^(align|justify|place)-items$/.test(prop) && insideGrid(decl)) ***REMOVED***
            let fixed = prop.replace('-items', '-self')
            result.warn(
              `IE does not support $***REMOVED***prop***REMOVED*** on grid containers. ` +
                `Try using $***REMOVED***fixed***REMOVED*** on child elements instead: ` +
                `$***REMOVED***decl.parent.selector***REMOVED*** > * ***REMOVED*** $***REMOVED***fixed***REMOVED***: $***REMOVED***decl.value***REMOVED*** ***REMOVED***`,
              ***REMOVED*** node: decl ***REMOVED***
            )
      ***REMOVED*** else if (
            /^(align|justify|place)-content$/.test(prop) &&
            insideGrid(decl)
          ) ***REMOVED***
            result.warn(`IE does not support $***REMOVED***decl.prop***REMOVED*** on grid containers`, ***REMOVED***
              node: decl
        ***REMOVED***)
      ***REMOVED*** else if (prop === 'display' && decl.value === 'contents') ***REMOVED***
            result.warn(
              'Please do not use display: contents; ' +
                'if you have grid setting enabled',
              ***REMOVED*** node: decl ***REMOVED***
            )
            return undefined
      ***REMOVED*** else if (decl.prop === 'grid-gap') ***REMOVED***
            let status = this.gridStatus(decl, result)
            if (
              status === 'autoplace' &&
              !hasRowsAndColumns(decl) &&
              !hasGridTemplate(decl)
            ) ***REMOVED***
              result.warn(
                'grid-gap only works if grid-template(-areas) is being ' +
                  'used or both rows and columns have been declared ' +
                  'and cells have not been manually ' +
                  'placed inside the explicit grid',
                ***REMOVED*** node: decl ***REMOVED***
              )
        ***REMOVED*** else if (
              (status === true || status === 'no-autoplace') &&
              !hasGridTemplate(decl)
            ) ***REMOVED***
              result.warn(
                'grid-gap only works if grid-template(-areas) is being used',
                ***REMOVED*** node: decl ***REMOVED***
              )
        ***REMOVED***
      ***REMOVED*** else if (prop === 'grid-auto-columns') ***REMOVED***
            result.warn('grid-auto-columns is not supported by IE', ***REMOVED***
              node: decl
        ***REMOVED***)
            return undefined
      ***REMOVED*** else if (prop === 'grid-auto-rows') ***REMOVED***
            result.warn('grid-auto-rows is not supported by IE', ***REMOVED*** node: decl ***REMOVED***)
            return undefined
      ***REMOVED*** else if (prop === 'grid-auto-flow') ***REMOVED***
            let hasRows = parent.some(i => i.prop === 'grid-template-rows')
            let hasCols = parent.some(i => i.prop === 'grid-template-columns')

            if (hasGridTemplate(decl)) ***REMOVED***
              result.warn('grid-auto-flow is not supported by IE', ***REMOVED***
                node: decl
          ***REMOVED***)
        ***REMOVED*** else if (value.includes('dense')) ***REMOVED***
              result.warn('grid-auto-flow: dense is not supported by IE', ***REMOVED***
                node: decl
          ***REMOVED***)
        ***REMOVED*** else if (!hasRows && !hasCols) ***REMOVED***
              result.warn(
                'grid-auto-flow works only if grid-template-rows and ' +
                  'grid-template-columns are present in the same rule',
                ***REMOVED*** node: decl ***REMOVED***
              )
        ***REMOVED***
            return undefined
      ***REMOVED*** else if (value.includes('auto-fit')) ***REMOVED***
            result.warn('auto-fit value is not supported by IE', ***REMOVED***
              node: decl,
              word: 'auto-fit'
        ***REMOVED***)
            return undefined
      ***REMOVED*** else if (value.includes('auto-fill')) ***REMOVED***
            result.warn('auto-fill value is not supported by IE', ***REMOVED***
              node: decl,
              word: 'auto-fill'
        ***REMOVED***)
            return undefined
      ***REMOVED*** else if (prop.startsWith('grid-template') && value.includes('[')) ***REMOVED***
            result.warn(
              'Autoprefixer currently does not support line names. ' +
                'Try using grid-template-areas instead.',
              ***REMOVED*** node: decl, word: '[' ***REMOVED***
            )
      ***REMOVED***
    ***REMOVED***
        if (value.includes('radial-gradient')) ***REMOVED***
          if (OLD_RADIAL.test(decl.value)) ***REMOVED***
            result.warn(
              'Gradient has outdated direction syntax. ' +
                'New syntax is like `closest-side at 0 0` ' +
                'instead of `0 0, closest-side`.',
              ***REMOVED*** node: decl ***REMOVED***
            )
      ***REMOVED*** else ***REMOVED***
            let ast = parser(value)

            for (let i of ast.nodes) ***REMOVED***
              if (i.type === 'function' && i.value === 'radial-gradient') ***REMOVED***
                for (let word of i.nodes) ***REMOVED***
                  if (word.type === 'word') ***REMOVED***
                    if (word.value === 'cover') ***REMOVED***
                      result.warn(
                        'Gradient has outdated direction syntax. ' +
                          'Replace `cover` to `farthest-corner`.',
                        ***REMOVED*** node: decl ***REMOVED***
                      )
                ***REMOVED*** else if (word.value === 'contain') ***REMOVED***
                      result.warn(
                        'Gradient has outdated direction syntax. ' +
                          'Replace `contain` to `closest-side`.',
                        ***REMOVED*** node: decl ***REMOVED***
                      )
                ***REMOVED***
              ***REMOVED***
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
        if (value.includes('linear-gradient')) ***REMOVED***
          if (OLD_LINEAR.test(value)) ***REMOVED***
            result.warn(
              'Gradient has outdated direction syntax. ' +
                'New syntax is like `to left` instead of `right`.',
              ***REMOVED*** node: decl ***REMOVED***
            )
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

      if (SIZES.includes(decl.prop)) ***REMOVED***
        if (!decl.value.includes('-fill-available')) ***REMOVED***
          if (decl.value.includes('fill-available')) ***REMOVED***
            result.warn(
              'Replace fill-available to stretch, ' +
                'because spec had been changed',
              ***REMOVED*** node: decl ***REMOVED***
            )
      ***REMOVED*** else if (decl.value.includes('fill')) ***REMOVED***
            let ast = parser(value)
            if (ast.nodes.some(i => i.type === 'word' && i.value === 'fill')) ***REMOVED***
              result.warn(
                'Replace fill to stretch, because spec had been changed',
                ***REMOVED*** node: decl ***REMOVED***
              )
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

      let prefixer

      if (decl.prop === 'transition' || decl.prop === 'transition-property') ***REMOVED***
        // Transition
        return this.prefixes.transition.add(decl, result)
  ***REMOVED*** else if (decl.prop === 'align-self') ***REMOVED***
        // align-self flexbox or grid
        let display = this.displayType(decl)
        if (display !== 'grid' && this.prefixes.options.flexbox !== false) ***REMOVED***
          prefixer = this.prefixes.add['align-self']
          if (prefixer && prefixer.prefixes) ***REMOVED***
            prefixer.process(decl)
      ***REMOVED***
    ***REMOVED***
        if (this.gridStatus(decl, result) !== false) ***REMOVED***
          prefixer = this.prefixes.add['grid-row-align']
          if (prefixer && prefixer.prefixes) ***REMOVED***
            return prefixer.process(decl, result)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else if (decl.prop === 'justify-self') ***REMOVED***
        // justify-self flexbox or grid
        if (this.gridStatus(decl, result) !== false) ***REMOVED***
          prefixer = this.prefixes.add['grid-column-align']
          if (prefixer && prefixer.prefixes) ***REMOVED***
            return prefixer.process(decl, result)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else if (decl.prop === 'place-self') ***REMOVED***
        prefixer = this.prefixes.add['place-self']
        if (
          prefixer &&
          prefixer.prefixes &&
          this.gridStatus(decl, result) !== false
        ) ***REMOVED***
          return prefixer.process(decl, result)
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
        // Properties
        prefixer = this.prefixes.add[decl.prop]
        if (prefixer && prefixer.prefixes) ***REMOVED***
          return prefixer.process(decl, result)
    ***REMOVED***
  ***REMOVED***

      return undefined
***REMOVED***)

    // Insert grid-area prefixes. We need to be able to store the different
    // rules as a data and hack API is not enough for this
    if (this.gridStatus(css, result)) ***REMOVED***
      insertAreas(css, this.disabled)
***REMOVED***

    // Values
    return css.walkDecls(decl => ***REMOVED***
      if (this.disabledValue(decl, result)) return

      let unprefixed = this.prefixes.unprefixed(decl.prop)
      let list = this.prefixes.values('add', unprefixed)
      if (Array.isArray(list)) ***REMOVED***
        for (let value of list) ***REMOVED***
          if (value.process) value.process(decl, result)
    ***REMOVED***
  ***REMOVED***
      Value.save(this.prefixes, decl)
***REMOVED***)
***REMOVED***

  /**
   * Remove unnecessary pefixes
   */
  remove(css, result) ***REMOVED***
    // At-rules
    let resolution = this.prefixes.remove['@resolution']

    css.walkAtRules((rule, i) => ***REMOVED***
      if (this.prefixes.remove[`@$***REMOVED***rule.name***REMOVED***`]) ***REMOVED***
        if (!this.disabled(rule, result)) ***REMOVED***
          rule.parent.removeChild(i)
    ***REMOVED***
  ***REMOVED*** else if (
        rule.name === 'media' &&
        rule.params.includes('-resolution') &&
        resolution
      ) ***REMOVED***
        resolution.clean(rule)
  ***REMOVED***
***REMOVED***)

    // Selectors
    for (let checker of this.prefixes.remove.selectors) ***REMOVED***
      css.walkRules((rule, i) => ***REMOVED***
        if (checker.check(rule)) ***REMOVED***
          if (!this.disabled(rule, result)) ***REMOVED***
            rule.parent.removeChild(i)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***)
***REMOVED***

    return css.walkDecls((decl, i) => ***REMOVED***
      if (this.disabled(decl, result)) return

      let rule = decl.parent
      let unprefixed = this.prefixes.unprefixed(decl.prop)

      // Transition
      if (decl.prop === 'transition' || decl.prop === 'transition-property') ***REMOVED***
        this.prefixes.transition.remove(decl)
  ***REMOVED***

      // Properties
      if (
        this.prefixes.remove[decl.prop] &&
        this.prefixes.remove[decl.prop].remove
      ) ***REMOVED***
        let notHack = this.prefixes.group(decl).down(other => ***REMOVED***
          return this.prefixes.normalize(other.prop) === unprefixed
    ***REMOVED***)

        if (unprefixed === 'flex-flow') ***REMOVED***
          notHack = true
    ***REMOVED***

        if (decl.prop === '-webkit-box-orient') ***REMOVED***
          let hacks = ***REMOVED*** 'flex-direction': true, 'flex-flow': true ***REMOVED***
          if (!decl.parent.some(j => hacks[j.prop])) return
    ***REMOVED***

        if (notHack && !this.withHackValue(decl)) ***REMOVED***
          if (decl.raw('before').includes('\n')) ***REMOVED***
            this.reduceSpaces(decl)
      ***REMOVED***
          rule.removeChild(i)
          return
    ***REMOVED***
  ***REMOVED***

      // Values
      for (let checker of this.prefixes.values('remove', unprefixed)) ***REMOVED***
        if (!checker.check) continue
        if (!checker.check(decl.value)) continue

        unprefixed = checker.unprefixed
        let notHack = this.prefixes.group(decl).down(other => ***REMOVED***
          return other.value.includes(unprefixed)
    ***REMOVED***)

        if (notHack) ***REMOVED***
          rule.removeChild(i)
          return
    ***REMOVED***
  ***REMOVED***
***REMOVED***)
***REMOVED***

  /**
   * Some rare old values, which is not in standard
   */
  withHackValue(decl) ***REMOVED***
    return decl.prop === '-webkit-background-clip' && decl.value === 'text'
***REMOVED***

  /**
   * Check for grid/flexbox options.
   */
  disabledValue(node, result) ***REMOVED***
    if (this.gridStatus(node, result) === false && node.type === 'decl') ***REMOVED***
      if (node.prop === 'display' && node.value.includes('grid')) ***REMOVED***
        return true
  ***REMOVED***
***REMOVED***
    if (this.prefixes.options.flexbox === false && node.type === 'decl') ***REMOVED***
      if (node.prop === 'display' && node.value.includes('flex')) ***REMOVED***
        return true
  ***REMOVED***
***REMOVED***
    if (node.type === 'decl' && node.prop === 'content') ***REMOVED***
      return true
***REMOVED***

    return this.disabled(node, result)
***REMOVED***

  /**
   * Check for grid/flexbox options.
   */
  disabledDecl(node, result) ***REMOVED***
    if (this.gridStatus(node, result) === false && node.type === 'decl') ***REMOVED***
      if (node.prop.includes('grid') || node.prop === 'justify-items') ***REMOVED***
        return true
  ***REMOVED***
***REMOVED***
    if (this.prefixes.options.flexbox === false && node.type === 'decl') ***REMOVED***
      let other = ['order', 'justify-content', 'align-items', 'align-content']
      if (node.prop.includes('flex') || other.includes(node.prop)) ***REMOVED***
        return true
  ***REMOVED***
***REMOVED***

    return this.disabled(node, result)
***REMOVED***

  /**
   * Check for control comment and global options
   */
  disabled(node, result) ***REMOVED***
    if (!node) return false

    if (node._autoprefixerDisabled !== undefined) ***REMOVED***
      return node._autoprefixerDisabled
***REMOVED***

    if (node.parent) ***REMOVED***
      let p = node.prev()
      if (p && p.type === 'comment' && IGNORE_NEXT.test(p.text)) ***REMOVED***
        node._autoprefixerDisabled = true
        node._autoprefixerSelfDisabled = true
        return true
  ***REMOVED***
***REMOVED***

    let value = null
    if (node.nodes) ***REMOVED***
      let status
      node.each(i => ***REMOVED***
        if (i.type !== 'comment') return
        if (/(!\s*)?autoprefixer:\s*(off|on)/i.test(i.text)) ***REMOVED***
          if (typeof status !== 'undefined') ***REMOVED***
            result.warn(
              'Second Autoprefixer control comment ' +
                'was ignored. Autoprefixer applies control ' +
                'comment to whole block, not to next rules.',
              ***REMOVED*** node: i ***REMOVED***
            )
      ***REMOVED*** else ***REMOVED***
            status = /on/i.test(i.text)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***)

      if (status !== undefined) ***REMOVED***
        value = !status
  ***REMOVED***
***REMOVED***
    if (!node.nodes || value === null) ***REMOVED***
      if (node.parent) ***REMOVED***
        let isParentDisabled = this.disabled(node.parent, result)
        if (node.parent._autoprefixerSelfDisabled === true) ***REMOVED***
          value = false
    ***REMOVED*** else ***REMOVED***
          value = isParentDisabled
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
        value = false
  ***REMOVED***
***REMOVED***
    node._autoprefixerDisabled = value
    return value
***REMOVED***

  /**
   * Normalize spaces in cascade declaration group
   */
  reduceSpaces(decl) ***REMOVED***
    let stop = false
    this.prefixes.group(decl).up(() => ***REMOVED***
      stop = true
      return true
***REMOVED***)
    if (stop) ***REMOVED***
      return
***REMOVED***

    let parts = decl.raw('before').split('\n')
    let prevMin = parts[parts.length - 1].length
    let diff = false

    this.prefixes.group(decl).down(other => ***REMOVED***
      parts = other.raw('before').split('\n')
      let last = parts.length - 1

      if (parts[last].length > prevMin) ***REMOVED***
        if (diff === false) ***REMOVED***
          diff = parts[last].length - prevMin
    ***REMOVED***

        parts[last] = parts[last].slice(0, -diff)
        other.raws.before = parts.join('\n')
  ***REMOVED***
***REMOVED***)
***REMOVED***

  /**
   * Is it flebox or grid rule
   */
  displayType(decl) ***REMOVED***
    for (let i of decl.parent.nodes) ***REMOVED***
      if (i.prop !== 'display') ***REMOVED***
        continue
  ***REMOVED***

      if (i.value.includes('flex')) ***REMOVED***
        return 'flex'
  ***REMOVED***

      if (i.value.includes('grid')) ***REMOVED***
        return 'grid'
  ***REMOVED***
***REMOVED***

    return false
***REMOVED***

  /**
   * Set grid option via control comment
   */
  gridStatus(node, result) ***REMOVED***
    if (!node) return false

    if (node._autoprefixerGridStatus !== undefined) ***REMOVED***
      return node._autoprefixerGridStatus
***REMOVED***

    let value = null
    if (node.nodes) ***REMOVED***
      let status
      node.each(i => ***REMOVED***
        if (i.type !== 'comment') return
        if (GRID_REGEX.test(i.text)) ***REMOVED***
          let hasAutoplace = /:\s*autoplace/i.test(i.text)
          let noAutoplace = /no-autoplace/i.test(i.text)
          if (typeof status !== 'undefined') ***REMOVED***
            result.warn(
              'Second Autoprefixer grid control comment was ' +
                'ignored. Autoprefixer applies control comments to the whole ' +
                'block, not to the next rules.',
              ***REMOVED*** node: i ***REMOVED***
            )
      ***REMOVED*** else if (hasAutoplace) ***REMOVED***
            status = 'autoplace'
      ***REMOVED*** else if (noAutoplace) ***REMOVED***
            status = true
      ***REMOVED*** else ***REMOVED***
            status = /on/i.test(i.text)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***)

      if (status !== undefined) ***REMOVED***
        value = status
  ***REMOVED***
***REMOVED***

    if (node.type === 'atrule' && node.name === 'supports') ***REMOVED***
      let params = node.params
      if (params.includes('grid') && params.includes('auto')) ***REMOVED***
        value = false
  ***REMOVED***
***REMOVED***

    if (!node.nodes || value === null) ***REMOVED***
      if (node.parent) ***REMOVED***
        let isParentGrid = this.gridStatus(node.parent, result)
        if (node.parent._autoprefixerSelfDisabled === true) ***REMOVED***
          value = false
    ***REMOVED*** else ***REMOVED***
          value = isParentGrid
    ***REMOVED***
  ***REMOVED*** else if (typeof this.prefixes.options.grid !== 'undefined') ***REMOVED***
        value = this.prefixes.options.grid
  ***REMOVED*** else if (typeof process.env.AUTOPREFIXER_GRID !== 'undefined') ***REMOVED***
        if (process.env.AUTOPREFIXER_GRID === 'autoplace') ***REMOVED***
          value = 'autoplace'
    ***REMOVED*** else ***REMOVED***
          value = true
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
        value = false
  ***REMOVED***
***REMOVED***

    node._autoprefixerGridStatus = value
    return value
***REMOVED***
***REMOVED***

module.exports = Processor
