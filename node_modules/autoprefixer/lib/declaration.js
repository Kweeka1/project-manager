let Prefixer = require('./prefixer')
let Browsers = require('./browsers')
let utils = require('./utils')

class Declaration extends Prefixer ***REMOVED***
  /**
   * Always true, because we already get prefixer by property name
   */
  check(/* decl */) ***REMOVED***
    return true
***REMOVED***

  /**
   * Return prefixed version of property
   */
  prefixed(prop, prefix) ***REMOVED***
    return prefix + prop
***REMOVED***

  /**
   * Return unprefixed version of property
   */
  normalize(prop) ***REMOVED***
    return prop
***REMOVED***

  /**
   * Check `value`, that it contain other prefixes, rather than `prefix`
   */
  otherPrefixes(value, prefix) ***REMOVED***
    for (let other of Browsers.prefixes()) ***REMOVED***
      if (other === prefix) ***REMOVED***
        continue
  ***REMOVED***
      if (value.includes(other)) ***REMOVED***
        return true
  ***REMOVED***
***REMOVED***
    return false
***REMOVED***

  /**
   * Set prefix to declaration
   */
  set(decl, prefix) ***REMOVED***
    decl.prop = this.prefixed(decl.prop, prefix)
    return decl
***REMOVED***

  /**
   * Should we use visual cascade for prefixes
   */
  needCascade(decl) ***REMOVED***
    if (!decl._autoprefixerCascade) ***REMOVED***
      decl._autoprefixerCascade =
        this.all.options.cascade !== false && decl.raw('before').includes('\n')
***REMOVED***
    return decl._autoprefixerCascade
***REMOVED***

  /**
   * Return maximum length of possible prefixed property
   */
  maxPrefixed(prefixes, decl) ***REMOVED***
    if (decl._autoprefixerMax) ***REMOVED***
      return decl._autoprefixerMax
***REMOVED***

    let max = 0
    for (let prefix of prefixes) ***REMOVED***
      prefix = utils.removeNote(prefix)
      if (prefix.length > max) ***REMOVED***
        max = prefix.length
  ***REMOVED***
***REMOVED***
    decl._autoprefixerMax = max

    return decl._autoprefixerMax
***REMOVED***

  /**
   * Calculate indentation to create visual cascade
   */
  calcBefore(prefixes, decl, prefix = '') ***REMOVED***
    let max = this.maxPrefixed(prefixes, decl)
    let diff = max - utils.removeNote(prefix).length

    let before = decl.raw('before')
    if (diff > 0) ***REMOVED***
      before += Array(diff).fill(' ').join('')
***REMOVED***

    return before
***REMOVED***

  /**
   * Remove visual cascade
   */
  restoreBefore(decl) ***REMOVED***
    let lines = decl.raw('before').split('\n')
    let min = lines[lines.length - 1]

    this.all.group(decl).up(prefixed => ***REMOVED***
      let array = prefixed.raw('before').split('\n')
      let last = array[array.length - 1]
      if (last.length < min.length) ***REMOVED***
        min = last
  ***REMOVED***
***REMOVED***)

    lines[lines.length - 1] = min
    decl.raws.before = lines.join('\n')
***REMOVED***

  /**
   * Clone and insert new declaration
   */
  insert(decl, prefix, prefixes) ***REMOVED***
    let cloned = this.set(this.clone(decl), prefix)
    if (!cloned) return undefined

    let already = decl.parent.some(
      i => i.prop === cloned.prop && i.value === cloned.value
    )
    if (already) ***REMOVED***
      return undefined
***REMOVED***

    if (this.needCascade(decl)) ***REMOVED***
      cloned.raws.before = this.calcBefore(prefixes, decl, prefix)
***REMOVED***
    return decl.parent.insertBefore(decl, cloned)
***REMOVED***

  /**
   * Did this declaration has this prefix above
   */
  isAlready(decl, prefixed) ***REMOVED***
    let already = this.all.group(decl).up(i => i.prop === prefixed)
    if (!already) ***REMOVED***
      already = this.all.group(decl).down(i => i.prop === prefixed)
***REMOVED***
    return already
***REMOVED***

  /**
   * Clone and add prefixes for declaration
   */
  add(decl, prefix, prefixes, result) ***REMOVED***
    let prefixed = this.prefixed(decl.prop, prefix)
    if (
      this.isAlready(decl, prefixed) ||
      this.otherPrefixes(decl.value, prefix)
    ) ***REMOVED***
      return undefined
***REMOVED***
    return this.insert(decl, prefix, prefixes, result)
***REMOVED***

  /**
   * Add spaces for visual cascade
   */
  process(decl, result) ***REMOVED***
    if (!this.needCascade(decl)) ***REMOVED***
      super.process(decl, result)
      return
***REMOVED***

    let prefixes = super.process(decl, result)

    if (!prefixes || !prefixes.length) ***REMOVED***
      return
***REMOVED***

    this.restoreBefore(decl)
    decl.raws.before = this.calcBefore(prefixes, decl)
***REMOVED***

  /**
   * Return list of prefixed properties to clean old prefixes
   */
  old(prop, prefix) ***REMOVED***
    return [this.prefixed(prop, prefix)]
***REMOVED***
***REMOVED***

module.exports = Declaration
