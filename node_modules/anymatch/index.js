'use strict';

Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);

const picomatch = require('picomatch');
const normalizePath = require('normalize-path');

/**
 * @typedef ***REMOVED***(testString: string) => boolean***REMOVED*** AnymatchFn
 * @typedef ***REMOVED***string|RegExp|AnymatchFn***REMOVED*** AnymatchPattern
 * @typedef ***REMOVED***AnymatchPattern|AnymatchPattern[]***REMOVED*** AnymatchMatcher
 */
const BANG = '!';
const DEFAULT_OPTIONS = ***REMOVED***returnIndex: false***REMOVED***;
const arrify = (item) => Array.isArray(item) ? item : [item];

/**
 * @param ***REMOVED***AnymatchPattern***REMOVED*** matcher
 * @param ***REMOVED***object***REMOVED*** options
 * @returns ***REMOVED***AnymatchFn***REMOVED***
 */
const createPattern = (matcher, options) => ***REMOVED***
  if (typeof matcher === 'function') ***REMOVED***
    return matcher;
***REMOVED***
  if (typeof matcher === 'string') ***REMOVED***
    const glob = picomatch(matcher, options);
    return (string) => matcher === string || glob(string);
***REMOVED***
  if (matcher instanceof RegExp) ***REMOVED***
    return (string) => matcher.test(string);
***REMOVED***
  return (string) => false;
***REMOVED***;

/**
 * @param ***REMOVED***Array<Function>***REMOVED*** patterns
 * @param ***REMOVED***Array<Function>***REMOVED*** negPatterns
 * @param ***REMOVED***String|Array***REMOVED*** args
 * @param ***REMOVED***Boolean***REMOVED*** returnIndex
 * @returns ***REMOVED***boolean|number***REMOVED***
 */
const matchPatterns = (patterns, negPatterns, args, returnIndex) => ***REMOVED***
  const isList = Array.isArray(args);
  const _path = isList ? args[0] : args;
  if (!isList && typeof _path !== 'string') ***REMOVED***
    throw new TypeError('anymatch: second argument must be a string: got ' +
      Object.prototype.toString.call(_path))
***REMOVED***
  const path = normalizePath(_path);

  for (let index = 0; index < negPatterns.length; index++) ***REMOVED***
    const nglob = negPatterns[index];
    if (nglob(path)) ***REMOVED***
      return returnIndex ? -1 : false;
***REMOVED***
***REMOVED***

  const applied = isList && [path].concat(args.slice(1));
  for (let index = 0; index < patterns.length; index++) ***REMOVED***
    const pattern = patterns[index];
    if (isList ? pattern(...applied) : pattern(path)) ***REMOVED***
      return returnIndex ? index : true;
***REMOVED***
***REMOVED***

  return returnIndex ? -1 : false;
***REMOVED***;

/**
 * @param ***REMOVED***AnymatchMatcher***REMOVED*** matchers
 * @param ***REMOVED***Array|string***REMOVED*** testString
 * @param ***REMOVED***object***REMOVED*** options
 * @returns ***REMOVED***boolean|number|Function***REMOVED***
 */
const anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => ***REMOVED***
  if (matchers == null) ***REMOVED***
    throw new TypeError('anymatch: specify first argument');
***REMOVED***
  const opts = typeof options === 'boolean' ? ***REMOVED***returnIndex: options***REMOVED*** : options;
  const returnIndex = opts.returnIndex || false;

  // Early cache for matchers.
  const mtchers = arrify(matchers);
  const negatedGlobs = mtchers
    .filter(item => typeof item === 'string' && item.charAt(0) === BANG)
    .map(item => item.slice(1))
    .map(item => picomatch(item, opts));
  const patterns = mtchers
    .filter(item => typeof item !== 'string' || (typeof item === 'string' && item.charAt(0) !== BANG))
    .map(matcher => createPattern(matcher, opts));

  if (testString == null) ***REMOVED***
    return (testString, ri = false) => ***REMOVED***
      const returnIndex = typeof ri === 'boolean' ? ri : false;
      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
***REMOVED***
***REMOVED***

  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
***REMOVED***;

anymatch.default = anymatch;
module.exports = anymatch;
