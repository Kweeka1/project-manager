'use strict'

const fs = require('graceful-fs')
const path = require('path')
const assert = require('assert')

const isWindows = (process.platform === 'win32')

function defaults (options) ***REMOVED***
  const methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ]
  methods.forEach(m => ***REMOVED***
    options[m] = options[m] || fs[m]
    m = m + 'Sync'
    options[m] = options[m] || fs[m]
***REMOVED***)

  options.maxBusyTries = options.maxBusyTries || 3
***REMOVED***

function rimraf (p, options, cb) ***REMOVED***
  let busyTries = 0

  if (typeof options === 'function') ***REMOVED***
    cb = options
    options = ***REMOVED******REMOVED***
***REMOVED***

  assert(p, 'rimraf: missing path')
  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')
  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required')
  assert(options, 'rimraf: invalid options argument provided')
  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')

  defaults(options)

  rimraf_(p, options, function CB (er) ***REMOVED***
    if (er) ***REMOVED***
      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&
          busyTries < options.maxBusyTries) ***REMOVED***
        busyTries++
        const time = busyTries * 100
        // try again, with the same exact callback as this one.
        return setTimeout(() => rimraf_(p, options, CB), time)
  ***REMOVED***

      // already gone
      if (er.code === 'ENOENT') er = null
***REMOVED***

    cb(er)
***REMOVED***)
***REMOVED***

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_ (p, options, cb) ***REMOVED***
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, (er, st) => ***REMOVED***
    if (er && er.code === 'ENOENT') ***REMOVED***
      return cb(null)
***REMOVED***

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === 'EPERM' && isWindows) ***REMOVED***
      return fixWinEPERM(p, options, er, cb)
***REMOVED***

    if (st && st.isDirectory()) ***REMOVED***
      return rmdir(p, options, er, cb)
***REMOVED***

    options.unlink(p, er => ***REMOVED***
      if (er) ***REMOVED***
        if (er.code === 'ENOENT') ***REMOVED***
          return cb(null)
    ***REMOVED***
        if (er.code === 'EPERM') ***REMOVED***
          return (isWindows)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
    ***REMOVED***
        if (er.code === 'EISDIR') ***REMOVED***
          return rmdir(p, options, er, cb)
    ***REMOVED***
  ***REMOVED***
      return cb(er)
***REMOVED***)
***REMOVED***)
***REMOVED***

function fixWinEPERM (p, options, er, cb) ***REMOVED***
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.chmod(p, 0o666, er2 => ***REMOVED***
    if (er2) ***REMOVED***
      cb(er2.code === 'ENOENT' ? null : er)
***REMOVED*** else ***REMOVED***
      options.stat(p, (er3, stats) => ***REMOVED***
        if (er3) ***REMOVED***
          cb(er3.code === 'ENOENT' ? null : er)
    ***REMOVED*** else if (stats.isDirectory()) ***REMOVED***
          rmdir(p, options, er, cb)
    ***REMOVED*** else ***REMOVED***
          options.unlink(p, cb)
    ***REMOVED***
  ***REMOVED***)
***REMOVED***
***REMOVED***)
***REMOVED***

function fixWinEPERMSync (p, options, er) ***REMOVED***
  let stats

  assert(p)
  assert(options)

  try ***REMOVED***
    options.chmodSync(p, 0o666)
***REMOVED*** catch (er2) ***REMOVED***
    if (er2.code === 'ENOENT') ***REMOVED***
      return
***REMOVED*** else ***REMOVED***
      throw er
***REMOVED***
***REMOVED***

  try ***REMOVED***
    stats = options.statSync(p)
***REMOVED*** catch (er3) ***REMOVED***
    if (er3.code === 'ENOENT') ***REMOVED***
      return
***REMOVED*** else ***REMOVED***
      throw er
***REMOVED***
***REMOVED***

  if (stats.isDirectory()) ***REMOVED***
    rmdirSync(p, options, er)
***REMOVED*** else ***REMOVED***
    options.unlinkSync(p)
***REMOVED***
***REMOVED***

function rmdir (p, options, originalEr, cb) ***REMOVED***
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, er => ***REMOVED***
    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) ***REMOVED***
      rmkids(p, options, cb)
***REMOVED*** else if (er && er.code === 'ENOTDIR') ***REMOVED***
      cb(originalEr)
***REMOVED*** else ***REMOVED***
      cb(er)
***REMOVED***
***REMOVED***)
***REMOVED***

function rmkids (p, options, cb) ***REMOVED***
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.readdir(p, (er, files) => ***REMOVED***
    if (er) return cb(er)

    let n = files.length
    let errState

    if (n === 0) return options.rmdir(p, cb)

    files.forEach(f => ***REMOVED***
      rimraf(path.join(p, f), options, er => ***REMOVED***
        if (errState) ***REMOVED***
          return
    ***REMOVED***
        if (er) return cb(errState = er)
        if (--n === 0) ***REMOVED***
          options.rmdir(p, cb)
    ***REMOVED***
  ***REMOVED***)
***REMOVED***)
***REMOVED***)
***REMOVED***

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync (p, options) ***REMOVED***
  let st

  options = options || ***REMOVED******REMOVED***
  defaults(options)

  assert(p, 'rimraf: missing path')
  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')
  assert(options, 'rimraf: missing options')
  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')

  try ***REMOVED***
    st = options.lstatSync(p)
***REMOVED*** catch (er) ***REMOVED***
    if (er.code === 'ENOENT') ***REMOVED***
      return
***REMOVED***

    // Windows can EPERM on stat.  Life is suffering.
    if (er.code === 'EPERM' && isWindows) ***REMOVED***
      fixWinEPERMSync(p, options, er)
***REMOVED***
***REMOVED***

  try ***REMOVED***
    // sunos lets the root user unlink directories, which is... weird.
    if (st && st.isDirectory()) ***REMOVED***
      rmdirSync(p, options, null)
***REMOVED*** else ***REMOVED***
      options.unlinkSync(p)
***REMOVED***
***REMOVED*** catch (er) ***REMOVED***
    if (er.code === 'ENOENT') ***REMOVED***
      return
***REMOVED*** else if (er.code === 'EPERM') ***REMOVED***
      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
***REMOVED*** else if (er.code !== 'EISDIR') ***REMOVED***
      throw er
***REMOVED***
    rmdirSync(p, options, er)
***REMOVED***
***REMOVED***

function rmdirSync (p, options, originalEr) ***REMOVED***
  assert(p)
  assert(options)

  try ***REMOVED***
    options.rmdirSync(p)
***REMOVED*** catch (er) ***REMOVED***
    if (er.code === 'ENOTDIR') ***REMOVED***
      throw originalEr
***REMOVED*** else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') ***REMOVED***
      rmkidsSync(p, options)
***REMOVED*** else if (er.code !== 'ENOENT') ***REMOVED***
      throw er
***REMOVED***
***REMOVED***
***REMOVED***

function rmkidsSync (p, options) ***REMOVED***
  assert(p)
  assert(options)
  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))

  if (isWindows) ***REMOVED***
    // We only end up here once we got ENOTEMPTY at least once, and
    // at this point, we are guaranteed to have removed all the kids.
    // So, we know that it won't be ENOENT or ENOTDIR or anything else.
    // try really hard to delete stuff on windows, because it has a
    // PROFOUNDLY annoying habit of not closing handles promptly when
    // files are deleted, resulting in spurious ENOTEMPTY errors.
    const startTime = Date.now()
    do ***REMOVED***
      try ***REMOVED***
        const ret = options.rmdirSync(p, options)
        return ret
  ***REMOVED*** catch ***REMOVED******REMOVED***
***REMOVED*** while (Date.now() - startTime < 500) // give up after 500ms
***REMOVED*** else ***REMOVED***
    const ret = options.rmdirSync(p, options)
    return ret
***REMOVED***
***REMOVED***

module.exports = rimraf
rimraf.sync = rimrafSync
