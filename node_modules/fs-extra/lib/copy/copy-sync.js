'use strict'

const fs = require('graceful-fs')
const path = require('path')
const mkdirsSync = require('../mkdirs').mkdirsSync
const utimesMillisSync = require('../util/utimes').utimesMillisSync
const stat = require('../util/stat')

function copySync (src, dest, opts) ***REMOVED***
  if (typeof opts === 'function') ***REMOVED***
    opts = ***REMOVED*** filter: opts ***REMOVED***
***REMOVED***

  opts = opts || ***REMOVED******REMOVED***
  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') ***REMOVED***
    process.emitWarning(
      'Using the preserveTimestamps option in 32-bit node is not recommended;\n\n' +
      '\tsee https://github.com/jprichardson/node-fs-extra/issues/269',
      'Warning', 'fs-extra-WARN0002'
    )
***REMOVED***

  const ***REMOVED*** srcStat, destStat ***REMOVED*** = stat.checkPathsSync(src, dest, 'copy', opts)
  stat.checkParentPathsSync(src, srcStat, dest, 'copy')
  return handleFilterAndCopy(destStat, src, dest, opts)
***REMOVED***

function handleFilterAndCopy (destStat, src, dest, opts) ***REMOVED***
  if (opts.filter && !opts.filter(src, dest)) return
  const destParent = path.dirname(dest)
  if (!fs.existsSync(destParent)) mkdirsSync(destParent)
  return getStats(destStat, src, dest, opts)
***REMOVED***

function startCopy (destStat, src, dest, opts) ***REMOVED***
  if (opts.filter && !opts.filter(src, dest)) return
  return getStats(destStat, src, dest, opts)
***REMOVED***

function getStats (destStat, src, dest, opts) ***REMOVED***
  const statSync = opts.dereference ? fs.statSync : fs.lstatSync
  const srcStat = statSync(src)

  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)
  else if (srcStat.isFile() ||
           srcStat.isCharacterDevice() ||
           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)
  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)
  else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: $***REMOVED***src***REMOVED***`)
  else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: $***REMOVED***src***REMOVED***`)
  throw new Error(`Unknown file: $***REMOVED***src***REMOVED***`)
***REMOVED***

function onFile (srcStat, destStat, src, dest, opts) ***REMOVED***
  if (!destStat) return copyFile(srcStat, src, dest, opts)
  return mayCopyFile(srcStat, src, dest, opts)
***REMOVED***

function mayCopyFile (srcStat, src, dest, opts) ***REMOVED***
  if (opts.overwrite) ***REMOVED***
    fs.unlinkSync(dest)
    return copyFile(srcStat, src, dest, opts)
***REMOVED*** else if (opts.errorOnExist) ***REMOVED***
    throw new Error(`'$***REMOVED***dest***REMOVED***' already exists`)
***REMOVED***
***REMOVED***

function copyFile (srcStat, src, dest, opts) ***REMOVED***
  fs.copyFileSync(src, dest)
  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest)
  return setDestMode(dest, srcStat.mode)
***REMOVED***

function handleTimestamps (srcMode, src, dest) ***REMOVED***
  // Make sure the file is writable before setting the timestamp
  // otherwise open fails with EPERM when invoked with 'r+'
  // (through utimes call)
  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode)
  return setDestTimestamps(src, dest)
***REMOVED***

function fileIsNotWritable (srcMode) ***REMOVED***
  return (srcMode & 0o200) === 0
***REMOVED***

function makeFileWritable (dest, srcMode) ***REMOVED***
  return setDestMode(dest, srcMode | 0o200)
***REMOVED***

function setDestMode (dest, srcMode) ***REMOVED***
  return fs.chmodSync(dest, srcMode)
***REMOVED***

function setDestTimestamps (src, dest) ***REMOVED***
  // The initial srcStat.atime cannot be trusted
  // because it is modified by the read(2) system call
  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
  const updatedSrcStat = fs.statSync(src)
  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime)
***REMOVED***

function onDir (srcStat, destStat, src, dest, opts) ***REMOVED***
  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts)
  return copyDir(src, dest, opts)
***REMOVED***

function mkDirAndCopy (srcMode, src, dest, opts) ***REMOVED***
  fs.mkdirSync(dest)
  copyDir(src, dest, opts)
  return setDestMode(dest, srcMode)
***REMOVED***

function copyDir (src, dest, opts) ***REMOVED***
  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))
***REMOVED***

function copyDirItem (item, src, dest, opts) ***REMOVED***
  const srcItem = path.join(src, item)
  const destItem = path.join(dest, item)
  const ***REMOVED*** destStat ***REMOVED*** = stat.checkPathsSync(srcItem, destItem, 'copy', opts)
  return startCopy(destStat, srcItem, destItem, opts)
***REMOVED***

function onLink (destStat, src, dest, opts) ***REMOVED***
  let resolvedSrc = fs.readlinkSync(src)
  if (opts.dereference) ***REMOVED***
    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)
***REMOVED***

  if (!destStat) ***REMOVED***
    return fs.symlinkSync(resolvedSrc, dest)
***REMOVED*** else ***REMOVED***
    let resolvedDest
    try ***REMOVED***
      resolvedDest = fs.readlinkSync(dest)
***REMOVED*** catch (err) ***REMOVED***
      // dest exists and is a regular file or directory,
      // Windows may throw UNKNOWN error. If dest already exists,
      // fs throws error anyway, so no need to guard against it here.
      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)
      throw err
***REMOVED***
    if (opts.dereference) ***REMOVED***
      resolvedDest = path.resolve(process.cwd(), resolvedDest)
***REMOVED***
    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) ***REMOVED***
      throw new Error(`Cannot copy '$***REMOVED***resolvedSrc***REMOVED***' to a subdirectory of itself, '$***REMOVED***resolvedDest***REMOVED***'.`)
***REMOVED***

    // prevent copy if src is a subdir of dest since unlinking
    // dest in this case would result in removing src contents
    // and therefore a broken symlink would be created.
    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) ***REMOVED***
      throw new Error(`Cannot overwrite '$***REMOVED***resolvedDest***REMOVED***' with '$***REMOVED***resolvedSrc***REMOVED***'.`)
***REMOVED***
    return copyLink(resolvedSrc, dest)
***REMOVED***
***REMOVED***

function copyLink (resolvedSrc, dest) ***REMOVED***
  fs.unlinkSync(dest)
  return fs.symlinkSync(resolvedSrc, dest)
***REMOVED***

module.exports = copySync
