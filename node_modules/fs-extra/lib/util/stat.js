'use strict'

const fs = require('../fs')
const path = require('path')
const util = require('util')

function getStats (src, dest, opts) ***REMOVED***
  const statFunc = opts.dereference
    ? (file) => fs.stat(file, ***REMOVED*** bigint: true ***REMOVED***)
    : (file) => fs.lstat(file, ***REMOVED*** bigint: true ***REMOVED***)
  return Promise.all([
    statFunc(src),
    statFunc(dest).catch(err => ***REMOVED***
      if (err.code === 'ENOENT') return null
      throw err
***REMOVED***)
  ]).then(([srcStat, destStat]) => (***REMOVED*** srcStat, destStat ***REMOVED***))
***REMOVED***

function getStatsSync (src, dest, opts) ***REMOVED***
  let destStat
  const statFunc = opts.dereference
    ? (file) => fs.statSync(file, ***REMOVED*** bigint: true ***REMOVED***)
    : (file) => fs.lstatSync(file, ***REMOVED*** bigint: true ***REMOVED***)
  const srcStat = statFunc(src)
  try ***REMOVED***
    destStat = statFunc(dest)
***REMOVED*** catch (err) ***REMOVED***
    if (err.code === 'ENOENT') return ***REMOVED*** srcStat, destStat: null ***REMOVED***
    throw err
***REMOVED***
  return ***REMOVED*** srcStat, destStat ***REMOVED***
***REMOVED***

function checkPaths (src, dest, funcName, opts, cb) ***REMOVED***
  util.callbackify(getStats)(src, dest, opts, (err, stats) => ***REMOVED***
    if (err) return cb(err)
    const ***REMOVED*** srcStat, destStat ***REMOVED*** = stats

    if (destStat) ***REMOVED***
      if (areIdentical(srcStat, destStat)) ***REMOVED***
        const srcBaseName = path.basename(src)
        const destBaseName = path.basename(dest)
        if (funcName === 'move' &&
          srcBaseName !== destBaseName &&
          srcBaseName.toLowerCase() === destBaseName.toLowerCase()) ***REMOVED***
          return cb(null, ***REMOVED*** srcStat, destStat, isChangingCase: true ***REMOVED***)
    ***REMOVED***
        return cb(new Error('Source and destination must not be the same.'))
  ***REMOVED***
      if (srcStat.isDirectory() && !destStat.isDirectory()) ***REMOVED***
        return cb(new Error(`Cannot overwrite non-directory '$***REMOVED***dest***REMOVED***' with directory '$***REMOVED***src***REMOVED***'.`))
  ***REMOVED***
      if (!srcStat.isDirectory() && destStat.isDirectory()) ***REMOVED***
        return cb(new Error(`Cannot overwrite directory '$***REMOVED***dest***REMOVED***' with non-directory '$***REMOVED***src***REMOVED***'.`))
  ***REMOVED***
***REMOVED***

    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) ***REMOVED***
      return cb(new Error(errMsg(src, dest, funcName)))
***REMOVED***
    return cb(null, ***REMOVED*** srcStat, destStat ***REMOVED***)
***REMOVED***)
***REMOVED***

function checkPathsSync (src, dest, funcName, opts) ***REMOVED***
  const ***REMOVED*** srcStat, destStat ***REMOVED*** = getStatsSync(src, dest, opts)

  if (destStat) ***REMOVED***
    if (areIdentical(srcStat, destStat)) ***REMOVED***
      const srcBaseName = path.basename(src)
      const destBaseName = path.basename(dest)
      if (funcName === 'move' &&
        srcBaseName !== destBaseName &&
        srcBaseName.toLowerCase() === destBaseName.toLowerCase()) ***REMOVED***
        return ***REMOVED*** srcStat, destStat, isChangingCase: true ***REMOVED***
  ***REMOVED***
      throw new Error('Source and destination must not be the same.')
***REMOVED***
    if (srcStat.isDirectory() && !destStat.isDirectory()) ***REMOVED***
      throw new Error(`Cannot overwrite non-directory '$***REMOVED***dest***REMOVED***' with directory '$***REMOVED***src***REMOVED***'.`)
***REMOVED***
    if (!srcStat.isDirectory() && destStat.isDirectory()) ***REMOVED***
      throw new Error(`Cannot overwrite directory '$***REMOVED***dest***REMOVED***' with non-directory '$***REMOVED***src***REMOVED***'.`)
***REMOVED***
***REMOVED***

  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) ***REMOVED***
    throw new Error(errMsg(src, dest, funcName))
***REMOVED***
  return ***REMOVED*** srcStat, destStat ***REMOVED***
***REMOVED***

// recursively check if dest parent is a subdirectory of src.
// It works for all file types including symlinks since it
// checks the src and dest inodes. It starts from the deepest
// parent and stops once it reaches the src parent or the root path.
function checkParentPaths (src, srcStat, dest, funcName, cb) ***REMOVED***
  const srcParent = path.resolve(path.dirname(src))
  const destParent = path.resolve(path.dirname(dest))
  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()
  fs.stat(destParent, ***REMOVED*** bigint: true ***REMOVED***, (err, destStat) => ***REMOVED***
    if (err) ***REMOVED***
      if (err.code === 'ENOENT') return cb()
      return cb(err)
***REMOVED***
    if (areIdentical(srcStat, destStat)) ***REMOVED***
      return cb(new Error(errMsg(src, dest, funcName)))
***REMOVED***
    return checkParentPaths(src, srcStat, destParent, funcName, cb)
***REMOVED***)
***REMOVED***

function checkParentPathsSync (src, srcStat, dest, funcName) ***REMOVED***
  const srcParent = path.resolve(path.dirname(src))
  const destParent = path.resolve(path.dirname(dest))
  if (destParent === srcParent || destParent === path.parse(destParent).root) return
  let destStat
  try ***REMOVED***
    destStat = fs.statSync(destParent, ***REMOVED*** bigint: true ***REMOVED***)
***REMOVED*** catch (err) ***REMOVED***
    if (err.code === 'ENOENT') return
    throw err
***REMOVED***
  if (areIdentical(srcStat, destStat)) ***REMOVED***
    throw new Error(errMsg(src, dest, funcName))
***REMOVED***
  return checkParentPathsSync(src, srcStat, destParent, funcName)
***REMOVED***

function areIdentical (srcStat, destStat) ***REMOVED***
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev
***REMOVED***

// return true if dest is a subdir of src, otherwise false.
// It only checks the path strings.
function isSrcSubdir (src, dest) ***REMOVED***
  const srcArr = path.resolve(src).split(path.sep).filter(i => i)
  const destArr = path.resolve(dest).split(path.sep).filter(i => i)
  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)
***REMOVED***

function errMsg (src, dest, funcName) ***REMOVED***
  return `Cannot $***REMOVED***funcName***REMOVED*** '$***REMOVED***src***REMOVED***' to a subdirectory of itself, '$***REMOVED***dest***REMOVED***'.`
***REMOVED***

module.exports = ***REMOVED***
  checkPaths,
  checkPathsSync,
  checkParentPaths,
  checkParentPathsSync,
  isSrcSubdir,
  areIdentical
***REMOVED***
