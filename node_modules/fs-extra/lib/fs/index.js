'use strict'
// This is adapted from https://github.com/normalize/mz
// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
const u = require('universalify').fromCallback
const fs = require('graceful-fs')

const api = [
  'access',
  'appendFile',
  'chmod',
  'chown',
  'close',
  'copyFile',
  'fchmod',
  'fchown',
  'fdatasync',
  'fstat',
  'fsync',
  'ftruncate',
  'futimes',
  'lchmod',
  'lchown',
  'link',
  'lstat',
  'mkdir',
  'mkdtemp',
  'open',
  'opendir',
  'readdir',
  'readFile',
  'readlink',
  'realpath',
  'rename',
  'rm',
  'rmdir',
  'stat',
  'symlink',
  'truncate',
  'unlink',
  'utimes',
  'writeFile'
].filter(key => ***REMOVED***
  // Some commands are not available on some systems. Ex:
  // fs.opendir was added in Node.js v12.12.0
  // fs.rm was added in Node.js v14.14.0
  // fs.lchown is not available on at least some Linux
  return typeof fs[key] === 'function'
***REMOVED***)

// Export cloned fs:
Object.assign(exports, fs)

// Universalify async methods:
api.forEach(method => ***REMOVED***
  exports[method] = u(fs[method])
***REMOVED***)

// We differ from mz/fs in that we still ship the old, broken, fs.exists()
// since we are a drop-in replacement for the native module
exports.exists = function (filename, callback) ***REMOVED***
  if (typeof callback === 'function') ***REMOVED***
    return fs.exists(filename, callback)
***REMOVED***
  return new Promise(resolve => ***REMOVED***
    return fs.exists(filename, resolve)
***REMOVED***)
***REMOVED***

// fs.read(), fs.write(), & fs.writev() need special treatment due to multiple callback args

exports.read = function (fd, buffer, offset, length, position, callback) ***REMOVED***
  if (typeof callback === 'function') ***REMOVED***
    return fs.read(fd, buffer, offset, length, position, callback)
***REMOVED***
  return new Promise((resolve, reject) => ***REMOVED***
    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => ***REMOVED***
      if (err) return reject(err)
      resolve(***REMOVED*** bytesRead, buffer ***REMOVED***)
***REMOVED***)
***REMOVED***)
***REMOVED***

// Function signature can be
// fs.write(fd, buffer[, offset[, length[, position]]], callback)
// OR
// fs.write(fd, string[, position[, encoding]], callback)
// We need to handle both cases, so we use ...args
exports.write = function (fd, buffer, ...args) ***REMOVED***
  if (typeof args[args.length - 1] === 'function') ***REMOVED***
    return fs.write(fd, buffer, ...args)
***REMOVED***

  return new Promise((resolve, reject) => ***REMOVED***
    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => ***REMOVED***
      if (err) return reject(err)
      resolve(***REMOVED*** bytesWritten, buffer ***REMOVED***)
***REMOVED***)
***REMOVED***)
***REMOVED***

// fs.writev only available in Node v12.9.0+
if (typeof fs.writev === 'function') ***REMOVED***
  // Function signature is
  // s.writev(fd, buffers[, position], callback)
  // We need to handle the optional arg, so we use ...args
  exports.writev = function (fd, buffers, ...args) ***REMOVED***
    if (typeof args[args.length - 1] === 'function') ***REMOVED***
      return fs.writev(fd, buffers, ...args)
***REMOVED***

    return new Promise((resolve, reject) => ***REMOVED***
      fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => ***REMOVED***
        if (err) return reject(err)
        resolve(***REMOVED*** bytesWritten, buffers ***REMOVED***)
  ***REMOVED***)
***REMOVED***)
***REMOVED***
***REMOVED***

// fs.realpath.native sometimes not available if fs is monkey-patched
if (typeof fs.realpath.native === 'function') ***REMOVED***
  exports.realpath.native = u(fs.realpath.native)
***REMOVED*** else ***REMOVED***
  process.emitWarning(
    'fs.realpath.native is not a function. Is fs being monkey-patched?',
    'Warning', 'fs-extra-WARN0003'
  )
***REMOVED***
