#!/usr/bin/env node

import fs from 'fs-extra'
import path from 'path'

import prettyHrtime from 'pretty-hrtime'
import stdin from 'get-stdin'
import read from 'read-cache'
import pc from 'picocolors'
import ***REMOVED*** globby ***REMOVED*** from 'globby'
import slash from 'slash'
import chokidar from 'chokidar'

import postcss from 'postcss'
import postcssrc from 'postcss-load-config'
import postcssReporter from 'postcss-reporter/lib/formatter.js'

import argv from './lib/args.js'
import createDependencyGraph from './lib/DependencyGraph.js'
import getMapfile from './lib/getMapfile.js'

const reporter = postcssReporter()
const depGraph = createDependencyGraph()

let input = argv._
const ***REMOVED*** dir, output ***REMOVED*** = argv

if (argv.map) argv.map = ***REMOVED*** inline: false ***REMOVED***

let cliConfig

async function buildCliConfig() ***REMOVED***
  cliConfig = ***REMOVED***
    options: ***REMOVED***
      map: argv.map !== undefined ? argv.map : ***REMOVED*** inline: true ***REMOVED***,
      parser: argv.parser ? await import(argv.parser) : undefined,
      syntax: argv.syntax ? await import(argv.syntax) : undefined,
      stringifier: argv.stringifier
        ? await import(argv.stringifier)
        : undefined,
***REMOVED***,
    plugins: argv.use
      ? await Promise.all(
          argv.use.map(async (plugin) => ***REMOVED***
            try ***REMOVED***
              return (await import(plugin)).default()
        ***REMOVED*** catch (e) ***REMOVED***
              const msg = e.message || `Cannot find module '$***REMOVED***plugin***REMOVED***'`
              let prefix = msg.includes(plugin) ? '' : ` ($***REMOVED***plugin***REMOVED***)`
              if (e.name && e.name !== 'Error') prefix += `: $***REMOVED***e.name***REMOVED***`
              return error(`Plugin Error$***REMOVED***prefix***REMOVED***: $***REMOVED***msg***REMOVED***'`)
        ***REMOVED***
      ***REMOVED***)
        )
      : [],
***REMOVED***
***REMOVED***

let configFile

if (argv.env) process.env.NODE_ENV = argv.env
if (argv.config) argv.config = path.resolve(argv.config)

if (argv.watch) ***REMOVED***
  process.stdin.on('end', () => process.exit(0))
  process.stdin.resume()
***REMOVED***

/* istanbul ignore next */
if (parseInt(postcss().version) < 8) ***REMOVED***
  error('Please install PostCSS 8 or above')
***REMOVED***

buildCliConfig()
  .then(() => ***REMOVED***
    if (argv.watch && !(argv.output || argv.replace || argv.dir)) ***REMOVED***
      error('Cannot write to stdout in watch mode')
      // Need to explicitly exit here, since error() doesn't exit in watch mode
      process.exit(1)
***REMOVED***

    if (input && input.length) ***REMOVED***
      return globby(
        input.map((i) => slash(String(i))),
        ***REMOVED*** dot: argv.includeDotfiles ***REMOVED***
      )
***REMOVED***

    if (argv.replace || argv.dir) ***REMOVED***
      error(
        'Input Error: Cannot use --dir or --replace when reading from stdin'
      )
***REMOVED***

    if (argv.watch) ***REMOVED***
      error('Input Error: Cannot run in watch mode when reading from stdin')
***REMOVED***

    return ['stdin']
***REMOVED***)
  .then((i) => ***REMOVED***
    if (!i || !i.length) ***REMOVED***
      error('Input Error: You must pass a valid list of files to parse')
***REMOVED***

    if (i.length > 1 && !argv.dir && !argv.replace) ***REMOVED***
      error(
        'Input Error: Must use --dir or --replace with multiple input files'
      )
***REMOVED***

    if (i[0] !== 'stdin') i = i.map((i) => path.resolve(i))

    input = i

    return files(input)
***REMOVED***)
  .then((results) => ***REMOVED***
    if (argv.watch) ***REMOVED***
      const printMessage = () =>
        printVerbose(pc.dim('\nWaiting for file changes...'))
      const watcher = chokidar.watch(input.concat(dependencies(results)), ***REMOVED***
        usePolling: argv.poll,
        interval: argv.poll && typeof argv.poll === 'number' ? argv.poll : 100,
        awaitWriteFinish: ***REMOVED***
          stabilityThreshold: 50,
          pollInterval: 10,
    ***REMOVED***,
  ***REMOVED***)

      if (configFile) watcher.add(configFile)

      watcher.on('ready', printMessage).on('change', (file) => ***REMOVED***
        let recompile = []

        if (input.includes(file)) recompile.push(file)

        const dependants = depGraph
          .dependantsOf(file)
          .concat(getAncestorDirs(file).flatMap(depGraph.dependantsOf))

        recompile = recompile.concat(
          dependants.filter((file) => input.includes(file))
        )

        if (!recompile.length) recompile = input

        return files([...new Set(recompile)])
          .then((results) => watcher.add(dependencies(results)))
          .then(printMessage)
          .catch(error)
  ***REMOVED***)
***REMOVED***
***REMOVED***)
  .catch((err) => ***REMOVED***
    error(err)

    process.exit(1)
***REMOVED***)

function rc(ctx, path) ***REMOVED***
  if (argv.use) return Promise.resolve(cliConfig)

  return postcssrc(ctx, path)
    .then((rc) => ***REMOVED***
      if (rc.options.from || rc.options.to) ***REMOVED***
        error(
          'Config Error: Can not set from or to options in config file, use CLI arguments instead'
        )
  ***REMOVED***
      configFile = rc.file
      return rc
***REMOVED***)
    .catch((err) => ***REMOVED***
      if (!err.message.includes('No PostCSS Config found')) throw err
***REMOVED***)
***REMOVED***

function files(files) ***REMOVED***
  if (typeof files === 'string') files = [files]

  return Promise.all(
    files.map((file) => ***REMOVED***
      if (file === 'stdin') ***REMOVED***
        return stdin().then((content) => ***REMOVED***
          if (!content) return error('Input Error: Did not receive any STDIN')
          return css(content, 'stdin')
    ***REMOVED***)
  ***REMOVED***

      return read(file).then((content) => css(content, file))
***REMOVED***)
  )
***REMOVED***

function css(css, file) ***REMOVED***
  const ctx = ***REMOVED*** options: cliConfig.options ***REMOVED***

  if (file !== 'stdin') ***REMOVED***
    ctx.file = ***REMOVED***
      dirname: path.dirname(file),
      basename: path.basename(file),
      extname: path.extname(file),
***REMOVED***

    if (!argv.config) argv.config = path.dirname(file)
***REMOVED***

  const relativePath =
    file !== 'stdin' ? path.relative(path.resolve(), file) : file

  if (!argv.config) argv.config = process.cwd()

  const time = process.hrtime()

  printVerbose(pc.cyan(`Processing $***REMOVED***pc.bold(relativePath)***REMOVED***...`))

  return rc(ctx, argv.config)
    .then((config) => ***REMOVED***
      config = config || cliConfig
      const options = ***REMOVED*** ...config.options ***REMOVED***

      if (file === 'stdin' && output) file = output

      // TODO: Unit test this
      options.from = file === 'stdin' ? path.join(process.cwd(), 'stdin') : file

      if (output || dir || argv.replace) ***REMOVED***
        const base = argv.base
          ? file.replace(path.resolve(argv.base), '')
          : path.basename(file)
        options.to = output || (argv.replace ? file : path.join(dir, base))

        if (argv.ext) ***REMOVED***
          options.to = options.to.replace(path.extname(options.to), argv.ext)
    ***REMOVED***

        options.to = path.resolve(options.to)
  ***REMOVED***

      if (!options.to && config.options.map && !config.options.map.inline) ***REMOVED***
        error(
          'Output Error: Cannot output external sourcemaps when writing to STDOUT'
        )
  ***REMOVED***

      return postcss(config.plugins)
        .process(css, options)
        .then((result) => ***REMOVED***
          const tasks = []

          if (options.to) ***REMOVED***
            tasks.push(outputFile(options.to, result.css))

            if (result.map) ***REMOVED***
              const mapfile = getMapfile(options)
              tasks.push(outputFile(mapfile, result.map.toString()))
        ***REMOVED***
      ***REMOVED*** else process.stdout.write(result.css, 'utf8')

          return Promise.all(tasks).then(() => ***REMOVED***
            const prettyTime = prettyHrtime(process.hrtime(time))
            printVerbose(
              pc.green(
                `Finished $***REMOVED***pc.bold(relativePath)***REMOVED*** in $***REMOVED***pc.bold(prettyTime)***REMOVED***`
              )
            )

            const messages = result.warnings()
            if (messages.length) ***REMOVED***
              console.warn(reporter(***REMOVED*** ...result, messages ***REMOVED***))
        ***REMOVED***

            return result
      ***REMOVED***)
    ***REMOVED***)
***REMOVED***)
    .catch((err) => ***REMOVED***
      throw err
***REMOVED***)

  async function outputFile(file, string) ***REMOVED***
    const fileExists = await fs.pathExists(file)
    const currentValue = fileExists ? await fs.readFile(file, 'utf8') : null
    if (currentValue === string) return
    return fs.outputFile(file, string)
***REMOVED***
***REMOVED***

function dependencies(results) ***REMOVED***
  if (!Array.isArray(results)) results = [results]

  const messages = []

  results.forEach((result) => ***REMOVED***
    if (result.messages <= 0) return

    result.messages
      .filter((msg) =>
        msg.type === 'dependency' || msg.type === 'dir-dependency' ? msg : ''
      )
      .map(depGraph.add)
      .forEach((dependency) => ***REMOVED***
        if (dependency.type === 'dir-dependency') ***REMOVED***
          messages.push(
            dependency.glob
              ? path.join(dependency.dir, dependency.glob)
              : dependency.dir
          )
    ***REMOVED*** else ***REMOVED***
          messages.push(dependency.file)
    ***REMOVED***
  ***REMOVED***)
***REMOVED***)

  return messages
***REMOVED***

function printVerbose(message) ***REMOVED***
  if (argv.verbose) console.warn(message)
***REMOVED***

function error(err) ***REMOVED***
  // Seperate error from logging output
  if (argv.verbose) console.error()

  if (typeof err === 'string') ***REMOVED***
    console.error(pc.red(err))
***REMOVED*** else if (err.name === 'CssSyntaxError') ***REMOVED***
    console.error(err.toString())
***REMOVED*** else ***REMOVED***
    console.error(err)
***REMOVED***
  // Watch mode shouldn't exit on error
  if (argv.watch) return
  process.exit(1)
***REMOVED***

// Input: '/imports/components/button.css'
// Output: ['/imports/components', '/imports', '/']
function getAncestorDirs(fileOrDir) ***REMOVED***
  const ***REMOVED*** root ***REMOVED*** = path.parse(fileOrDir)
  if (fileOrDir === root) ***REMOVED***
    return []
***REMOVED***
  const parentDir = path.dirname(fileOrDir)
  return [parentDir, ...getAncestorDirs(parentDir)]
***REMOVED***
