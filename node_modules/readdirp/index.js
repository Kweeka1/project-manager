'use strict';

const fs = require('fs');
const ***REMOVED*** Readable ***REMOVED*** = require('stream');
const sysPath = require('path');
const ***REMOVED*** promisify ***REMOVED*** = require('util');
const picomatch = require('picomatch');

const readdir = promisify(fs.readdir);
const stat = promisify(fs.stat);
const lstat = promisify(fs.lstat);
const realpath = promisify(fs.realpath);

/**
 * @typedef ***REMOVED***Object***REMOVED*** EntryInfo
 * @property ***REMOVED***String***REMOVED*** path
 * @property ***REMOVED***String***REMOVED*** fullPath
 * @property ***REMOVED***fs.Stats=***REMOVED*** stats
 * @property ***REMOVED***fs.Dirent=***REMOVED*** dirent
 * @property ***REMOVED***String***REMOVED*** basename
 */

const BANG = '!';
const RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';
const NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);
const FILE_TYPE = 'files';
const DIR_TYPE = 'directories';
const FILE_DIR_TYPE = 'files_directories';
const EVERYTHING_TYPE = 'all';
const ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];

const isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);
const [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));
const wantBigintFsStats = process.platform === 'win32' && (maj > 10 || (maj === 10 && min >= 5));

const normalizeFilter = filter => ***REMOVED***
  if (filter === undefined) return;
  if (typeof filter === 'function') return filter;

  if (typeof filter === 'string') ***REMOVED***
    const glob = picomatch(filter.trim());
    return entry => glob(entry.basename);
***REMOVED***

  if (Array.isArray(filter)) ***REMOVED***
    const positive = [];
    const negative = [];
    for (const item of filter) ***REMOVED***
      const trimmed = item.trim();
      if (trimmed.charAt(0) === BANG) ***REMOVED***
        negative.push(picomatch(trimmed.slice(1)));
  ***REMOVED*** else ***REMOVED***
        positive.push(picomatch(trimmed));
  ***REMOVED***
***REMOVED***

    if (negative.length > 0) ***REMOVED***
      if (positive.length > 0) ***REMOVED***
        return entry =>
          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));
  ***REMOVED***
      return entry => !negative.some(f => f(entry.basename));
***REMOVED***
    return entry => positive.some(f => f(entry.basename));
***REMOVED***
***REMOVED***;

class ReaddirpStream extends Readable ***REMOVED***
  static get defaultOptions() ***REMOVED***
    return ***REMOVED***
      root: '.',
      /* eslint-disable no-unused-vars */
      fileFilter: (path) => true,
      directoryFilter: (path) => true,
      /* eslint-enable no-unused-vars */
      type: FILE_TYPE,
      lstat: false,
      depth: 2147483648,
      alwaysStat: false
***REMOVED***;
***REMOVED***

  constructor(options = ***REMOVED******REMOVED***) ***REMOVED***
    super(***REMOVED***
      objectMode: true,
      autoDestroy: true,
      highWaterMark: options.highWaterMark || 4096
***REMOVED***);
    const opts = ***REMOVED*** ...ReaddirpStream.defaultOptions, ...options ***REMOVED***;
    const ***REMOVED*** root, type ***REMOVED*** = opts;

    this._fileFilter = normalizeFilter(opts.fileFilter);
    this._directoryFilter = normalizeFilter(opts.directoryFilter);

    const statMethod = opts.lstat ? lstat : stat;
    // Use bigint stats if it's windows and stat() supports options (node 10+).
    if (wantBigintFsStats) ***REMOVED***
      this._stat = path => statMethod(path, ***REMOVED*** bigint: true ***REMOVED***);
***REMOVED*** else ***REMOVED***
      this._stat = statMethod;
***REMOVED***

    this._maxDepth = opts.depth;
    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
    this._wantsEverything = type === EVERYTHING_TYPE;
    this._root = sysPath.resolve(root);
    this._isDirent = ('Dirent' in fs) && !opts.alwaysStat;
    this._statsProp = this._isDirent ? 'dirent' : 'stats';
    this._rdOptions = ***REMOVED*** encoding: 'utf8', withFileTypes: this._isDirent ***REMOVED***;

    // Launch stream with one parent, the root dir.
    this.parents = [this._exploreDir(root, 1)];
    this.reading = false;
    this.parent = undefined;
***REMOVED***

  async _read(batch) ***REMOVED***
    if (this.reading) return;
    this.reading = true;

    try ***REMOVED***
      while (!this.destroyed && batch > 0) ***REMOVED***
        const ***REMOVED*** path, depth, files = [] ***REMOVED*** = this.parent || ***REMOVED******REMOVED***;

        if (files.length > 0) ***REMOVED***
          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));
          for (const entry of await Promise.all(slice)) ***REMOVED***
            if (this.destroyed) return;

            const entryType = await this._getEntryType(entry);
            if (entryType === 'directory' && this._directoryFilter(entry)) ***REMOVED***
              if (depth <= this._maxDepth) ***REMOVED***
                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));
          ***REMOVED***

              if (this._wantsDir) ***REMOVED***
                this.push(entry);
                batch--;
          ***REMOVED***
        ***REMOVED*** else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) ***REMOVED***
              if (this._wantsFile) ***REMOVED***
                this.push(entry);
                batch--;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
          const parent = this.parents.pop();
          if (!parent) ***REMOVED***
            this.push(null);
            break;
      ***REMOVED***
          this.parent = await parent;
          if (this.destroyed) return;
    ***REMOVED***
  ***REMOVED***
***REMOVED*** catch (error) ***REMOVED***
      this.destroy(error);
***REMOVED*** finally ***REMOVED***
      this.reading = false;
***REMOVED***
***REMOVED***

  async _exploreDir(path, depth) ***REMOVED***
    let files;
    try ***REMOVED***
      files = await readdir(path, this._rdOptions);
***REMOVED*** catch (error) ***REMOVED***
      this._onError(error);
***REMOVED***
    return ***REMOVED*** files, depth, path ***REMOVED***;
***REMOVED***

  async _formatEntry(dirent, path) ***REMOVED***
    let entry;
    try ***REMOVED***
      const basename = this._isDirent ? dirent.name : dirent;
      const fullPath = sysPath.resolve(sysPath.join(path, basename));
      entry = ***REMOVED*** path: sysPath.relative(this._root, fullPath), fullPath, basename ***REMOVED***;
      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
***REMOVED*** catch (err) ***REMOVED***
      this._onError(err);
***REMOVED***
    return entry;
***REMOVED***

  _onError(err) ***REMOVED***
    if (isNormalFlowError(err) && !this.destroyed) ***REMOVED***
      this.emit('warn', err);
***REMOVED*** else ***REMOVED***
      this.destroy(err);
***REMOVED***
***REMOVED***

  async _getEntryType(entry) ***REMOVED***
    // entry may be undefined, because a warning or an error were emitted
    // and the statsProp is undefined
    const stats = entry && entry[this._statsProp];
    if (!stats) ***REMOVED***
      return;
***REMOVED***
    if (stats.isFile()) ***REMOVED***
      return 'file';
***REMOVED***
    if (stats.isDirectory()) ***REMOVED***
      return 'directory';
***REMOVED***
    if (stats && stats.isSymbolicLink()) ***REMOVED***
      const full = entry.fullPath;
      try ***REMOVED***
        const entryRealPath = await realpath(full);
        const entryRealPathStats = await lstat(entryRealPath);
        if (entryRealPathStats.isFile()) ***REMOVED***
          return 'file';
    ***REMOVED***
        if (entryRealPathStats.isDirectory()) ***REMOVED***
          const len = entryRealPath.length;
          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) ***REMOVED***
            const recursiveError = new Error(
              `Circular symlink detected: "$***REMOVED***full***REMOVED***" points to "$***REMOVED***entryRealPath***REMOVED***"`
            );
            recursiveError.code = RECURSIVE_ERROR_CODE;
            return this._onError(recursiveError);
      ***REMOVED***
          return 'directory';
    ***REMOVED***
  ***REMOVED*** catch (error) ***REMOVED***
        this._onError(error);
  ***REMOVED***
***REMOVED***
***REMOVED***

  _includeAsFile(entry) ***REMOVED***
    const stats = entry && entry[this._statsProp];

    return stats && this._wantsEverything && !stats.isDirectory();
***REMOVED***
***REMOVED***

/**
 * @typedef ***REMOVED***Object***REMOVED*** ReaddirpArguments
 * @property ***REMOVED***Function=***REMOVED*** fileFilter
 * @property ***REMOVED***Function=***REMOVED*** directoryFilter
 * @property ***REMOVED***String=***REMOVED*** type
 * @property ***REMOVED***Number=***REMOVED*** depth
 * @property ***REMOVED***String=***REMOVED*** root
 * @property ***REMOVED***Boolean=***REMOVED*** lstat
 * @property ***REMOVED***Boolean=***REMOVED*** bigint
 */

/**
 * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.
 * @param ***REMOVED***String***REMOVED*** root Root directory
 * @param ***REMOVED***ReaddirpArguments=***REMOVED*** options Options to specify root (start directory), filters and recursion depth
 */
const readdirp = (root, options = ***REMOVED******REMOVED***) => ***REMOVED***
  let type = options.entryType || options.type;
  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility
  if (type) options.type = type;
  if (!root) ***REMOVED***
    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');
***REMOVED*** else if (typeof root !== 'string') ***REMOVED***
    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');
***REMOVED*** else if (type && !ALL_TYPES.includes(type)) ***REMOVED***
    throw new Error(`readdirp: Invalid type passed. Use one of $***REMOVED***ALL_TYPES.join(', ')***REMOVED***`);
***REMOVED***

  options.root = root;
  return new ReaddirpStream(options);
***REMOVED***;

const readdirpPromise = (root, options = ***REMOVED******REMOVED***) => ***REMOVED***
  return new Promise((resolve, reject) => ***REMOVED***
    const files = [];
    readdirp(root, options)
      .on('data', entry => files.push(entry))
      .on('end', () => resolve(files))
      .on('error', error => reject(error));
***REMOVED***);
***REMOVED***;

readdirp.promise = readdirpPromise;
readdirp.ReaddirpStream = ReaddirpStream;
readdirp.default = readdirp;

module.exports = readdirp;
