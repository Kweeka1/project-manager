'use strict';

var PlainValue = require('./PlainValue-ec8e588e.js');

function addCommentBefore(str, indent, comment) ***REMOVED***
  if (!comment) return str;
  const cc = comment.replace(/[\s\S]^/gm, `$&$***REMOVED***indent***REMOVED***#`);
  return `#$***REMOVED***cc***REMOVED***\n$***REMOVED***indent***REMOVED***$***REMOVED***str***REMOVED***`;
***REMOVED***
function addComment(str, indent, comment) ***REMOVED***
  return !comment ? str : comment.indexOf('\n') === -1 ? `$***REMOVED***str***REMOVED*** #$***REMOVED***comment***REMOVED***` : `$***REMOVED***str***REMOVED***\n` + comment.replace(/^/gm, `$***REMOVED***indent || ''***REMOVED***#`);
***REMOVED***

class Node ***REMOVED******REMOVED***

function toJSON(value, arg, ctx) ***REMOVED***
  if (Array.isArray(value)) return value.map((v, i) => toJSON(v, String(i), ctx));

  if (value && typeof value.toJSON === 'function') ***REMOVED***
    const anchor = ctx && ctx.anchors && ctx.anchors.get(value);
    if (anchor) ctx.onCreate = res => ***REMOVED***
      anchor.res = res;
      delete ctx.onCreate;
***REMOVED***;
    const res = value.toJSON(arg, ctx);
    if (anchor && ctx.onCreate) ctx.onCreate(res);
    return res;
***REMOVED***

  if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value);
  return value;
***REMOVED***

class Scalar extends Node ***REMOVED***
  constructor(value) ***REMOVED***
    super();
    this.value = value;
***REMOVED***

  toJSON(arg, ctx) ***REMOVED***
    return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);
***REMOVED***

  toString() ***REMOVED***
    return String(this.value);
***REMOVED***

***REMOVED***

function collectionFromPath(schema, path, value) ***REMOVED***
  let v = value;

  for (let i = path.length - 1; i >= 0; --i) ***REMOVED***
    const k = path[i];

    if (Number.isInteger(k) && k >= 0) ***REMOVED***
      const a = [];
      a[k] = v;
      v = a;
***REMOVED*** else ***REMOVED***
      const o = ***REMOVED******REMOVED***;
      Object.defineProperty(o, k, ***REMOVED***
        value: v,
        writable: true,
        enumerable: true,
        configurable: true
  ***REMOVED***);
      v = o;
***REMOVED***
***REMOVED***

  return schema.createNode(v, false);
***REMOVED*** // null, undefined, or an empty non-string iterable (e.g. [])


const isEmptyPath = path => path == null || typeof path === 'object' && path[Symbol.iterator]().next().done;
class Collection extends Node ***REMOVED***
  constructor(schema) ***REMOVED***
    super();

    PlainValue._defineProperty(this, "items", []);

    this.schema = schema;
***REMOVED***

  addIn(path, value) ***REMOVED***
    if (isEmptyPath(path)) this.add(value);else ***REMOVED***
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (node instanceof Collection) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at $***REMOVED***key***REMOVED***. Remaining path: $***REMOVED***rest***REMOVED***`);
***REMOVED***
***REMOVED***

  deleteIn([key, ...rest]) ***REMOVED***
    if (rest.length === 0) return this.delete(key);
    const node = this.get(key, true);
    if (node instanceof Collection) return node.deleteIn(rest);else throw new Error(`Expected YAML collection at $***REMOVED***key***REMOVED***. Remaining path: $***REMOVED***rest***REMOVED***`);
***REMOVED***

  getIn([key, ...rest], keepScalar) ***REMOVED***
    const node = this.get(key, true);
    if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;else return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;
***REMOVED***

  hasAllNullValues() ***REMOVED***
    return this.items.every(node => ***REMOVED***
      if (!node || node.type !== 'PAIR') return false;
      const n = node.value;
      return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;
***REMOVED***);
***REMOVED***

  hasIn([key, ...rest]) ***REMOVED***
    if (rest.length === 0) return this.has(key);
    const node = this.get(key, true);
    return node instanceof Collection ? node.hasIn(rest) : false;
***REMOVED***

  setIn([key, ...rest], value) ***REMOVED***
    if (rest.length === 0) ***REMOVED***
      this.set(key, value);
***REMOVED*** else ***REMOVED***
      const node = this.get(key, true);
      if (node instanceof Collection) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at $***REMOVED***key***REMOVED***. Remaining path: $***REMOVED***rest***REMOVED***`);
***REMOVED***
***REMOVED*** // overridden in implementations

  /* istanbul ignore next */


  toJSON() ***REMOVED***
    return null;
***REMOVED***

  toString(ctx, ***REMOVED***
    blockItem,
    flowChars,
    isMap,
    itemIndent
***REMOVED*** onComment, onChompKeep) ***REMOVED***
    const ***REMOVED***
      indent,
      indentStep,
      stringify
***REMOVED*** = ctx;
    const inFlow = this.type === PlainValue.Type.FLOW_MAP || this.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow;
    if (inFlow) itemIndent += indentStep;
    const allNullValues = isMap && this.hasAllNullValues();
    ctx = Object.assign(***REMOVED******REMOVED***, ctx, ***REMOVED***
      allNullValues,
      indent: itemIndent,
      inFlow,
      type: null
***REMOVED***);
    let chompKeep = false;
    let hasItemWithNewLine = false;
    const nodes = this.items.reduce((nodes, item, i) => ***REMOVED***
      let comment;

      if (item) ***REMOVED***
        if (!chompKeep && item.spaceBefore) nodes.push(***REMOVED***
          type: 'comment',
          str: ''
    ***REMOVED***);
        if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(line => ***REMOVED***
          nodes.push(***REMOVED***
            type: 'comment',
            str: `#$***REMOVED***line***REMOVED***`
      ***REMOVED***);
    ***REMOVED***);
        if (item.comment) comment = item.comment;
        if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;
  ***REMOVED***

      chompKeep = false;
      let str = stringify(item, ctx, () => comment = null, () => chompKeep = true);
      if (inFlow && !hasItemWithNewLine && str.includes('\n')) hasItemWithNewLine = true;
      if (inFlow && i < this.items.length - 1) str += ',';
      str = addComment(str, itemIndent, comment);
      if (chompKeep && (comment || inFlow)) chompKeep = false;
      nodes.push(***REMOVED***
        type: 'item',
        str
  ***REMOVED***);
      return nodes;
***REMOVED***, []);
    let str;

    if (nodes.length === 0) ***REMOVED***
      str = flowChars.start + flowChars.end;
***REMOVED*** else if (inFlow) ***REMOVED***
      const ***REMOVED***
        start,
        end
  ***REMOVED*** = flowChars;
      const strings = nodes.map(n => n.str);

      if (hasItemWithNewLine || strings.reduce((sum, str) => sum + str.length + 2, 2) > Collection.maxFlowStringSingleLineLength) ***REMOVED***
        str = start;

        for (const s of strings) ***REMOVED***
          str += s ? `\n$***REMOVED***indentStep***REMOVED***$***REMOVED***indent***REMOVED***$***REMOVED***s***REMOVED***` : '\n';
    ***REMOVED***

        str += `\n$***REMOVED***indent***REMOVED***$***REMOVED***end***REMOVED***`;
  ***REMOVED*** else ***REMOVED***
        str = `$***REMOVED***start***REMOVED*** $***REMOVED***strings.join(' ')***REMOVED*** $***REMOVED***end***REMOVED***`;
  ***REMOVED***
***REMOVED*** else ***REMOVED***
      const strings = nodes.map(blockItem);
      str = strings.shift();

      for (const s of strings) str += s ? `\n$***REMOVED***indent***REMOVED***$***REMOVED***s***REMOVED***` : '\n';
***REMOVED***

    if (this.comment) ***REMOVED***
      str += '\n' + this.comment.replace(/^/gm, `$***REMOVED***indent***REMOVED***#`);
      if (onComment) onComment();
***REMOVED*** else if (chompKeep && onChompKeep) onChompKeep();

    return str;
***REMOVED***

***REMOVED***

PlainValue._defineProperty(Collection, "maxFlowStringSingleLineLength", 60);

function asItemIndex(key) ***REMOVED***
  let idx = key instanceof Scalar ? key.value : key;
  if (idx && typeof idx === 'string') idx = Number(idx);
  return Number.isInteger(idx) && idx >= 0 ? idx : null;
***REMOVED***

class YAMLSeq extends Collection ***REMOVED***
  add(value) ***REMOVED***
    this.items.push(value);
***REMOVED***

  delete(key) ***REMOVED***
    const idx = asItemIndex(key);
    if (typeof idx !== 'number') return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
***REMOVED***

  get(key, keepScalar) ***REMOVED***
    const idx = asItemIndex(key);
    if (typeof idx !== 'number') return undefined;
    const it = this.items[idx];
    return !keepScalar && it instanceof Scalar ? it.value : it;
***REMOVED***

  has(key) ***REMOVED***
    const idx = asItemIndex(key);
    return typeof idx === 'number' && idx < this.items.length;
***REMOVED***

  set(key, value) ***REMOVED***
    const idx = asItemIndex(key);
    if (typeof idx !== 'number') throw new Error(`Expected a valid index, not $***REMOVED***key***REMOVED***.`);
    this.items[idx] = value;
***REMOVED***

  toJSON(_, ctx) ***REMOVED***
    const seq = [];
    if (ctx && ctx.onCreate) ctx.onCreate(seq);
    let i = 0;

    for (const item of this.items) seq.push(toJSON(item, String(i++), ctx));

    return seq;
***REMOVED***

  toString(ctx, onComment, onChompKeep) ***REMOVED***
    if (!ctx) return JSON.stringify(this);
    return super.toString(ctx, ***REMOVED***
      blockItem: n => n.type === 'comment' ? n.str : `- $***REMOVED***n.str***REMOVED***`,
      flowChars: ***REMOVED***
        start: '[',
        end: ']'
  ***REMOVED***,
      isMap: false,
      itemIndent: (ctx.indent || '') + '  '
***REMOVED***, onComment, onChompKeep);
***REMOVED***

***REMOVED***

const stringifyKey = (key, jsKey, ctx) => ***REMOVED***
  if (jsKey === null) return '';
  if (typeof jsKey !== 'object') return String(jsKey);
  if (key instanceof Node && ctx && ctx.doc) return key.toString(***REMOVED***
    anchors: Object.create(null),
    doc: ctx.doc,
    indent: '',
    indentStep: ctx.indentStep,
    inFlow: true,
    inStringifyKey: true,
    stringify: ctx.stringify
***REMOVED***);
  return JSON.stringify(jsKey);
***REMOVED***;

class Pair extends Node ***REMOVED***
  constructor(key, value = null) ***REMOVED***
    super();
    this.key = key;
    this.value = value;
    this.type = Pair.Type.PAIR;
***REMOVED***

  get commentBefore() ***REMOVED***
    return this.key instanceof Node ? this.key.commentBefore : undefined;
***REMOVED***

  set commentBefore(cb) ***REMOVED***
    if (this.key == null) this.key = new Scalar(null);
    if (this.key instanceof Node) this.key.commentBefore = cb;else ***REMOVED***
      const msg = 'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.';
      throw new Error(msg);
***REMOVED***
***REMOVED***

  addToJSMap(ctx, map) ***REMOVED***
    const key = toJSON(this.key, '', ctx);

    if (map instanceof Map) ***REMOVED***
      const value = toJSON(this.value, key, ctx);
      map.set(key, value);
***REMOVED*** else if (map instanceof Set) ***REMOVED***
      map.add(key);
***REMOVED*** else ***REMOVED***
      const stringKey = stringifyKey(this.key, key, ctx);
      const value = toJSON(this.value, stringKey, ctx);
      if (stringKey in map) Object.defineProperty(map, stringKey, ***REMOVED***
        value,
        writable: true,
        enumerable: true,
        configurable: true
  ***REMOVED***);else map[stringKey] = value;
***REMOVED***

    return map;
***REMOVED***

  toJSON(_, ctx) ***REMOVED***
    const pair = ctx && ctx.mapAsMap ? new Map() : ***REMOVED******REMOVED***;
    return this.addToJSMap(ctx, pair);
***REMOVED***

  toString(ctx, onComment, onChompKeep) ***REMOVED***
    if (!ctx || !ctx.doc) return JSON.stringify(this);
    const ***REMOVED***
      indent: indentSize,
      indentSeq,
      simpleKeys
***REMOVED*** = ctx.doc.options;
    let ***REMOVED***
      key,
      value
***REMOVED*** = this;
    let keyComment = key instanceof Node && key.comment;

    if (simpleKeys) ***REMOVED***
      if (keyComment) ***REMOVED***
        throw new Error('With simple keys, key nodes cannot have comments');
  ***REMOVED***

      if (key instanceof Collection) ***REMOVED***
        const msg = 'With simple keys, collection cannot be used as a key value';
        throw new Error(msg);
  ***REMOVED***
***REMOVED***

    let explicitKey = !simpleKeys && (!key || keyComment || (key instanceof Node ? key instanceof Collection || key.type === PlainValue.Type.BLOCK_FOLDED || key.type === PlainValue.Type.BLOCK_LITERAL : typeof key === 'object'));
    const ***REMOVED***
      doc,
      indent,
      indentStep,
      stringify
***REMOVED*** = ctx;
    ctx = Object.assign(***REMOVED******REMOVED***, ctx, ***REMOVED***
      implicitKey: !explicitKey,
      indent: indent + indentStep
***REMOVED***);
    let chompKeep = false;
    let str = stringify(key, ctx, () => keyComment = null, () => chompKeep = true);
    str = addComment(str, ctx.indent, keyComment);

    if (!explicitKey && str.length > 1024) ***REMOVED***
      if (simpleKeys) throw new Error('With simple keys, single line scalar must not span more than 1024 characters');
      explicitKey = true;
***REMOVED***

    if (ctx.allNullValues && !simpleKeys) ***REMOVED***
      if (this.comment) ***REMOVED***
        str = addComment(str, ctx.indent, this.comment);
        if (onComment) onComment();
  ***REMOVED*** else if (chompKeep && !keyComment && onChompKeep) onChompKeep();

      return ctx.inFlow && !explicitKey ? str : `? $***REMOVED***str***REMOVED***`;
***REMOVED***

    str = explicitKey ? `? $***REMOVED***str***REMOVED***\n$***REMOVED***indent***REMOVED***:` : `$***REMOVED***str***REMOVED***:`;

    if (this.comment) ***REMOVED***
      // expected (but not strictly required) to be a single-line comment
      str = addComment(str, ctx.indent, this.comment);
      if (onComment) onComment();
***REMOVED***

    let vcb = '';
    let valueComment = null;

    if (value instanceof Node) ***REMOVED***
      if (value.spaceBefore) vcb = '\n';

      if (value.commentBefore) ***REMOVED***
        const cs = value.commentBefore.replace(/^/gm, `$***REMOVED***ctx.indent***REMOVED***#`);
        vcb += `\n$***REMOVED***cs***REMOVED***`;
  ***REMOVED***

      valueComment = value.comment;
***REMOVED*** else if (value && typeof value === 'object') ***REMOVED***
      value = doc.schema.createNode(value, true);
***REMOVED***

    ctx.implicitKey = false;
    if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;
    chompKeep = false;

    if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== PlainValue.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) ***REMOVED***
      // If indentSeq === false, consider '- ' as part of indentation where possible
      ctx.indent = ctx.indent.substr(2);
***REMOVED***

    const valueStr = stringify(value, ctx, () => valueComment = null, () => chompKeep = true);
    let ws = ' ';

    if (vcb || this.comment) ***REMOVED***
      ws = `$***REMOVED***vcb***REMOVED***\n$***REMOVED***ctx.indent***REMOVED***`;
***REMOVED*** else if (!explicitKey && value instanceof Collection) ***REMOVED***
      const flow = valueStr[0] === '[' || valueStr[0] === '***REMOVED***';
      if (!flow || valueStr.includes('\n')) ws = `\n$***REMOVED***ctx.indent***REMOVED***`;
***REMOVED*** else if (valueStr[0] === '\n') ws = '';

    if (chompKeep && !valueComment && onChompKeep) onChompKeep();
    return addComment(str + ws + valueStr, ctx.indent, valueComment);
***REMOVED***

***REMOVED***

PlainValue._defineProperty(Pair, "Type", ***REMOVED***
  PAIR: 'PAIR',
  MERGE_PAIR: 'MERGE_PAIR'
***REMOVED***);

const getAliasCount = (node, anchors) => ***REMOVED***
  if (node instanceof Alias) ***REMOVED***
    const anchor = anchors.get(node.source);
    return anchor.count * anchor.aliasCount;
***REMOVED*** else if (node instanceof Collection) ***REMOVED***
    let count = 0;

    for (const item of node.items) ***REMOVED***
      const c = getAliasCount(item, anchors);
      if (c > count) count = c;
***REMOVED***

    return count;
***REMOVED*** else if (node instanceof Pair) ***REMOVED***
    const kc = getAliasCount(node.key, anchors);
    const vc = getAliasCount(node.value, anchors);
    return Math.max(kc, vc);
***REMOVED***

  return 1;
***REMOVED***;

class Alias extends Node ***REMOVED***
  static stringify(***REMOVED***
    range,
    source
***REMOVED*** ***REMOVED***
    anchors,
    doc,
    implicitKey,
    inStringifyKey
***REMOVED***) ***REMOVED***
    let anchor = Object.keys(anchors).find(a => anchors[a] === source);
    if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();
    if (anchor) return `*$***REMOVED***anchor***REMOVED***$***REMOVED***implicitKey ? ' ' : ''***REMOVED***`;
    const msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';
    throw new Error(`$***REMOVED***msg***REMOVED*** [$***REMOVED***range***REMOVED***]`);
***REMOVED***

  constructor(source) ***REMOVED***
    super();
    this.source = source;
    this.type = PlainValue.Type.ALIAS;
***REMOVED***

  set tag(t) ***REMOVED***
    throw new Error('Alias nodes cannot have tags');
***REMOVED***

  toJSON(arg, ctx) ***REMOVED***
    if (!ctx) return toJSON(this.source, arg, ctx);
    const ***REMOVED***
      anchors,
      maxAliasCount
***REMOVED*** = ctx;
    const anchor = anchors.get(this.source);
    /* istanbul ignore if */

    if (!anchor || anchor.res === undefined) ***REMOVED***
      const msg = 'This should not happen: Alias anchor was not resolved?';
      if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);
***REMOVED***

    if (maxAliasCount >= 0) ***REMOVED***
      anchor.count += 1;
      if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);

      if (anchor.count * anchor.aliasCount > maxAliasCount) ***REMOVED***
        const msg = 'Excessive alias count indicates a resource exhaustion attack';
        if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);
  ***REMOVED***
***REMOVED***

    return anchor.res;
***REMOVED*** // Only called when stringifying an alias mapping key while constructing
  // Object output.


  toString(ctx) ***REMOVED***
    return Alias.stringify(this, ctx);
***REMOVED***

***REMOVED***

PlainValue._defineProperty(Alias, "default", true);

function findPair(items, key) ***REMOVED***
  const k = key instanceof Scalar ? key.value : key;

  for (const it of items) ***REMOVED***
    if (it instanceof Pair) ***REMOVED***
      if (it.key === key || it.key === k) return it;
      if (it.key && it.key.value === k) return it;
***REMOVED***
***REMOVED***

  return undefined;
***REMOVED***
class YAMLMap extends Collection ***REMOVED***
  add(pair, overwrite) ***REMOVED***
    if (!pair) pair = new Pair(pair);else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);
    const prev = findPair(this.items, pair.key);
    const sortEntries = this.schema && this.schema.sortMapEntries;

    if (prev) ***REMOVED***
      if (overwrite) prev.value = pair.value;else throw new Error(`Key $***REMOVED***pair.key***REMOVED*** already set`);
***REMOVED*** else if (sortEntries) ***REMOVED***
      const i = this.items.findIndex(item => sortEntries(pair, item) < 0);
      if (i === -1) this.items.push(pair);else this.items.splice(i, 0, pair);
***REMOVED*** else ***REMOVED***
      this.items.push(pair);
***REMOVED***
***REMOVED***

  delete(key) ***REMOVED***
    const it = findPair(this.items, key);
    if (!it) return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
***REMOVED***

  get(key, keepScalar) ***REMOVED***
    const it = findPair(this.items, key);
    const node = it && it.value;
    return !keepScalar && node instanceof Scalar ? node.value : node;
***REMOVED***

  has(key) ***REMOVED***
    return !!findPair(this.items, key);
***REMOVED***

  set(key, value) ***REMOVED***
    this.add(new Pair(key, value), true);
***REMOVED***
  /**
   * @param ***REMOVED*******REMOVED*** arg ignored
   * @param ***REMOVED*******REMOVED*** ctx Conversion context, originally set in Document#toJSON()
   * @param ***REMOVED***Class***REMOVED*** Type If set, forces the returned collection type
   * @returns ***REMOVED*******REMOVED*** Instance of Type, Map, or Object
   */


  toJSON(_, ctx, Type) ***REMOVED***
    const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : ***REMOVED******REMOVED***;
    if (ctx && ctx.onCreate) ctx.onCreate(map);

    for (const item of this.items) item.addToJSMap(ctx, map);

    return map;
***REMOVED***

  toString(ctx, onComment, onChompKeep) ***REMOVED***
    if (!ctx) return JSON.stringify(this);

    for (const item of this.items) ***REMOVED***
      if (!(item instanceof Pair)) throw new Error(`Map items must all be pairs; found $***REMOVED***JSON.stringify(item)***REMOVED*** instead`);
***REMOVED***

    return super.toString(ctx, ***REMOVED***
      blockItem: n => n.str,
      flowChars: ***REMOVED***
        start: '***REMOVED***',
        end: '***REMOVED***'
  ***REMOVED***,
      isMap: true,
      itemIndent: ctx.indent || ''
***REMOVED***, onComment, onChompKeep);
***REMOVED***

***REMOVED***

const MERGE_KEY = '<<';
class Merge extends Pair ***REMOVED***
  constructor(pair) ***REMOVED***
    if (pair instanceof Pair) ***REMOVED***
      let seq = pair.value;

      if (!(seq instanceof YAMLSeq)) ***REMOVED***
        seq = new YAMLSeq();
        seq.items.push(pair.value);
        seq.range = pair.value.range;
  ***REMOVED***

      super(pair.key, seq);
      this.range = pair.range;
***REMOVED*** else ***REMOVED***
      super(new Scalar(MERGE_KEY), new YAMLSeq());
***REMOVED***

    this.type = Pair.Type.MERGE_PAIR;
***REMOVED*** // If the value associated with a merge key is a single mapping node, each of
  // its key/value pairs is inserted into the current mapping, unless the key
  // already exists in it. If the value associated with the merge key is a
  // sequence, then this sequence is expected to contain mapping nodes and each
  // of these nodes is merged in turn according to its order in the sequence.
  // Keys in mapping nodes earlier in the sequence override keys specified in
  // later mapping nodes. -- http://yaml.org/type/merge.html


  addToJSMap(ctx, map) ***REMOVED***
    for (const ***REMOVED***
      source
***REMOVED*** of this.value.items) ***REMOVED***
      if (!(source instanceof YAMLMap)) throw new Error('Merge sources must be maps');
      const srcMap = source.toJSON(null, ctx, Map);

      for (const [key, value] of srcMap) ***REMOVED***
        if (map instanceof Map) ***REMOVED***
          if (!map.has(key)) map.set(key, value);
    ***REMOVED*** else if (map instanceof Set) ***REMOVED***
          map.add(key);
    ***REMOVED*** else if (!Object.prototype.hasOwnProperty.call(map, key)) ***REMOVED***
          Object.defineProperty(map, key, ***REMOVED***
            value,
            writable: true,
            enumerable: true,
            configurable: true
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

    return map;
***REMOVED***

  toString(ctx, onComment) ***REMOVED***
    const seq = this.value;
    if (seq.items.length > 1) return super.toString(ctx, onComment);
    this.value = seq.items[0];
    const str = super.toString(ctx, onComment);
    this.value = seq;
    return str;
***REMOVED***

***REMOVED***

const binaryOptions = ***REMOVED***
  defaultType: PlainValue.Type.BLOCK_LITERAL,
  lineWidth: 76
***REMOVED***;
const boolOptions = ***REMOVED***
  trueStr: 'true',
  falseStr: 'false'
***REMOVED***;
const intOptions = ***REMOVED***
  asBigInt: false
***REMOVED***;
const nullOptions = ***REMOVED***
  nullStr: 'null'
***REMOVED***;
const strOptions = ***REMOVED***
  defaultType: PlainValue.Type.PLAIN,
  doubleQuoted: ***REMOVED***
    jsonEncoding: false,
    minMultiLineLength: 40
***REMOVED***
  fold: ***REMOVED***
    lineWidth: 80,
    minContentWidth: 20
***REMOVED***
***REMOVED***;

function resolveScalar(str, tags, scalarFallback) ***REMOVED***
  for (const ***REMOVED***
    format,
    test,
    resolve
***REMOVED*** of tags) ***REMOVED***
    if (test) ***REMOVED***
      const match = str.match(test);

      if (match) ***REMOVED***
        let res = resolve.apply(null, match);
        if (!(res instanceof Scalar)) res = new Scalar(res);
        if (format) res.format = format;
        return res;
  ***REMOVED***
***REMOVED***
***REMOVED***

  if (scalarFallback) str = scalarFallback(str);
  return new Scalar(str);
***REMOVED***

const FOLD_FLOW = 'flow';
const FOLD_BLOCK = 'block';
const FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line
// returns index of last newline in more-indented block

const consumeMoreIndentedLines = (text, i) => ***REMOVED***
  let ch = text[i + 1];

  while (ch === ' ' || ch === '\t') ***REMOVED***
    do ***REMOVED***
      ch = text[i += 1];
***REMOVED*** while (ch && ch !== '\n');

    ch = text[i + 1];
***REMOVED***

  return i;
***REMOVED***;
/**
 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
 * terminated with `\n` and started with `indent`.
 *
 * @param ***REMOVED***string***REMOVED*** text
 * @param ***REMOVED***string***REMOVED*** indent
 * @param ***REMOVED***string***REMOVED*** [mode='flow'] `'block'` prevents more-indented lines
 *   from being folded; `'quoted'` allows for `\` escapes, including escaped
 *   newlines
 * @param ***REMOVED***Object***REMOVED*** options
 * @param ***REMOVED***number***REMOVED*** [options.indentAtStart] Accounts for leading contents on
 *   the first line, defaulting to `indent.length`
 * @param ***REMOVED***number***REMOVED*** [options.lineWidth=80]
 * @param ***REMOVED***number***REMOVED*** [options.minContentWidth=20] Allow highly indented lines to
 *   stretch the line width or indent content from the start
 * @param ***REMOVED***function***REMOVED*** options.onFold Called once if the text is folded
 * @param ***REMOVED***function***REMOVED*** options.onFold Called once if any line of text exceeds
 *   lineWidth characters
 */


function foldFlowLines(text, indent, mode, ***REMOVED***
  indentAtStart,
  lineWidth = 80,
  minContentWidth = 20,
  onFold,
  onOverflow
***REMOVED***) ***REMOVED***
  if (!lineWidth || lineWidth < 0) return text;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep) return text;
  const folds = [];
  const escapedFolds = ***REMOVED******REMOVED***;
  let end = lineWidth - indent.length;

  if (typeof indentAtStart === 'number') ***REMOVED***
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);else end = lineWidth - indentAtStart;
***REMOVED***

  let split = undefined;
  let prev = undefined;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;

  if (mode === FOLD_BLOCK) ***REMOVED***
    i = consumeMoreIndentedLines(text, i);
    if (i !== -1) end = i + endStep;
***REMOVED***

  for (let ch; ch = text[i += 1];) ***REMOVED***
    if (mode === FOLD_QUOTED && ch === '\\') ***REMOVED***
      escStart = i;

      switch (text[i + 1]) ***REMOVED***
        case 'x':
          i += 3;
          break;

        case 'u':
          i += 5;
          break;

        case 'U':
          i += 9;
          break;

        default:
          i += 1;
  ***REMOVED***

      escEnd = i;
***REMOVED***

    if (ch === '\n') ***REMOVED***
      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);
      end = i + endStep;
      split = undefined;
***REMOVED*** else ***REMOVED***
      if (ch === ' ' && prev && prev !== ' ' && prev !== '\n' && prev !== '\t') ***REMOVED***
        // space surrounded by non-space can be replaced with newline + indent
        const next = text[i + 1];
        if (next && next !== ' ' && next !== '\n' && next !== '\t') split = i;
  ***REMOVED***

      if (i >= end) ***REMOVED***
        if (split) ***REMOVED***
          folds.push(split);
          end = split + endStep;
          split = undefined;
    ***REMOVED*** else if (mode === FOLD_QUOTED) ***REMOVED***
          // white-space collected at end may stretch past lineWidth
          while (prev === ' ' || prev === '\t') ***REMOVED***
            prev = ch;
            ch = text[i += 1];
            overflow = true;
      ***REMOVED*** // Account for newline escape, but don't break preceding escape


          const j = i > escEnd + 1 ? i - 2 : escStart - 1; // Bail out if lineWidth & minContentWidth are shorter than an escape string

          if (escapedFolds[j]) return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = undefined;
    ***REMOVED*** else ***REMOVED***
          overflow = true;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

    prev = ch;
***REMOVED***

  if (overflow && onOverflow) onOverflow();
  if (folds.length === 0) return text;
  if (onFold) onFold();
  let res = text.slice(0, folds[0]);

  for (let i = 0; i < folds.length; ++i) ***REMOVED***
    const fold = folds[i];
    const end = folds[i + 1] || text.length;
    if (fold === 0) res = `\n$***REMOVED***indent***REMOVED***$***REMOVED***text.slice(0, end)***REMOVED***`;else ***REMOVED***
      if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `$***REMOVED***text[fold]***REMOVED***\\`;
      res += `\n$***REMOVED***indent***REMOVED***$***REMOVED***text.slice(fold + 1, end)***REMOVED***`;
***REMOVED***
***REMOVED***

  return res;
***REMOVED***

const getFoldOptions = (***REMOVED***
  indentAtStart
***REMOVED***) => indentAtStart ? Object.assign(***REMOVED***
  indentAtStart
***REMOVED***, strOptions.fold) : strOptions.fold; // Also checks for lines starting with %, as parsing the output as YAML 1.1 will
// presume that's starting a new document.


const containsDocumentMarker = str => /^(%|---|\.\.\.)/m.test(str);

function lineLengthOverLimit(str, lineWidth, indentLength) ***REMOVED***
  if (!lineWidth || lineWidth < 0) return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit) return false;

  for (let i = 0, start = 0; i < strLen; ++i) ***REMOVED***
    if (str[i] === '\n') ***REMOVED***
      if (i - start > limit) return true;
      start = i + 1;
      if (strLen - start <= limit) return false;
***REMOVED***
***REMOVED***

  return true;
***REMOVED***

function doubleQuotedString(value, ctx) ***REMOVED***
  const ***REMOVED***
    implicitKey
***REMOVED*** = ctx;
  const ***REMOVED***
    jsonEncoding,
    minMultiLineLength
***REMOVED*** = strOptions.doubleQuoted;
  const json = JSON.stringify(value);
  if (jsonEncoding) return json;
  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
  let str = '';
  let start = 0;

  for (let i = 0, ch = json[i]; ch; ch = json[++i]) ***REMOVED***
    if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') ***REMOVED***
      // space before newline needs to be escaped to not be folded
      str += json.slice(start, i) + '\\ ';
      i += 1;
      start = i;
      ch = '\\';
***REMOVED***

    if (ch === '\\') switch (json[i + 1]) ***REMOVED***
      case 'u':
        ***REMOVED***
          str += json.slice(start, i);
          const code = json.substr(i + 2, 4);

          switch (code) ***REMOVED***
            case '0000':
              str += '\\0';
              break;

            case '0007':
              str += '\\a';
              break;

            case '000b':
              str += '\\v';
              break;

            case '001b':
              str += '\\e';
              break;

            case '0085':
              str += '\\N';
              break;

            case '00a0':
              str += '\\_';
              break;

            case '2028':
              str += '\\L';
              break;

            case '2029':
              str += '\\P';
              break;

            default:
              if (code.substr(0, 2) === '00') str += '\\x' + code.substr(2);else str += json.substr(i, 6);
      ***REMOVED***

          i += 5;
          start = i + 1;
    ***REMOVED***
        break;

      case 'n':
        if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) ***REMOVED***
          i += 1;
    ***REMOVED*** else ***REMOVED***
          // folding will eat first newline
          str += json.slice(start, i) + '\n\n';

          while (json[i + 2] === '\\' && json[i + 3] === 'n' && json[i + 4] !== '"') ***REMOVED***
            str += '\n';
            i += 2;
      ***REMOVED***

          str += indent; // space after newline needs to be escaped to not be folded

          if (json[i + 2] === ' ') str += '\\';
          i += 1;
          start = i + 1;
    ***REMOVED***

        break;

      default:
        i += 1;
***REMOVED***
***REMOVED***

  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
***REMOVED***

function singleQuotedString(value, ctx) ***REMOVED***
  if (ctx.implicitKey) ***REMOVED***
    if (/\n/.test(value)) return doubleQuotedString(value, ctx);
***REMOVED*** else ***REMOVED***
    // single quoted string can't have leading or trailing whitespace around newline
    if (/[ \t]\n|\n[ \t]/.test(value)) return doubleQuotedString(value, ctx);
***REMOVED***

  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n$***REMOVED***indent***REMOVED***`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
***REMOVED***

function blockString(***REMOVED***
  comment,
  type,
  value
***REMOVED***, ctx, onComment, onChompKeep) ***REMOVED***
  // 1. Block can't end in whitespace unless the last line is non-empty.
  // 2. Strings consisting of only whitespace are best rendered explicitly.
  if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) ***REMOVED***
    return doubleQuotedString(value, ctx);
***REMOVED***

  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
  const indentSize = indent ? '2' : '1'; // root is at -1

  const literal = type === PlainValue.Type.BLOCK_FOLDED ? false : type === PlainValue.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth, indent.length);
  let header = literal ? '|' : '>';
  if (!value) return header + '\n';
  let wsStart = '';
  let wsEnd = '';
  value = value.replace(/[\n\t ]*$/, ws => ***REMOVED***
    const n = ws.indexOf('\n');

    if (n === -1) ***REMOVED***
      header += '-'; // strip
***REMOVED*** else if (value === ws || n !== ws.length - 1) ***REMOVED***
      header += '+'; // keep

      if (onChompKeep) onChompKeep();
***REMOVED***

    wsEnd = ws.replace(/\n$/, '');
    return '';
***REMOVED***).replace(/^[\n ]*/, ws => ***REMOVED***
    if (ws.indexOf(' ') !== -1) header += indentSize;
    const m = ws.match(/ +$/);

    if (m) ***REMOVED***
      wsStart = ws.slice(0, -m[0].length);
      return m[0];
***REMOVED*** else ***REMOVED***
      wsStart = ws;
      return '';
***REMOVED***
***REMOVED***);
  if (wsEnd) wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, `$&$***REMOVED***indent***REMOVED***`);
  if (wsStart) wsStart = wsStart.replace(/\n+/g, `$&$***REMOVED***indent***REMOVED***`);

  if (comment) ***REMOVED***
    header += ' #' + comment.replace(/ ?[\r\n]+/g, ' ');
    if (onComment) onComment();
***REMOVED***

  if (!value) return `$***REMOVED***header***REMOVED***$***REMOVED***indentSize***REMOVED***\n$***REMOVED***indent***REMOVED***$***REMOVED***wsEnd***REMOVED***`;

  if (literal) ***REMOVED***
    value = value.replace(/\n+/g, `$&$***REMOVED***indent***REMOVED***`);
    return `$***REMOVED***header***REMOVED***\n$***REMOVED***indent***REMOVED***$***REMOVED***wsStart***REMOVED***$***REMOVED***value***REMOVED***$***REMOVED***wsEnd***REMOVED***`;
***REMOVED***

  value = value.replace(/\n+/g, '\n$&').replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
  //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent
  .replace(/\n+/g, `$&$***REMOVED***indent***REMOVED***`);
  const body = foldFlowLines(`$***REMOVED***wsStart***REMOVED***$***REMOVED***value***REMOVED***$***REMOVED***wsEnd***REMOVED***`, indent, FOLD_BLOCK, strOptions.fold);
  return `$***REMOVED***header***REMOVED***\n$***REMOVED***indent***REMOVED***$***REMOVED***body***REMOVED***`;
***REMOVED***

function plainString(item, ctx, onComment, onChompKeep) ***REMOVED***
  const ***REMOVED***
    comment,
    type,
    value
***REMOVED*** = item;
  const ***REMOVED***
    actualString,
    implicitKey,
    indent,
    inFlow
***REMOVED*** = ctx;

  if (implicitKey && /[\n[\]***REMOVED******REMOVED***,]/.test(value) || inFlow && /[[\]***REMOVED******REMOVED***,]/.test(value)) ***REMOVED***
    return doubleQuotedString(value, ctx);
***REMOVED***

  if (!value || /^[\n\t ,[\]***REMOVED******REMOVED***#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) ***REMOVED***
    // not allowed:
    // - empty string, '-' or '?'
    // - start with an indicator character (except [?:-]) or /[?-] /
    // - '\n ', ': ' or ' \n' anywhere
    // - '#' not preceded by a non-space char
    // - end with ' ' or ':'
    return implicitKey || inFlow || value.indexOf('\n') === -1 ? value.indexOf('"') !== -1 && value.indexOf("'") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
***REMOVED***

  if (!implicitKey && !inFlow && type !== PlainValue.Type.PLAIN && value.indexOf('\n') !== -1) ***REMOVED***
    // Where allowed & type not set explicitly, prefer block style for multiline strings
    return blockString(item, ctx, onComment, onChompKeep);
***REMOVED***

  if (indent === '' && containsDocumentMarker(value)) ***REMOVED***
    ctx.forceBlockIndent = true;
    return blockString(item, ctx, onComment, onChompKeep);
***REMOVED***

  const str = value.replace(/\n+/g, `$&\n$***REMOVED***indent***REMOVED***`); // Verify that output will be parsed as a string, as e.g. plain numbers and
  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
  // and others in v1.1.

  if (actualString) ***REMOVED***
    const ***REMOVED***
      tags
***REMOVED*** = ctx.doc.schema;
    const resolved = resolveScalar(str, tags, tags.scalarFallback).value;
    if (typeof resolved !== 'string') return doubleQuotedString(value, ctx);
***REMOVED***

  const body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));

  if (comment && !inFlow && (body.indexOf('\n') !== -1 || comment.indexOf('\n') !== -1)) ***REMOVED***
    if (onComment) onComment();
    return addCommentBefore(body, indent, comment);
***REMOVED***

  return body;
***REMOVED***

function stringifyString(item, ctx, onComment, onChompKeep) ***REMOVED***
  const ***REMOVED***
    defaultType
***REMOVED*** = strOptions;
  const ***REMOVED***
    implicitKey,
    inFlow
***REMOVED*** = ctx;
  let ***REMOVED***
    type,
    value
***REMOVED*** = item;

  if (typeof value !== 'string') ***REMOVED***
    value = String(value);
    item = Object.assign(***REMOVED******REMOVED***, item, ***REMOVED***
      value
***REMOVED***);
***REMOVED***

  const _stringify = _type => ***REMOVED***
    switch (_type) ***REMOVED***
      case PlainValue.Type.BLOCK_FOLDED:
      case PlainValue.Type.BLOCK_LITERAL:
        return blockString(item, ctx, onComment, onChompKeep);

      case PlainValue.Type.QUOTE_DOUBLE:
        return doubleQuotedString(value, ctx);

      case PlainValue.Type.QUOTE_SINGLE:
        return singleQuotedString(value, ctx);

      case PlainValue.Type.PLAIN:
        return plainString(item, ctx, onComment, onChompKeep);

      default:
        return null;
***REMOVED***
***REMOVED***;

  if (type !== PlainValue.Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)) ***REMOVED***
    // force double quotes on control characters
    type = PlainValue.Type.QUOTE_DOUBLE;
***REMOVED*** else if ((implicitKey || inFlow) && (type === PlainValue.Type.BLOCK_FOLDED || type === PlainValue.Type.BLOCK_LITERAL)) ***REMOVED***
    // should not happen; blocks are not valid inside flow containers
    type = PlainValue.Type.QUOTE_DOUBLE;
***REMOVED***

  let res = _stringify(type);

  if (res === null) ***REMOVED***
    res = _stringify(defaultType);
    if (res === null) throw new Error(`Unsupported default string type $***REMOVED***defaultType***REMOVED***`);
***REMOVED***

  return res;
***REMOVED***

function stringifyNumber(***REMOVED***
  format,
  minFractionDigits,
  tag,
  value
***REMOVED***) ***REMOVED***
  if (typeof value === 'bigint') return String(value);
  if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';
  let n = JSON.stringify(value);

  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\d/.test(n)) ***REMOVED***
    let i = n.indexOf('.');

    if (i < 0) ***REMOVED***
      i = n.length;
      n += '.';
***REMOVED***

    let d = minFractionDigits - (n.length - i - 1);

    while (d-- > 0) n += '0';
***REMOVED***

  return n;
***REMOVED***

function checkFlowCollectionEnd(errors, cst) ***REMOVED***
  let char, name;

  switch (cst.type) ***REMOVED***
    case PlainValue.Type.FLOW_MAP:
      char = '***REMOVED***';
      name = 'flow map';
      break;

    case PlainValue.Type.FLOW_SEQ:
      char = ']';
      name = 'flow sequence';
      break;

    default:
      errors.push(new PlainValue.YAMLSemanticError(cst, 'Not a flow collection!?'));
      return;
***REMOVED***

  let lastItem;

  for (let i = cst.items.length - 1; i >= 0; --i) ***REMOVED***
    const item = cst.items[i];

    if (!item || item.type !== PlainValue.Type.COMMENT) ***REMOVED***
      lastItem = item;
      break;
***REMOVED***
***REMOVED***

  if (lastItem && lastItem.char !== char) ***REMOVED***
    const msg = `Expected $***REMOVED***name***REMOVED*** to end with $***REMOVED***char***REMOVED***`;
    let err;

    if (typeof lastItem.offset === 'number') ***REMOVED***
      err = new PlainValue.YAMLSemanticError(cst, msg);
      err.offset = lastItem.offset + 1;
***REMOVED*** else ***REMOVED***
      err = new PlainValue.YAMLSemanticError(lastItem, msg);
      if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;
***REMOVED***

    errors.push(err);
***REMOVED***
***REMOVED***
function checkFlowCommentSpace(errors, comment) ***REMOVED***
  const prev = comment.context.src[comment.range.start - 1];

  if (prev !== '\n' && prev !== '\t' && prev !== ' ') ***REMOVED***
    const msg = 'Comments must be separated from other tokens by white space characters';
    errors.push(new PlainValue.YAMLSemanticError(comment, msg));
***REMOVED***
***REMOVED***
function getLongKeyError(source, key) ***REMOVED***
  const sk = String(key);
  const k = sk.substr(0, 8) + '...' + sk.substr(-8);
  return new PlainValue.YAMLSemanticError(source, `The "$***REMOVED***k***REMOVED***" key is too long`);
***REMOVED***
function resolveComments(collection, comments) ***REMOVED***
  for (const ***REMOVED***
    afterKey,
    before,
    comment
***REMOVED*** of comments) ***REMOVED***
    let item = collection.items[before];

    if (!item) ***REMOVED***
      if (comment !== undefined) ***REMOVED***
        if (collection.comment) collection.comment += '\n' + comment;else collection.comment = comment;
  ***REMOVED***
***REMOVED*** else ***REMOVED***
      if (afterKey && item.value) item = item.value;

      if (comment === undefined) ***REMOVED***
        if (afterKey || !item.commentBefore) item.spaceBefore = true;
  ***REMOVED*** else ***REMOVED***
        if (item.commentBefore) item.commentBefore += '\n' + comment;else item.commentBefore = comment;
  ***REMOVED***
***REMOVED***
***REMOVED***
***REMOVED***

// on error, will return ***REMOVED*** str: string, errors: Error[] ***REMOVED***
function resolveString(doc, node) ***REMOVED***
  const res = node.strValue;
  if (!res) return '';
  if (typeof res === 'string') return res;
  res.errors.forEach(error => ***REMOVED***
    if (!error.source) error.source = node;
    doc.errors.push(error);
***REMOVED***);
  return res.str;
***REMOVED***

function resolveTagHandle(doc, node) ***REMOVED***
  const ***REMOVED***
    handle,
    suffix
***REMOVED*** = node.tag;
  let prefix = doc.tagPrefixes.find(p => p.handle === handle);

  if (!prefix) ***REMOVED***
    const dtp = doc.getDefaults().tagPrefixes;
    if (dtp) prefix = dtp.find(p => p.handle === handle);
    if (!prefix) throw new PlainValue.YAMLSemanticError(node, `The $***REMOVED***handle***REMOVED*** tag handle is non-default and was not declared.`);
***REMOVED***

  if (!suffix) throw new PlainValue.YAMLSemanticError(node, `The $***REMOVED***handle***REMOVED*** tag has no suffix.`);

  if (handle === '!' && (doc.version || doc.options.version) === '1.0') ***REMOVED***
    if (suffix[0] === '^') ***REMOVED***
      doc.warnings.push(new PlainValue.YAMLWarning(node, 'YAML 1.0 ^ tag expansion is not supported'));
      return suffix;
***REMOVED***

    if (/[:/]/.test(suffix)) ***REMOVED***
      // word/foo -> tag:word.yaml.org,2002:foo
      const vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
      return vocab ? `tag:$***REMOVED***vocab[1]***REMOVED***.yaml.org,2002:$***REMOVED***vocab[2]***REMOVED***` : `tag:$***REMOVED***suffix***REMOVED***`;
***REMOVED***
***REMOVED***

  return prefix.prefix + decodeURIComponent(suffix);
***REMOVED***

function resolveTagName(doc, node) ***REMOVED***
  const ***REMOVED***
    tag,
    type
***REMOVED*** = node;
  let nonSpecific = false;

  if (tag) ***REMOVED***
    const ***REMOVED***
      handle,
      suffix,
      verbatim
***REMOVED*** = tag;

    if (verbatim) ***REMOVED***
      if (verbatim !== '!' && verbatim !== '!!') return verbatim;
      const msg = `Verbatim tags aren't resolved, so $***REMOVED***verbatim***REMOVED*** is invalid.`;
      doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));
***REMOVED*** else if (handle === '!' && !suffix) ***REMOVED***
      nonSpecific = true;
***REMOVED*** else ***REMOVED***
      try ***REMOVED***
        return resolveTagHandle(doc, node);
  ***REMOVED*** catch (error) ***REMOVED***
        doc.errors.push(error);
  ***REMOVED***
***REMOVED***
***REMOVED***

  switch (type) ***REMOVED***
    case PlainValue.Type.BLOCK_FOLDED:
    case PlainValue.Type.BLOCK_LITERAL:
    case PlainValue.Type.QUOTE_DOUBLE:
    case PlainValue.Type.QUOTE_SINGLE:
      return PlainValue.defaultTags.STR;

    case PlainValue.Type.FLOW_MAP:
    case PlainValue.Type.MAP:
      return PlainValue.defaultTags.MAP;

    case PlainValue.Type.FLOW_SEQ:
    case PlainValue.Type.SEQ:
      return PlainValue.defaultTags.SEQ;

    case PlainValue.Type.PLAIN:
      return nonSpecific ? PlainValue.defaultTags.STR : null;

    default:
      return null;
***REMOVED***
***REMOVED***

function resolveByTagName(doc, node, tagName) ***REMOVED***
  const ***REMOVED***
    tags
***REMOVED*** = doc.schema;
  const matchWithTest = [];

  for (const tag of tags) ***REMOVED***
    if (tag.tag === tagName) ***REMOVED***
      if (tag.test) matchWithTest.push(tag);else ***REMOVED***
        const res = tag.resolve(doc, node);
        return res instanceof Collection ? res : new Scalar(res);
  ***REMOVED***
***REMOVED***
***REMOVED***

  const str = resolveString(doc, node);
  if (typeof str === 'string' && matchWithTest.length > 0) return resolveScalar(str, matchWithTest, tags.scalarFallback);
  return null;
***REMOVED***

function getFallbackTagName(***REMOVED***
  type
***REMOVED***) ***REMOVED***
  switch (type) ***REMOVED***
    case PlainValue.Type.FLOW_MAP:
    case PlainValue.Type.MAP:
      return PlainValue.defaultTags.MAP;

    case PlainValue.Type.FLOW_SEQ:
    case PlainValue.Type.SEQ:
      return PlainValue.defaultTags.SEQ;

    default:
      return PlainValue.defaultTags.STR;
***REMOVED***
***REMOVED***

function resolveTag(doc, node, tagName) ***REMOVED***
  try ***REMOVED***
    const res = resolveByTagName(doc, node, tagName);

    if (res) ***REMOVED***
      if (tagName && node.tag) res.tag = tagName;
      return res;
***REMOVED***
***REMOVED*** catch (error) ***REMOVED***
    /* istanbul ignore if */
    if (!error.source) error.source = node;
    doc.errors.push(error);
    return null;
***REMOVED***

  try ***REMOVED***
    const fallback = getFallbackTagName(node);
    if (!fallback) throw new Error(`The tag $***REMOVED***tagName***REMOVED*** is unavailable`);
    const msg = `The tag $***REMOVED***tagName***REMOVED*** is unavailable, falling back to $***REMOVED***fallback***REMOVED***`;
    doc.warnings.push(new PlainValue.YAMLWarning(node, msg));
    const res = resolveByTagName(doc, node, fallback);
    res.tag = tagName;
    return res;
***REMOVED*** catch (error) ***REMOVED***
    const refError = new PlainValue.YAMLReferenceError(node, error.message);
    refError.stack = error.stack;
    doc.errors.push(refError);
    return null;
***REMOVED***
***REMOVED***

const isCollectionItem = node => ***REMOVED***
  if (!node) return false;
  const ***REMOVED***
    type
***REMOVED*** = node;
  return type === PlainValue.Type.MAP_KEY || type === PlainValue.Type.MAP_VALUE || type === PlainValue.Type.SEQ_ITEM;
***REMOVED***;

function resolveNodeProps(errors, node) ***REMOVED***
  const comments = ***REMOVED***
    before: [],
    after: []
***REMOVED***;
  let hasAnchor = false;
  let hasTag = false;
  const props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;

  for (const ***REMOVED***
    start,
    end
***REMOVED*** of props) ***REMOVED***
    switch (node.context.src[start]) ***REMOVED***
      case PlainValue.Char.COMMENT:
        ***REMOVED***
          if (!node.commentHasRequiredWhitespace(start)) ***REMOVED***
            const msg = 'Comments must be separated from other tokens by white space characters';
            errors.push(new PlainValue.YAMLSemanticError(node, msg));
      ***REMOVED***

          const ***REMOVED***
            header,
            valueRange
      ***REMOVED*** = node;
          const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;
          cc.push(node.context.src.slice(start + 1, end));
          break;
    ***REMOVED***
      // Actual anchor & tag resolution is handled by schema, here we just complain

      case PlainValue.Char.ANCHOR:
        if (hasAnchor) ***REMOVED***
          const msg = 'A node can have at most one anchor';
          errors.push(new PlainValue.YAMLSemanticError(node, msg));
    ***REMOVED***

        hasAnchor = true;
        break;

      case PlainValue.Char.TAG:
        if (hasTag) ***REMOVED***
          const msg = 'A node can have at most one tag';
          errors.push(new PlainValue.YAMLSemanticError(node, msg));
    ***REMOVED***

        hasTag = true;
        break;
***REMOVED***
***REMOVED***

  return ***REMOVED***
    comments,
    hasAnchor,
    hasTag
***REMOVED***;
***REMOVED***

function resolveNodeValue(doc, node) ***REMOVED***
  const ***REMOVED***
    anchors,
    errors,
    schema
***REMOVED*** = doc;

  if (node.type === PlainValue.Type.ALIAS) ***REMOVED***
    const name = node.rawValue;
    const src = anchors.getNode(name);

    if (!src) ***REMOVED***
      const msg = `Aliased anchor not found: $***REMOVED***name***REMOVED***`;
      errors.push(new PlainValue.YAMLReferenceError(node, msg));
      return null;
***REMOVED*** // Lazy resolution for circular references


    const res = new Alias(src);

    anchors._cstAliases.push(res);

    return res;
***REMOVED***

  const tagName = resolveTagName(doc, node);
  if (tagName) return resolveTag(doc, node, tagName);

  if (node.type !== PlainValue.Type.PLAIN) ***REMOVED***
    const msg = `Failed to resolve $***REMOVED***node.type***REMOVED*** node here`;
    errors.push(new PlainValue.YAMLSyntaxError(node, msg));
    return null;
***REMOVED***

  try ***REMOVED***
    const str = resolveString(doc, node);
    return resolveScalar(str, schema.tags, schema.tags.scalarFallback);
***REMOVED*** catch (error) ***REMOVED***
    if (!error.source) error.source = node;
    errors.push(error);
    return null;
***REMOVED***
***REMOVED*** // sets node.resolved on success


function resolveNode(doc, node) ***REMOVED***
  if (!node) return null;
  if (node.error) doc.errors.push(node.error);
  const ***REMOVED***
    comments,
    hasAnchor,
    hasTag
***REMOVED*** = resolveNodeProps(doc.errors, node);

  if (hasAnchor) ***REMOVED***
    const ***REMOVED***
      anchors
***REMOVED*** = doc;
    const name = node.anchor;
    const prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor
    // name have already been resolved, so it may safely be renamed.

    if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as
    // anchors need to be available during resolution to allow for
    // circular references.

    anchors.map[name] = node;
***REMOVED***

  if (node.type === PlainValue.Type.ALIAS && (hasAnchor || hasTag)) ***REMOVED***
    const msg = 'An alias node must not specify any properties';
    doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));
***REMOVED***

  const res = resolveNodeValue(doc, node);

  if (res) ***REMOVED***
    res.range = [node.range.start, node.range.end];
    if (doc.options.keepCstNodes) res.cstNode = node;
    if (doc.options.keepNodeTypes) res.type = node.type;
    const cb = comments.before.join('\n');

    if (cb) ***REMOVED***
      res.commentBefore = res.commentBefore ? `$***REMOVED***res.commentBefore***REMOVED***\n$***REMOVED***cb***REMOVED***` : cb;
***REMOVED***

    const ca = comments.after.join('\n');
    if (ca) res.comment = res.comment ? `$***REMOVED***res.comment***REMOVED***\n$***REMOVED***ca***REMOVED***` : ca;
***REMOVED***

  return node.resolved = res;
***REMOVED***

function resolveMap(doc, cst) ***REMOVED***
  if (cst.type !== PlainValue.Type.MAP && cst.type !== PlainValue.Type.FLOW_MAP) ***REMOVED***
    const msg = `A $***REMOVED***cst.type***REMOVED*** node cannot be resolved as a mapping`;
    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
    return null;
***REMOVED***

  const ***REMOVED***
    comments,
    items
***REMOVED*** = cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);
  const map = new YAMLMap();
  map.items = items;
  resolveComments(map, comments);
  let hasCollectionKey = false;

  for (let i = 0; i < items.length; ++i) ***REMOVED***
    const ***REMOVED***
      key: iKey
***REMOVED*** = items[i];
    if (iKey instanceof Collection) hasCollectionKey = true;

    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) ***REMOVED***
      items[i] = new Merge(items[i]);
      const sources = items[i].value.items;
      let error = null;
      sources.some(node => ***REMOVED***
        if (node instanceof Alias) ***REMOVED***
          // During parsing, alias sources are CST nodes; to account for
          // circular references their resolved values can't be used here.
          const ***REMOVED***
            type
      ***REMOVED*** = node.source;
          if (type === PlainValue.Type.MAP || type === PlainValue.Type.FLOW_MAP) return false;
          return error = 'Merge nodes aliases can only point to maps';
    ***REMOVED***

        return error = 'Merge nodes can only have Alias nodes as values';
  ***REMOVED***);
      if (error) doc.errors.push(new PlainValue.YAMLSemanticError(cst, error));
***REMOVED*** else ***REMOVED***
      for (let j = i + 1; j < items.length; ++j) ***REMOVED***
        const ***REMOVED***
          key: jKey
    ***REMOVED*** = items[j];

        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) ***REMOVED***
          const msg = `Map keys must be unique; "$***REMOVED***iKey***REMOVED***" is repeated`;
          doc.errors.push(new PlainValue.YAMLSemanticError(cst, msg));
          break;
    ***REMOVED***
  ***REMOVED***
***REMOVED***
***REMOVED***

  if (hasCollectionKey && !doc.options.mapAsMap) ***REMOVED***
    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';
    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));
***REMOVED***

  cst.resolved = map;
  return map;
***REMOVED***

const valueHasPairComment = (***REMOVED***
  context: ***REMOVED***
    lineStart,
    node,
    src
***REMOVED***
  props
***REMOVED***) => ***REMOVED***
  if (props.length === 0) return false;
  const ***REMOVED***
    start
***REMOVED*** = props[0];
  if (node && start > node.valueRange.start) return false;
  if (src[start] !== PlainValue.Char.COMMENT) return false;

  for (let i = lineStart; i < start; ++i) if (src[i] === '\n') return false;

  return true;
***REMOVED***;

function resolvePairComment(item, pair) ***REMOVED***
  if (!valueHasPairComment(item)) return;
  const comment = item.getPropValue(0, PlainValue.Char.COMMENT, true);
  let found = false;
  const cb = pair.value.commentBefore;

  if (cb && cb.startsWith(comment)) ***REMOVED***
    pair.value.commentBefore = cb.substr(comment.length + 1);
    found = true;
***REMOVED*** else ***REMOVED***
    const cc = pair.value.comment;

    if (!item.node && cc && cc.startsWith(comment)) ***REMOVED***
      pair.value.comment = cc.substr(comment.length + 1);
      found = true;
***REMOVED***
***REMOVED***

  if (found) pair.comment = comment;
***REMOVED***

function resolveBlockMapItems(doc, cst) ***REMOVED***
  const comments = [];
  const items = [];
  let key = undefined;
  let keyStart = null;

  for (let i = 0; i < cst.items.length; ++i) ***REMOVED***
    const item = cst.items[i];

    switch (item.type) ***REMOVED***
      case PlainValue.Type.BLANK_LINE:
        comments.push(***REMOVED***
          afterKey: !!key,
          before: items.length
    ***REMOVED***);
        break;

      case PlainValue.Type.COMMENT:
        comments.push(***REMOVED***
          afterKey: !!key,
          before: items.length,
          comment: item.comment
    ***REMOVED***);
        break;

      case PlainValue.Type.MAP_KEY:
        if (key !== undefined) items.push(new Pair(key));
        if (item.error) doc.errors.push(item.error);
        key = resolveNode(doc, item.node);
        keyStart = null;
        break;

      case PlainValue.Type.MAP_VALUE:
        ***REMOVED***
          if (key === undefined) key = null;
          if (item.error) doc.errors.push(item.error);

          if (!item.context.atLineStart && item.node && item.node.type === PlainValue.Type.MAP && !item.node.context.atLineStart) ***REMOVED***
            const msg = 'Nested mappings are not allowed in compact mappings';
            doc.errors.push(new PlainValue.YAMLSemanticError(item.node, msg));
      ***REMOVED***

          let valueNode = item.node;

          if (!valueNode && item.props.length > 0) ***REMOVED***
            // Comments on an empty mapping value need to be preserved, so we
            // need to construct a minimal empty node here to use instead of the
            // missing `item.node`. -- eemeli/yaml#19
            valueNode = new PlainValue.PlainValue(PlainValue.Type.PLAIN, []);
            valueNode.context = ***REMOVED***
              parent: item,
              src: item.context.src
        ***REMOVED***;
            const pos = item.range.start + 1;
            valueNode.range = ***REMOVED***
              start: pos,
              end: pos
        ***REMOVED***;
            valueNode.valueRange = ***REMOVED***
              start: pos,
              end: pos
        ***REMOVED***;

            if (typeof item.range.origStart === 'number') ***REMOVED***
              const origPos = item.range.origStart + 1;
              valueNode.range.origStart = valueNode.range.origEnd = origPos;
              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
        ***REMOVED***
      ***REMOVED***

          const pair = new Pair(key, resolveNode(doc, valueNode));
          resolvePairComment(item, pair);
          items.push(pair);

          if (key && typeof keyStart === 'number') ***REMOVED***
            if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));
      ***REMOVED***

          key = undefined;
          keyStart = null;
    ***REMOVED***
        break;

      default:
        if (key !== undefined) items.push(new Pair(key));
        key = resolveNode(doc, item);
        keyStart = item.range.start;
        if (item.error) doc.errors.push(item.error);

        next: for (let j = i + 1;; ++j) ***REMOVED***
          const nextItem = cst.items[j];

          switch (nextItem && nextItem.type) ***REMOVED***
            case PlainValue.Type.BLANK_LINE:
            case PlainValue.Type.COMMENT:
              continue next;

            case PlainValue.Type.MAP_VALUE:
              break next;

            default:
              ***REMOVED***
                const msg = 'Implicit map keys need to be followed by map values';
                doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
                break next;
          ***REMOVED***
      ***REMOVED***
    ***REMOVED***

        if (item.valueRangeContainsNewline) ***REMOVED***
          const msg = 'Implicit map keys need to be on a single line';
          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
    ***REMOVED***

***REMOVED***
***REMOVED***

  if (key !== undefined) items.push(new Pair(key));
  return ***REMOVED***
    comments,
    items
***REMOVED***;
***REMOVED***

function resolveFlowMapItems(doc, cst) ***REMOVED***
  const comments = [];
  const items = [];
  let key = undefined;
  let explicitKey = false;
  let next = '***REMOVED***';

  for (let i = 0; i < cst.items.length; ++i) ***REMOVED***
    const item = cst.items[i];

    if (typeof item.char === 'string') ***REMOVED***
      const ***REMOVED***
        char,
        offset
  ***REMOVED*** = item;

      if (char === '?' && key === undefined && !explicitKey) ***REMOVED***
        explicitKey = true;
        next = ':';
        continue;
  ***REMOVED***

      if (char === ':') ***REMOVED***
        if (key === undefined) key = null;

        if (next === ':') ***REMOVED***
          next = ',';
          continue;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
        if (explicitKey) ***REMOVED***
          if (key === undefined && char !== ',') key = null;
          explicitKey = false;
    ***REMOVED***

        if (key !== undefined) ***REMOVED***
          items.push(new Pair(key));
          key = undefined;

          if (char === ',') ***REMOVED***
            next = ':';
            continue;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

      if (char === '***REMOVED***') ***REMOVED***
        if (i === cst.items.length - 1) continue;
  ***REMOVED*** else if (char === next) ***REMOVED***
        next = ':';
        continue;
  ***REMOVED***

      const msg = `Flow map contains an unexpected $***REMOVED***char***REMOVED***`;
      const err = new PlainValue.YAMLSyntaxError(cst, msg);
      err.offset = offset;
      doc.errors.push(err);
***REMOVED*** else if (item.type === PlainValue.Type.BLANK_LINE) ***REMOVED***
      comments.push(***REMOVED***
        afterKey: !!key,
        before: items.length
  ***REMOVED***);
***REMOVED*** else if (item.type === PlainValue.Type.COMMENT) ***REMOVED***
      checkFlowCommentSpace(doc.errors, item);
      comments.push(***REMOVED***
        afterKey: !!key,
        before: items.length,
        comment: item.comment
  ***REMOVED***);
***REMOVED*** else if (key === undefined) ***REMOVED***
      if (next === ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Separator , missing in flow map'));
      key = resolveNode(doc, item);
***REMOVED*** else ***REMOVED***
      if (next !== ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Indicator : missing in flow map entry'));
      items.push(new Pair(key, resolveNode(doc, item)));
      key = undefined;
      explicitKey = false;
***REMOVED***
***REMOVED***

  checkFlowCollectionEnd(doc.errors, cst);
  if (key !== undefined) items.push(new Pair(key));
  return ***REMOVED***
    comments,
    items
***REMOVED***;
***REMOVED***

function resolveSeq(doc, cst) ***REMOVED***
  if (cst.type !== PlainValue.Type.SEQ && cst.type !== PlainValue.Type.FLOW_SEQ) ***REMOVED***
    const msg = `A $***REMOVED***cst.type***REMOVED*** node cannot be resolved as a sequence`;
    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
    return null;
***REMOVED***

  const ***REMOVED***
    comments,
    items
***REMOVED*** = cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);
  const seq = new YAMLSeq();
  seq.items = items;
  resolveComments(seq, comments);

  if (!doc.options.mapAsMap && items.some(it => it instanceof Pair && it.key instanceof Collection)) ***REMOVED***
    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';
    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));
***REMOVED***

  cst.resolved = seq;
  return seq;
***REMOVED***

function resolveBlockSeqItems(doc, cst) ***REMOVED***
  const comments = [];
  const items = [];

  for (let i = 0; i < cst.items.length; ++i) ***REMOVED***
    const item = cst.items[i];

    switch (item.type) ***REMOVED***
      case PlainValue.Type.BLANK_LINE:
        comments.push(***REMOVED***
          before: items.length
    ***REMOVED***);
        break;

      case PlainValue.Type.COMMENT:
        comments.push(***REMOVED***
          comment: item.comment,
          before: items.length
    ***REMOVED***);
        break;

      case PlainValue.Type.SEQ_ITEM:
        if (item.error) doc.errors.push(item.error);
        items.push(resolveNode(doc, item.node));

        if (item.hasProps) ***REMOVED***
          const msg = 'Sequence items cannot have tags or anchors before the - indicator';
          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
    ***REMOVED***

        break;

      default:
        if (item.error) doc.errors.push(item.error);
        doc.errors.push(new PlainValue.YAMLSyntaxError(item, `Unexpected $***REMOVED***item.type***REMOVED*** node in sequence`));
***REMOVED***
***REMOVED***

  return ***REMOVED***
    comments,
    items
***REMOVED***;
***REMOVED***

function resolveFlowSeqItems(doc, cst) ***REMOVED***
  const comments = [];
  const items = [];
  let explicitKey = false;
  let key = undefined;
  let keyStart = null;
  let next = '[';
  let prevItem = null;

  for (let i = 0; i < cst.items.length; ++i) ***REMOVED***
    const item = cst.items[i];

    if (typeof item.char === 'string') ***REMOVED***
      const ***REMOVED***
        char,
        offset
  ***REMOVED*** = item;

      if (char !== ':' && (explicitKey || key !== undefined)) ***REMOVED***
        if (explicitKey && key === undefined) key = next ? items.pop() : null;
        items.push(new Pair(key));
        explicitKey = false;
        key = undefined;
        keyStart = null;
  ***REMOVED***

      if (char === next) ***REMOVED***
        next = null;
  ***REMOVED*** else if (!next && char === '?') ***REMOVED***
        explicitKey = true;
  ***REMOVED*** else if (next !== '[' && char === ':' && key === undefined) ***REMOVED***
        if (next === ',') ***REMOVED***
          key = items.pop();

          if (key instanceof Pair) ***REMOVED***
            const msg = 'Chaining flow sequence pairs is invalid';
            const err = new PlainValue.YAMLSemanticError(cst, msg);
            err.offset = offset;
            doc.errors.push(err);
      ***REMOVED***

          if (!explicitKey && typeof keyStart === 'number') ***REMOVED***
            const keyEnd = item.range ? item.range.start : item.offset;
            if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));
            const ***REMOVED***
              src
        ***REMOVED*** = prevItem.context;

            for (let i = keyStart; i < keyEnd; ++i) if (src[i] === '\n') ***REMOVED***
              const msg = 'Implicit keys of flow sequence pairs need to be on a single line';
              doc.errors.push(new PlainValue.YAMLSemanticError(prevItem, msg));
              break;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
          key = null;
    ***REMOVED***

        keyStart = null;
        explicitKey = false;
        next = null;
  ***REMOVED*** else if (next === '[' || char !== ']' || i < cst.items.length - 1) ***REMOVED***
        const msg = `Flow sequence contains an unexpected $***REMOVED***char***REMOVED***`;
        const err = new PlainValue.YAMLSyntaxError(cst, msg);
        err.offset = offset;
        doc.errors.push(err);
  ***REMOVED***
***REMOVED*** else if (item.type === PlainValue.Type.BLANK_LINE) ***REMOVED***
      comments.push(***REMOVED***
        before: items.length
  ***REMOVED***);
***REMOVED*** else if (item.type === PlainValue.Type.COMMENT) ***REMOVED***
      checkFlowCommentSpace(doc.errors, item);
      comments.push(***REMOVED***
        comment: item.comment,
        before: items.length
  ***REMOVED***);
***REMOVED*** else ***REMOVED***
      if (next) ***REMOVED***
        const msg = `Expected a $***REMOVED***next***REMOVED*** in flow sequence`;
        doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
  ***REMOVED***

      const value = resolveNode(doc, item);

      if (key === undefined) ***REMOVED***
        items.push(value);
        prevItem = item;
  ***REMOVED*** else ***REMOVED***
        items.push(new Pair(key, value));
        key = undefined;
  ***REMOVED***

      keyStart = item.range.start;
      next = ',';
***REMOVED***
***REMOVED***

  checkFlowCollectionEnd(doc.errors, cst);
  if (key !== undefined) items.push(new Pair(key));
  return ***REMOVED***
    comments,
    items
***REMOVED***;
***REMOVED***

exports.Alias = Alias;
exports.Collection = Collection;
exports.Merge = Merge;
exports.Node = Node;
exports.Pair = Pair;
exports.Scalar = Scalar;
exports.YAMLMap = YAMLMap;
exports.YAMLSeq = YAMLSeq;
exports.addComment = addComment;
exports.binaryOptions = binaryOptions;
exports.boolOptions = boolOptions;
exports.findPair = findPair;
exports.intOptions = intOptions;
exports.isEmptyPath = isEmptyPath;
exports.nullOptions = nullOptions;
exports.resolveMap = resolveMap;
exports.resolveNode = resolveNode;
exports.resolveSeq = resolveSeq;
exports.resolveString = resolveString;
exports.strOptions = strOptions;
exports.stringifyNumber = stringifyNumber;
exports.stringifyString = stringifyString;
exports.toJSON = toJSON;
