'use strict';

var PlainValue = require('./PlainValue-ec8e588e.js');
var resolveSeq = require('./resolveSeq-d03cb037.js');
var Schema = require('./Schema-88e323a7.js');

const defaultOptions = ***REMOVED***
  anchorPrefix: 'a',
  customTags: null,
  indent: 2,
  indentSeq: true,
  keepCstNodes: false,
  keepNodeTypes: true,
  keepBlobsInJSON: true,
  mapAsMap: false,
  maxAliasCount: 100,
  prettyErrors: false,
  // TODO Set true in v2
  simpleKeys: false,
  version: '1.2'
***REMOVED***;
const scalarOptions = ***REMOVED***
  get binary() ***REMOVED***
    return resolveSeq.binaryOptions;
***REMOVED***

  set binary(opt) ***REMOVED***
    Object.assign(resolveSeq.binaryOptions, opt);
***REMOVED***

  get bool() ***REMOVED***
    return resolveSeq.boolOptions;
***REMOVED***

  set bool(opt) ***REMOVED***
    Object.assign(resolveSeq.boolOptions, opt);
***REMOVED***

  get int() ***REMOVED***
    return resolveSeq.intOptions;
***REMOVED***

  set int(opt) ***REMOVED***
    Object.assign(resolveSeq.intOptions, opt);
***REMOVED***

  get null() ***REMOVED***
    return resolveSeq.nullOptions;
***REMOVED***

  set null(opt) ***REMOVED***
    Object.assign(resolveSeq.nullOptions, opt);
***REMOVED***

  get str() ***REMOVED***
    return resolveSeq.strOptions;
***REMOVED***

  set str(opt) ***REMOVED***
    Object.assign(resolveSeq.strOptions, opt);
***REMOVED***

***REMOVED***;
const documentOptions = ***REMOVED***
  '1.0': ***REMOVED***
    schema: 'yaml-1.1',
    merge: true,
    tagPrefixes: [***REMOVED***
      handle: '!',
      prefix: PlainValue.defaultTagPrefix
***REMOVED***, ***REMOVED***
      handle: '!!',
      prefix: 'tag:private.yaml.org,2002:'
***REMOVED***]
***REMOVED***
  1.1: ***REMOVED***
    schema: 'yaml-1.1',
    merge: true,
    tagPrefixes: [***REMOVED***
      handle: '!',
      prefix: '!'
***REMOVED***, ***REMOVED***
      handle: '!!',
      prefix: PlainValue.defaultTagPrefix
***REMOVED***]
***REMOVED***
  1.2: ***REMOVED***
    schema: 'core',
    merge: false,
    tagPrefixes: [***REMOVED***
      handle: '!',
      prefix: '!'
***REMOVED***, ***REMOVED***
      handle: '!!',
      prefix: PlainValue.defaultTagPrefix
***REMOVED***]
***REMOVED***
***REMOVED***;

function stringifyTag(doc, tag) ***REMOVED***
  if ((doc.version || doc.options.version) === '1.0') ***REMOVED***
    const priv = tag.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
    if (priv) return '!' + priv[1];
    const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
    return vocab ? `!$***REMOVED***vocab[1]***REMOVED***/$***REMOVED***vocab[2]***REMOVED***` : `!$***REMOVED***tag.replace(/^tag:/, '')***REMOVED***`;
***REMOVED***

  let p = doc.tagPrefixes.find(p => tag.indexOf(p.prefix) === 0);

  if (!p) ***REMOVED***
    const dtp = doc.getDefaults().tagPrefixes;
    p = dtp && dtp.find(p => tag.indexOf(p.prefix) === 0);
***REMOVED***

  if (!p) return tag[0] === '!' ? tag : `!<$***REMOVED***tag***REMOVED***>`;
  const suffix = tag.substr(p.prefix.length).replace(/[!,[\]***REMOVED******REMOVED***]/g, ch => (***REMOVED***
    '!': '%21',
    ',': '%2C',
    '[': '%5B',
    ']': '%5D',
    '***REMOVED***': '%7B',
    '***REMOVED***': '%7D'
***REMOVED***)[ch]);
  return p.handle + suffix;
***REMOVED***

function getTagObject(tags, item) ***REMOVED***
  if (item instanceof resolveSeq.Alias) return resolveSeq.Alias;

  if (item.tag) ***REMOVED***
    const match = tags.filter(t => t.tag === item.tag);
    if (match.length > 0) return match.find(t => t.format === item.format) || match[0];
***REMOVED***

  let tagObj, obj;

  if (item instanceof resolveSeq.Scalar) ***REMOVED***
    obj = item.value; // TODO: deprecate/remove class check

    const match = tags.filter(t => t.identify && t.identify(obj) || t.class && obj instanceof t.class);
    tagObj = match.find(t => t.format === item.format) || match.find(t => !t.format);
***REMOVED*** else ***REMOVED***
    obj = item;
    tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);
***REMOVED***

  if (!tagObj) ***REMOVED***
    const name = obj && obj.constructor ? obj.constructor.name : typeof obj;
    throw new Error(`Tag not resolved for $***REMOVED***name***REMOVED*** value`);
***REMOVED***

  return tagObj;
***REMOVED*** // needs to be called before value stringifier to allow for circular anchor refs


function stringifyProps(node, tagObj, ***REMOVED***
  anchors,
  doc
***REMOVED***) ***REMOVED***
  const props = [];
  const anchor = doc.anchors.getName(node);

  if (anchor) ***REMOVED***
    anchors[anchor] = node;
    props.push(`&$***REMOVED***anchor***REMOVED***`);
***REMOVED***

  if (node.tag) ***REMOVED***
    props.push(stringifyTag(doc, node.tag));
***REMOVED*** else if (!tagObj.default) ***REMOVED***
    props.push(stringifyTag(doc, tagObj.tag));
***REMOVED***

  return props.join(' ');
***REMOVED***

function stringify(item, ctx, onComment, onChompKeep) ***REMOVED***
  const ***REMOVED***
    anchors,
    schema
***REMOVED*** = ctx.doc;
  let tagObj;

  if (!(item instanceof resolveSeq.Node)) ***REMOVED***
    const createCtx = ***REMOVED***
      aliasNodes: [],
      onTagObj: o => tagObj = o,
      prevObjects: new Map()
***REMOVED***;
    item = schema.createNode(item, true, null, createCtx);

    for (const alias of createCtx.aliasNodes) ***REMOVED***
      alias.source = alias.source.node;
      let name = anchors.getName(alias.source);

      if (!name) ***REMOVED***
        name = anchors.newName();
        anchors.map[name] = alias.source;
  ***REMOVED***
***REMOVED***
***REMOVED***

  if (item instanceof resolveSeq.Pair) return item.toString(ctx, onComment, onChompKeep);
  if (!tagObj) tagObj = getTagObject(schema.tags, item);
  const props = stringifyProps(item, tagObj, ctx);
  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
  const str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof resolveSeq.Scalar ? resolveSeq.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);
  if (!props) return str;
  return item instanceof resolveSeq.Scalar || str[0] === '***REMOVED***' || str[0] === '[' ? `$***REMOVED***props***REMOVED*** $***REMOVED***str***REMOVED***` : `$***REMOVED***props***REMOVED***\n$***REMOVED***ctx.indent***REMOVED***$***REMOVED***str***REMOVED***`;
***REMOVED***

class Anchors ***REMOVED***
  static validAnchorNode(node) ***REMOVED***
    return node instanceof resolveSeq.Scalar || node instanceof resolveSeq.YAMLSeq || node instanceof resolveSeq.YAMLMap;
***REMOVED***

  constructor(prefix) ***REMOVED***
    PlainValue._defineProperty(this, "map", Object.create(null));

    this.prefix = prefix;
***REMOVED***

  createAlias(node, name) ***REMOVED***
    this.setAnchor(node, name);
    return new resolveSeq.Alias(node);
***REMOVED***

  createMergePair(...sources) ***REMOVED***
    const merge = new resolveSeq.Merge();
    merge.value.items = sources.map(s => ***REMOVED***
      if (s instanceof resolveSeq.Alias) ***REMOVED***
        if (s.source instanceof resolveSeq.YAMLMap) return s;
  ***REMOVED*** else if (s instanceof resolveSeq.YAMLMap) ***REMOVED***
        return this.createAlias(s);
  ***REMOVED***

      throw new Error('Merge sources must be Map nodes or their Aliases');
***REMOVED***);
    return merge;
***REMOVED***

  getName(node) ***REMOVED***
    const ***REMOVED***
      map
***REMOVED*** = this;
    return Object.keys(map).find(a => map[a] === node);
***REMOVED***

  getNames() ***REMOVED***
    return Object.keys(this.map);
***REMOVED***

  getNode(name) ***REMOVED***
    return this.map[name];
***REMOVED***

  newName(prefix) ***REMOVED***
    if (!prefix) prefix = this.prefix;
    const names = Object.keys(this.map);

    for (let i = 1; true; ++i) ***REMOVED***
      const name = `$***REMOVED***prefix***REMOVED***$***REMOVED***i***REMOVED***`;
      if (!names.includes(name)) return name;
***REMOVED***
***REMOVED*** // During parsing, map & aliases contain CST nodes


  resolveNodes() ***REMOVED***
    const ***REMOVED***
      map,
      _cstAliases
***REMOVED*** = this;
    Object.keys(map).forEach(a => ***REMOVED***
      map[a] = map[a].resolved;
***REMOVED***);

    _cstAliases.forEach(a => ***REMOVED***
      a.source = a.source.resolved;
***REMOVED***);

    delete this._cstAliases;
***REMOVED***

  setAnchor(node, name) ***REMOVED***
    if (node != null && !Anchors.validAnchorNode(node)) ***REMOVED***
      throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');
***REMOVED***

    if (name && /[\x00-\x19\s,[\]***REMOVED******REMOVED***]/.test(name)) ***REMOVED***
      throw new Error('Anchor names must not contain whitespace or control characters');
***REMOVED***

    const ***REMOVED***
      map
***REMOVED*** = this;
    const prev = node && Object.keys(map).find(a => map[a] === node);

    if (prev) ***REMOVED***
      if (!name) ***REMOVED***
        return prev;
  ***REMOVED*** else if (prev !== name) ***REMOVED***
        delete map[prev];
        map[name] = node;
  ***REMOVED***
***REMOVED*** else ***REMOVED***
      if (!name) ***REMOVED***
        if (!node) return null;
        name = this.newName();
  ***REMOVED***

      map[name] = node;
***REMOVED***

    return name;
***REMOVED***

***REMOVED***

const visit = (node, tags) => ***REMOVED***
  if (node && typeof node === 'object') ***REMOVED***
    const ***REMOVED***
      tag
***REMOVED*** = node;

    if (node instanceof resolveSeq.Collection) ***REMOVED***
      if (tag) tags[tag] = true;
      node.items.forEach(n => visit(n, tags));
***REMOVED*** else if (node instanceof resolveSeq.Pair) ***REMOVED***
      visit(node.key, tags);
      visit(node.value, tags);
***REMOVED*** else if (node instanceof resolveSeq.Scalar) ***REMOVED***
      if (tag) tags[tag] = true;
***REMOVED***
***REMOVED***

  return tags;
***REMOVED***;

const listTagNames = node => Object.keys(visit(node, ***REMOVED******REMOVED***));

function parseContents(doc, contents) ***REMOVED***
  const comments = ***REMOVED***
    before: [],
    after: []
***REMOVED***;
  let body = undefined;
  let spaceBefore = false;

  for (const node of contents) ***REMOVED***
    if (node.valueRange) ***REMOVED***
      if (body !== undefined) ***REMOVED***
        const msg = 'Document contains trailing content not separated by a ... or --- line';
        doc.errors.push(new PlainValue.YAMLSyntaxError(node, msg));
        break;
  ***REMOVED***

      const res = resolveSeq.resolveNode(doc, node);

      if (spaceBefore) ***REMOVED***
        res.spaceBefore = true;
        spaceBefore = false;
  ***REMOVED***

      body = res;
***REMOVED*** else if (node.comment !== null) ***REMOVED***
      const cc = body === undefined ? comments.before : comments.after;
      cc.push(node.comment);
***REMOVED*** else if (node.type === PlainValue.Type.BLANK_LINE) ***REMOVED***
      spaceBefore = true;

      if (body === undefined && comments.before.length > 0 && !doc.commentBefore) ***REMOVED***
        // space-separated comments at start are parsed as document comments
        doc.commentBefore = comments.before.join('\n');
        comments.before = [];
  ***REMOVED***
***REMOVED***
***REMOVED***

  doc.contents = body || null;

  if (!body) ***REMOVED***
    doc.comment = comments.before.concat(comments.after).join('\n') || null;
***REMOVED*** else ***REMOVED***
    const cb = comments.before.join('\n');

    if (cb) ***REMOVED***
      const cbNode = body instanceof resolveSeq.Collection && body.items[0] ? body.items[0] : body;
      cbNode.commentBefore = cbNode.commentBefore ? `$***REMOVED***cb***REMOVED***\n$***REMOVED***cbNode.commentBefore***REMOVED***` : cb;
***REMOVED***

    doc.comment = comments.after.join('\n') || null;
***REMOVED***
***REMOVED***

function resolveTagDirective(***REMOVED***
  tagPrefixes
***REMOVED***, directive) ***REMOVED***
  const [handle, prefix] = directive.parameters;

  if (!handle || !prefix) ***REMOVED***
    const msg = 'Insufficient parameters given for %TAG directive';
    throw new PlainValue.YAMLSemanticError(directive, msg);
***REMOVED***

  if (tagPrefixes.some(p => p.handle === handle)) ***REMOVED***
    const msg = 'The %TAG directive must only be given at most once per handle in the same document.';
    throw new PlainValue.YAMLSemanticError(directive, msg);
***REMOVED***

  return ***REMOVED***
    handle,
    prefix
***REMOVED***;
***REMOVED***

function resolveYamlDirective(doc, directive) ***REMOVED***
  let [version] = directive.parameters;
  if (directive.name === 'YAML:1.0') version = '1.0';

  if (!version) ***REMOVED***
    const msg = 'Insufficient parameters given for %YAML directive';
    throw new PlainValue.YAMLSemanticError(directive, msg);
***REMOVED***

  if (!documentOptions[version]) ***REMOVED***
    const v0 = doc.version || doc.options.version;
    const msg = `Document will be parsed as YAML $***REMOVED***v0***REMOVED*** rather than YAML $***REMOVED***version***REMOVED***`;
    doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));
***REMOVED***

  return version;
***REMOVED***

function parseDirectives(doc, directives, prevDoc) ***REMOVED***
  const directiveComments = [];
  let hasDirectives = false;

  for (const directive of directives) ***REMOVED***
    const ***REMOVED***
      comment,
      name
***REMOVED*** = directive;

    switch (name) ***REMOVED***
      case 'TAG':
        try ***REMOVED***
          doc.tagPrefixes.push(resolveTagDirective(doc, directive));
    ***REMOVED*** catch (error) ***REMOVED***
          doc.errors.push(error);
    ***REMOVED***

        hasDirectives = true;
        break;

      case 'YAML':
      case 'YAML:1.0':
        if (doc.version) ***REMOVED***
          const msg = 'The %YAML directive must only be given at most once per document.';
          doc.errors.push(new PlainValue.YAMLSemanticError(directive, msg));
    ***REMOVED***

        try ***REMOVED***
          doc.version = resolveYamlDirective(doc, directive);
    ***REMOVED*** catch (error) ***REMOVED***
          doc.errors.push(error);
    ***REMOVED***

        hasDirectives = true;
        break;

      default:
        if (name) ***REMOVED***
          const msg = `YAML only supports %TAG and %YAML directives, and not %$***REMOVED***name***REMOVED***`;
          doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));
    ***REMOVED***

***REMOVED***

    if (comment) directiveComments.push(comment);
***REMOVED***

  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) ***REMOVED***
    const copyTagPrefix = (***REMOVED***
      handle,
      prefix
***REMOVED***) => (***REMOVED***
      handle,
      prefix
***REMOVED***);

    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);
    doc.version = prevDoc.version;
***REMOVED***

  doc.commentBefore = directiveComments.join('\n') || null;
***REMOVED***

function assertCollection(contents) ***REMOVED***
  if (contents instanceof resolveSeq.Collection) return true;
  throw new Error('Expected a YAML collection as document contents');
***REMOVED***

class Document ***REMOVED***
  constructor(options) ***REMOVED***
    this.anchors = new Anchors(options.anchorPrefix);
    this.commentBefore = null;
    this.comment = null;
    this.contents = null;
    this.directivesEndMarker = null;
    this.errors = [];
    this.options = options;
    this.schema = null;
    this.tagPrefixes = [];
    this.version = null;
    this.warnings = [];
***REMOVED***

  add(value) ***REMOVED***
    assertCollection(this.contents);
    return this.contents.add(value);
***REMOVED***

  addIn(path, value) ***REMOVED***
    assertCollection(this.contents);
    this.contents.addIn(path, value);
***REMOVED***

  delete(key) ***REMOVED***
    assertCollection(this.contents);
    return this.contents.delete(key);
***REMOVED***

  deleteIn(path) ***REMOVED***
    if (resolveSeq.isEmptyPath(path)) ***REMOVED***
      if (this.contents == null) return false;
      this.contents = null;
      return true;
***REMOVED***

    assertCollection(this.contents);
    return this.contents.deleteIn(path);
***REMOVED***

  getDefaults() ***REMOVED***
    return Document.defaults[this.version] || Document.defaults[this.options.version] || ***REMOVED******REMOVED***;
***REMOVED***

  get(key, keepScalar) ***REMOVED***
    return this.contents instanceof resolveSeq.Collection ? this.contents.get(key, keepScalar) : undefined;
***REMOVED***

  getIn(path, keepScalar) ***REMOVED***
    if (resolveSeq.isEmptyPath(path)) return !keepScalar && this.contents instanceof resolveSeq.Scalar ? this.contents.value : this.contents;
    return this.contents instanceof resolveSeq.Collection ? this.contents.getIn(path, keepScalar) : undefined;
***REMOVED***

  has(key) ***REMOVED***
    return this.contents instanceof resolveSeq.Collection ? this.contents.has(key) : false;
***REMOVED***

  hasIn(path) ***REMOVED***
    if (resolveSeq.isEmptyPath(path)) return this.contents !== undefined;
    return this.contents instanceof resolveSeq.Collection ? this.contents.hasIn(path) : false;
***REMOVED***

  set(key, value) ***REMOVED***
    assertCollection(this.contents);
    this.contents.set(key, value);
***REMOVED***

  setIn(path, value) ***REMOVED***
    if (resolveSeq.isEmptyPath(path)) this.contents = value;else ***REMOVED***
      assertCollection(this.contents);
      this.contents.setIn(path, value);
***REMOVED***
***REMOVED***

  setSchema(id, customTags) ***REMOVED***
    if (!id && !customTags && this.schema) return;
    if (typeof id === 'number') id = id.toFixed(1);

    if (id === '1.0' || id === '1.1' || id === '1.2') ***REMOVED***
      if (this.version) this.version = id;else this.options.version = id;
      delete this.options.schema;
***REMOVED*** else if (id && typeof id === 'string') ***REMOVED***
      this.options.schema = id;
***REMOVED***

    if (Array.isArray(customTags)) this.options.customTags = customTags;
    const opt = Object.assign(***REMOVED******REMOVED***, this.getDefaults(), this.options);
    this.schema = new Schema.Schema(opt);
***REMOVED***

  parse(node, prevDoc) ***REMOVED***
    if (this.options.keepCstNodes) this.cstNode = node;
    if (this.options.keepNodeTypes) this.type = 'DOCUMENT';
    const ***REMOVED***
      directives = [],
      contents = [],
      directivesEndMarker,
      error,
      valueRange
***REMOVED*** = node;

    if (error) ***REMOVED***
      if (!error.source) error.source = this;
      this.errors.push(error);
***REMOVED***

    parseDirectives(this, directives, prevDoc);
    if (directivesEndMarker) this.directivesEndMarker = true;
    this.range = valueRange ? [valueRange.start, valueRange.end] : null;
    this.setSchema();
    this.anchors._cstAliases = [];
    parseContents(this, contents);
    this.anchors.resolveNodes();

    if (this.options.prettyErrors) ***REMOVED***
      for (const error of this.errors) if (error instanceof PlainValue.YAMLError) error.makePretty();

      for (const warn of this.warnings) if (warn instanceof PlainValue.YAMLError) warn.makePretty();
***REMOVED***

    return this;
***REMOVED***

  listNonDefaultTags() ***REMOVED***
    return listTagNames(this.contents).filter(t => t.indexOf(Schema.Schema.defaultPrefix) !== 0);
***REMOVED***

  setTagPrefix(handle, prefix) ***REMOVED***
    if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');

    if (prefix) ***REMOVED***
      const prev = this.tagPrefixes.find(p => p.handle === handle);
      if (prev) prev.prefix = prefix;else this.tagPrefixes.push(***REMOVED***
        handle,
        prefix
  ***REMOVED***);
***REMOVED*** else ***REMOVED***
      this.tagPrefixes = this.tagPrefixes.filter(p => p.handle !== handle);
***REMOVED***
***REMOVED***

  toJSON(arg, onAnchor) ***REMOVED***
    const ***REMOVED***
      keepBlobsInJSON,
      mapAsMap,
      maxAliasCount
***REMOVED*** = this.options;
    const keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof resolveSeq.Scalar));
    const ctx = ***REMOVED***
      doc: this,
      indentStep: '  ',
      keep,
      mapAsMap: keep && !!mapAsMap,
      maxAliasCount,
      stringify // Requiring directly in Pair would create circular dependencies

***REMOVED***;
    const anchorNames = Object.keys(this.anchors.map);
    if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(name => [this.anchors.map[name], ***REMOVED***
      alias: [],
      aliasCount: 0,
      count: 1
***REMOVED***]));
    const res = resolveSeq.toJSON(this.contents, arg, ctx);
    if (typeof onAnchor === 'function' && ctx.anchors) for (const ***REMOVED***
      count,
      res
***REMOVED*** of ctx.anchors.values()) onAnchor(res, count);
    return res;
***REMOVED***

  toString() ***REMOVED***
    if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');
    const indentSize = this.options.indent;

    if (!Number.isInteger(indentSize) || indentSize <= 0) ***REMOVED***
      const s = JSON.stringify(indentSize);
      throw new Error(`"indent" option must be a positive integer, not $***REMOVED***s***REMOVED***`);
***REMOVED***

    this.setSchema();
    const lines = [];
    let hasDirectives = false;

    if (this.version) ***REMOVED***
      let vd = '%YAML 1.2';

      if (this.schema.name === 'yaml-1.1') ***REMOVED***
        if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';
  ***REMOVED***

      lines.push(vd);
      hasDirectives = true;
***REMOVED***

    const tagNames = this.listNonDefaultTags();
    this.tagPrefixes.forEach((***REMOVED***
      handle,
      prefix
***REMOVED***) => ***REMOVED***
      if (tagNames.some(t => t.indexOf(prefix) === 0)) ***REMOVED***
        lines.push(`%TAG $***REMOVED***handle***REMOVED*** $***REMOVED***prefix***REMOVED***`);
        hasDirectives = true;
  ***REMOVED***
***REMOVED***);
    if (hasDirectives || this.directivesEndMarker) lines.push('---');

    if (this.commentBefore) ***REMOVED***
      if (hasDirectives || !this.directivesEndMarker) lines.unshift('');
      lines.unshift(this.commentBefore.replace(/^/gm, '#'));
***REMOVED***

    const ctx = ***REMOVED***
      anchors: Object.create(null),
      doc: this,
      indent: '',
      indentStep: ' '.repeat(indentSize),
      stringify // Requiring directly in nodes would create circular dependencies

***REMOVED***;
    let chompKeep = false;
    let contentComment = null;

    if (this.contents) ***REMOVED***
      if (this.contents instanceof resolveSeq.Node) ***REMOVED***
        if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');
        if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment

        ctx.forceBlockIndent = !!this.comment;
        contentComment = this.contents.comment;
  ***REMOVED***

      const onChompKeep = contentComment ? null : () => chompKeep = true;
      const body = stringify(this.contents, ctx, () => contentComment = null, onChompKeep);
      lines.push(resolveSeq.addComment(body, '', contentComment));
***REMOVED*** else if (this.contents !== undefined) ***REMOVED***
      lines.push(stringify(this.contents, ctx));
***REMOVED***

    if (this.comment) ***REMOVED***
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');
      lines.push(this.comment.replace(/^/gm, '#'));
***REMOVED***

    return lines.join('\n') + '\n';
***REMOVED***

***REMOVED***

PlainValue._defineProperty(Document, "defaults", documentOptions);

exports.Document = Document;
exports.defaultOptions = defaultOptions;
exports.scalarOptions = scalarOptions;
