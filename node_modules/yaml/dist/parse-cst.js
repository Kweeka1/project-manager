'use strict';

var PlainValue = require('./PlainValue-ec8e588e.js');

class BlankLine extends PlainValue.Node ***REMOVED***
  constructor() ***REMOVED***
    super(PlainValue.Type.BLANK_LINE);
***REMOVED***
  /* istanbul ignore next */


  get includesTrailingLines() ***REMOVED***
    // This is never called from anywhere, but if it were,
    // this is the value it should return.
    return true;
***REMOVED***
  /**
   * Parses a blank line from the source
   *
   * @param ***REMOVED***ParseContext***REMOVED*** context
   * @param ***REMOVED***number***REMOVED*** start - Index of first \n character
   * @returns ***REMOVED***number***REMOVED*** - Index of the character after this
   */


  parse(context, start) ***REMOVED***
    this.context = context;
    this.range = new PlainValue.Range(start, start + 1);
    return start + 1;
***REMOVED***

***REMOVED***

class CollectionItem extends PlainValue.Node ***REMOVED***
  constructor(type, props) ***REMOVED***
    super(type, props);
    this.node = null;
***REMOVED***

  get includesTrailingLines() ***REMOVED***
    return !!this.node && this.node.includesTrailingLines;
***REMOVED***
  /**
   * @param ***REMOVED***ParseContext***REMOVED*** context
   * @param ***REMOVED***number***REMOVED*** start - Index of first character
   * @returns ***REMOVED***number***REMOVED*** - Index of the character after this
   */


  parse(context, start) ***REMOVED***
    this.context = context;
    const ***REMOVED***
      parseNode,
      src
***REMOVED*** = context;
    let ***REMOVED***
      atLineStart,
      lineStart
***REMOVED*** = context;
    if (!atLineStart && this.type === PlainValue.Type.SEQ_ITEM) this.error = new PlainValue.YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');
    const indent = atLineStart ? start - lineStart : context.indent;
    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);
    let ch = src[offset];
    const inlineComment = ch === '#';
    const comments = [];
    let blankLine = null;

    while (ch === '\n' || ch === '#') ***REMOVED***
      if (ch === '#') ***REMOVED***
        const end = PlainValue.Node.endOfLine(src, offset + 1);
        comments.push(new PlainValue.Range(offset, end));
        offset = end;
  ***REMOVED*** else ***REMOVED***
        atLineStart = true;
        lineStart = offset + 1;
        const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);

        if (src[wsEnd] === '\n' && comments.length === 0) ***REMOVED***
          blankLine = new BlankLine();
          lineStart = blankLine.parse(***REMOVED***
            src
      ***REMOVED***, lineStart);
    ***REMOVED***

        offset = PlainValue.Node.endOfIndent(src, lineStart);
  ***REMOVED***

      ch = src[offset];
***REMOVED***

    if (PlainValue.Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== PlainValue.Type.SEQ_ITEM)) ***REMOVED***
      this.node = parseNode(***REMOVED***
        atLineStart,
        inCollection: false,
        indent,
        lineStart,
        parent: this
  ***REMOVED***, offset);
***REMOVED*** else if (ch && lineStart > start + 1) ***REMOVED***
      offset = lineStart - 1;
***REMOVED***

    if (this.node) ***REMOVED***
      if (blankLine) ***REMOVED***
        // Only blank lines preceding non-empty nodes are captured. Note that
        // this means that collection item range start indices do not always
        // increase monotonically. -- eemeli/yaml#126
        const items = context.parent.items || context.parent.contents;
        if (items) items.push(blankLine);
  ***REMOVED***

      if (comments.length) Array.prototype.push.apply(this.props, comments);
      offset = this.node.range.end;
***REMOVED*** else ***REMOVED***
      if (inlineComment) ***REMOVED***
        const c = comments[0];
        this.props.push(c);
        offset = c.end;
  ***REMOVED*** else ***REMOVED***
        offset = PlainValue.Node.endOfLine(src, start + 1);
  ***REMOVED***
***REMOVED***

    const end = this.node ? this.node.valueRange.end : offset;
    this.valueRange = new PlainValue.Range(start, end);
    return offset;
***REMOVED***

  setOrigRanges(cr, offset) ***REMOVED***
    offset = super.setOrigRanges(cr, offset);
    return this.node ? this.node.setOrigRanges(cr, offset) : offset;
***REMOVED***

  toString() ***REMOVED***
    const ***REMOVED***
      context: ***REMOVED***
        src
  ***REMOVED***,
      node,
      range,
      value
***REMOVED*** = this;
    if (value != null) return value;
    const str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);
    return PlainValue.Node.addStringTerminator(src, range.end, str);
***REMOVED***

***REMOVED***

class Comment extends PlainValue.Node ***REMOVED***
  constructor() ***REMOVED***
    super(PlainValue.Type.COMMENT);
***REMOVED***
  /**
   * Parses a comment line from the source
   *
   * @param ***REMOVED***ParseContext***REMOVED*** context
   * @param ***REMOVED***number***REMOVED*** start - Index of first character
   * @returns ***REMOVED***number***REMOVED*** - Index of the character after this scalar
   */


  parse(context, start) ***REMOVED***
    this.context = context;
    const offset = this.parseComment(start);
    this.range = new PlainValue.Range(start, offset);
    return offset;
***REMOVED***

***REMOVED***

function grabCollectionEndComments(node) ***REMOVED***
  let cnode = node;

  while (cnode instanceof CollectionItem) cnode = cnode.node;

  if (!(cnode instanceof Collection)) return null;
  const len = cnode.items.length;
  let ci = -1;

  for (let i = len - 1; i >= 0; --i) ***REMOVED***
    const n = cnode.items[i];

    if (n.type === PlainValue.Type.COMMENT) ***REMOVED***
      // Keep sufficiently indented comments with preceding node
      const ***REMOVED***
        indent,
        lineStart
  ***REMOVED*** = n.context;
      if (indent > 0 && n.range.start >= lineStart + indent) break;
      ci = i;
***REMOVED*** else if (n.type === PlainValue.Type.BLANK_LINE) ci = i;else break;
***REMOVED***

  if (ci === -1) return null;
  const ca = cnode.items.splice(ci, len - ci);
  const prevEnd = ca[0].range.start;

  while (true) ***REMOVED***
    cnode.range.end = prevEnd;
    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;
    if (cnode === node) break;
    cnode = cnode.context.parent;
***REMOVED***

  return ca;
***REMOVED***
class Collection extends PlainValue.Node ***REMOVED***
  static nextContentHasIndent(src, offset, indent) ***REMOVED***
    const lineStart = PlainValue.Node.endOfLine(src, offset) + 1;
    offset = PlainValue.Node.endOfWhiteSpace(src, lineStart);
    const ch = src[offset];
    if (!ch) return false;
    if (offset >= lineStart + indent) return true;
    if (ch !== '#' && ch !== '\n') return false;
    return Collection.nextContentHasIndent(src, offset, indent);
***REMOVED***

  constructor(firstItem) ***REMOVED***
    super(firstItem.type === PlainValue.Type.SEQ_ITEM ? PlainValue.Type.SEQ : PlainValue.Type.MAP);

    for (let i = firstItem.props.length - 1; i >= 0; --i) ***REMOVED***
      if (firstItem.props[i].start < firstItem.context.lineStart) ***REMOVED***
        // props on previous line are assumed by the collection
        this.props = firstItem.props.slice(0, i + 1);
        firstItem.props = firstItem.props.slice(i + 1);
        const itemRange = firstItem.props[0] || firstItem.valueRange;
        firstItem.range.start = itemRange.start;
        break;
  ***REMOVED***
***REMOVED***

    this.items = [firstItem];
    const ec = grabCollectionEndComments(firstItem);
    if (ec) Array.prototype.push.apply(this.items, ec);
***REMOVED***

  get includesTrailingLines() ***REMOVED***
    return this.items.length > 0;
***REMOVED***
  /**
   * @param ***REMOVED***ParseContext***REMOVED*** context
   * @param ***REMOVED***number***REMOVED*** start - Index of first character
   * @returns ***REMOVED***number***REMOVED*** - Index of the character after this
   */


  parse(context, start) ***REMOVED***
    this.context = context;
    const ***REMOVED***
      parseNode,
      src
***REMOVED*** = context; // It's easier to recalculate lineStart here rather than tracking down the
    // last context from which to read it -- eemeli/yaml#2

    let lineStart = PlainValue.Node.startOfLine(src, start);
    const firstItem = this.items[0]; // First-item context needs to be correct for later comment handling
    // -- eemeli/yaml#17

    firstItem.context.parent = this;
    this.valueRange = PlainValue.Range.copy(firstItem.valueRange);
    const indent = firstItem.range.start - firstItem.context.lineStart;
    let offset = start;
    offset = PlainValue.Node.normalizeOffset(src, offset);
    let ch = src[offset];
    let atLineStart = PlainValue.Node.endOfWhiteSpace(src, lineStart) === offset;
    let prevIncludesTrailingLines = false;

    while (ch) ***REMOVED***
      while (ch === '\n' || ch === '#') ***REMOVED***
        if (atLineStart && ch === '\n' && !prevIncludesTrailingLines) ***REMOVED***
          const blankLine = new BlankLine();
          offset = blankLine.parse(***REMOVED***
            src
      ***REMOVED***, offset);
          this.valueRange.end = offset;

          if (offset >= src.length) ***REMOVED***
            ch = null;
            break;
      ***REMOVED***

          this.items.push(blankLine);
          offset -= 1; // blankLine.parse() consumes terminal newline
    ***REMOVED*** else if (ch === '#') ***REMOVED***
          if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) ***REMOVED***
            return offset;
      ***REMOVED***

          const comment = new Comment();
          offset = comment.parse(***REMOVED***
            indent,
            lineStart,
            src
      ***REMOVED***, offset);
          this.items.push(comment);
          this.valueRange.end = offset;

          if (offset >= src.length) ***REMOVED***
            ch = null;
            break;
      ***REMOVED***
    ***REMOVED***

        lineStart = offset + 1;
        offset = PlainValue.Node.endOfIndent(src, lineStart);

        if (PlainValue.Node.atBlank(src, offset)) ***REMOVED***
          const wsEnd = PlainValue.Node.endOfWhiteSpace(src, offset);
          const next = src[wsEnd];

          if (!next || next === '\n' || next === '#') ***REMOVED***
            offset = wsEnd;
      ***REMOVED***
    ***REMOVED***

        ch = src[offset];
        atLineStart = true;
  ***REMOVED***

      if (!ch) ***REMOVED***
        break;
  ***REMOVED***

      if (offset !== lineStart + indent && (atLineStart || ch !== ':')) ***REMOVED***
        if (offset < lineStart + indent) ***REMOVED***
          if (lineStart > start) offset = lineStart;
          break;
    ***REMOVED*** else if (!this.error) ***REMOVED***
          const msg = 'All collection items must start at the same column';
          this.error = new PlainValue.YAMLSyntaxError(this, msg);
    ***REMOVED***
  ***REMOVED***

      if (firstItem.type === PlainValue.Type.SEQ_ITEM) ***REMOVED***
        if (ch !== '-') ***REMOVED***
          if (lineStart > start) offset = lineStart;
          break;
    ***REMOVED***
  ***REMOVED*** else if (ch === '-' && !this.error) ***REMOVED***
        // map key may start with -, as long as it's followed by a non-whitespace char
        const next = src[offset + 1];

        if (!next || next === '\n' || next === '\t' || next === ' ') ***REMOVED***
          const msg = 'A collection cannot be both a mapping and a sequence';
          this.error = new PlainValue.YAMLSyntaxError(this, msg);
    ***REMOVED***
  ***REMOVED***

      const node = parseNode(***REMOVED***
        atLineStart,
        inCollection: true,
        indent,
        lineStart,
        parent: this
  ***REMOVED***, offset);
      if (!node) return offset; // at next document start

      this.items.push(node);
      this.valueRange.end = node.valueRange.end;
      offset = PlainValue.Node.normalizeOffset(src, node.range.end);
      ch = src[offset];
      atLineStart = false;
      prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range
      // has advanced to check the current line's indentation level
      // -- eemeli/yaml#10 & eemeli/yaml#38

      if (ch) ***REMOVED***
        let ls = offset - 1;
        let prev = src[ls];

        while (prev === ' ' || prev === '\t') prev = src[--ls];

        if (prev === '\n') ***REMOVED***
          lineStart = ls + 1;
          atLineStart = true;
    ***REMOVED***
  ***REMOVED***

      const ec = grabCollectionEndComments(node);
      if (ec) Array.prototype.push.apply(this.items, ec);
***REMOVED***

    return offset;
***REMOVED***

  setOrigRanges(cr, offset) ***REMOVED***
    offset = super.setOrigRanges(cr, offset);
    this.items.forEach(node => ***REMOVED***
      offset = node.setOrigRanges(cr, offset);
***REMOVED***);
    return offset;
***REMOVED***

  toString() ***REMOVED***
    const ***REMOVED***
      context: ***REMOVED***
        src
  ***REMOVED***,
      items,
      range,
      value
***REMOVED*** = this;
    if (value != null) return value;
    let str = src.slice(range.start, items[0].range.start) + String(items[0]);

    for (let i = 1; i < items.length; ++i) ***REMOVED***
      const item = items[i];
      const ***REMOVED***
        atLineStart,
        indent
  ***REMOVED*** = item.context;
      if (atLineStart) for (let i = 0; i < indent; ++i) str += ' ';
      str += String(item);
***REMOVED***

    return PlainValue.Node.addStringTerminator(src, range.end, str);
***REMOVED***

***REMOVED***

class Directive extends PlainValue.Node ***REMOVED***
  constructor() ***REMOVED***
    super(PlainValue.Type.DIRECTIVE);
    this.name = null;
***REMOVED***

  get parameters() ***REMOVED***
    const raw = this.rawValue;
    return raw ? raw.trim().split(/[ \t]+/) : [];
***REMOVED***

  parseName(start) ***REMOVED***
    const ***REMOVED***
      src
***REMOVED*** = this.context;
    let offset = start;
    let ch = src[offset];

    while (ch && ch !== '\n' && ch !== '\t' && ch !== ' ') ch = src[offset += 1];

    this.name = src.slice(start, offset);
    return offset;
***REMOVED***

  parseParameters(start) ***REMOVED***
    const ***REMOVED***
      src
***REMOVED*** = this.context;
    let offset = start;
    let ch = src[offset];

    while (ch && ch !== '\n' && ch !== '#') ch = src[offset += 1];

    this.valueRange = new PlainValue.Range(start, offset);
    return offset;
***REMOVED***

  parse(context, start) ***REMOVED***
    this.context = context;
    let offset = this.parseName(start + 1);
    offset = this.parseParameters(offset);
    offset = this.parseComment(offset);
    this.range = new PlainValue.Range(start, offset);
    return offset;
***REMOVED***

***REMOVED***

class Document extends PlainValue.Node ***REMOVED***
  static startCommentOrEndBlankLine(src, start) ***REMOVED***
    const offset = PlainValue.Node.endOfWhiteSpace(src, start);
    const ch = src[offset];
    return ch === '#' || ch === '\n' ? offset : start;
***REMOVED***

  constructor() ***REMOVED***
    super(PlainValue.Type.DOCUMENT);
    this.directives = null;
    this.contents = null;
    this.directivesEndMarker = null;
    this.documentEndMarker = null;
***REMOVED***

  parseDirectives(start) ***REMOVED***
    const ***REMOVED***
      src
***REMOVED*** = this.context;
    this.directives = [];
    let atLineStart = true;
    let hasDirectives = false;
    let offset = start;

    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DIRECTIVES_END)) ***REMOVED***
      offset = Document.startCommentOrEndBlankLine(src, offset);

      switch (src[offset]) ***REMOVED***
        case '\n':
          if (atLineStart) ***REMOVED***
            const blankLine = new BlankLine();
            offset = blankLine.parse(***REMOVED***
              src
        ***REMOVED***, offset);

            if (offset < src.length) ***REMOVED***
              this.directives.push(blankLine);
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
            offset += 1;
            atLineStart = true;
      ***REMOVED***

          break;

        case '#':
          ***REMOVED***
            const comment = new Comment();
            offset = comment.parse(***REMOVED***
              src
        ***REMOVED***, offset);
            this.directives.push(comment);
            atLineStart = false;
      ***REMOVED***
          break;

        case '%':
          ***REMOVED***
            const directive = new Directive();
            offset = directive.parse(***REMOVED***
              parent: this,
              src
        ***REMOVED***, offset);
            this.directives.push(directive);
            hasDirectives = true;
            atLineStart = false;
      ***REMOVED***
          break;

        default:
          if (hasDirectives) ***REMOVED***
            this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');
      ***REMOVED*** else if (this.directives.length > 0) ***REMOVED***
            this.contents = this.directives;
            this.directives = [];
      ***REMOVED***

          return offset;
  ***REMOVED***
***REMOVED***

    if (src[offset]) ***REMOVED***
      this.directivesEndMarker = new PlainValue.Range(offset, offset + 3);
      return offset + 3;
***REMOVED***

    if (hasDirectives) ***REMOVED***
      this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');
***REMOVED*** else if (this.directives.length > 0) ***REMOVED***
      this.contents = this.directives;
      this.directives = [];
***REMOVED***

    return offset;
***REMOVED***

  parseContents(start) ***REMOVED***
    const ***REMOVED***
      parseNode,
      src
***REMOVED*** = this.context;
    if (!this.contents) this.contents = [];
    let lineStart = start;

    while (src[lineStart - 1] === '-') lineStart -= 1;

    let offset = PlainValue.Node.endOfWhiteSpace(src, start);
    let atLineStart = lineStart === start;
    this.valueRange = new PlainValue.Range(offset);

    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DOCUMENT_END)) ***REMOVED***
      switch (src[offset]) ***REMOVED***
        case '\n':
          if (atLineStart) ***REMOVED***
            const blankLine = new BlankLine();
            offset = blankLine.parse(***REMOVED***
              src
        ***REMOVED***, offset);

            if (offset < src.length) ***REMOVED***
              this.contents.push(blankLine);
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
            offset += 1;
            atLineStart = true;
      ***REMOVED***

          lineStart = offset;
          break;

        case '#':
          ***REMOVED***
            const comment = new Comment();
            offset = comment.parse(***REMOVED***
              src
        ***REMOVED***, offset);
            this.contents.push(comment);
            atLineStart = false;
      ***REMOVED***
          break;

        default:
          ***REMOVED***
            const iEnd = PlainValue.Node.endOfIndent(src, offset);
            const context = ***REMOVED***
              atLineStart,
              indent: -1,
              inFlow: false,
              inCollection: false,
              lineStart,
              parent: this
        ***REMOVED***;
            const node = parseNode(context, iEnd);
            if (!node) return this.valueRange.end = iEnd; // at next document start

            this.contents.push(node);
            offset = node.range.end;
            atLineStart = false;
            const ec = grabCollectionEndComments(node);
            if (ec) Array.prototype.push.apply(this.contents, ec);
      ***REMOVED***
  ***REMOVED***

      offset = Document.startCommentOrEndBlankLine(src, offset);
***REMOVED***

    this.valueRange.end = offset;

    if (src[offset]) ***REMOVED***
      this.documentEndMarker = new PlainValue.Range(offset, offset + 3);
      offset += 3;

      if (src[offset]) ***REMOVED***
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);

        if (src[offset] === '#') ***REMOVED***
          const comment = new Comment();
          offset = comment.parse(***REMOVED***
            src
      ***REMOVED***, offset);
          this.contents.push(comment);
    ***REMOVED***

        switch (src[offset]) ***REMOVED***
          case '\n':
            offset += 1;
            break;

          case undefined:
            break;

          default:
            this.error = new PlainValue.YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');
    ***REMOVED***
  ***REMOVED***
***REMOVED***

    return offset;
***REMOVED***
  /**
   * @param ***REMOVED***ParseContext***REMOVED*** context
   * @param ***REMOVED***number***REMOVED*** start - Index of first character
   * @returns ***REMOVED***number***REMOVED*** - Index of the character after this
   */


  parse(context, start) ***REMOVED***
    context.root = this;
    this.context = context;
    const ***REMOVED***
      src
***REMOVED*** = context;
    let offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM

    offset = this.parseDirectives(offset);
    offset = this.parseContents(offset);
    return offset;
***REMOVED***

  setOrigRanges(cr, offset) ***REMOVED***
    offset = super.setOrigRanges(cr, offset);
    this.directives.forEach(node => ***REMOVED***
      offset = node.setOrigRanges(cr, offset);
***REMOVED***);
    if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);
    this.contents.forEach(node => ***REMOVED***
      offset = node.setOrigRanges(cr, offset);
***REMOVED***);
    if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);
    return offset;
***REMOVED***

  toString() ***REMOVED***
    const ***REMOVED***
      contents,
      directives,
      value
***REMOVED*** = this;
    if (value != null) return value;
    let str = directives.join('');

    if (contents.length > 0) ***REMOVED***
      if (directives.length > 0 || contents[0].type === PlainValue.Type.COMMENT) str += '---\n';
      str += contents.join('');
***REMOVED***

    if (str[str.length - 1] !== '\n') str += '\n';
    return str;
***REMOVED***

***REMOVED***

class Alias extends PlainValue.Node ***REMOVED***
  /**
   * Parses an *alias from the source
   *
   * @param ***REMOVED***ParseContext***REMOVED*** context
   * @param ***REMOVED***number***REMOVED*** start - Index of first character
   * @returns ***REMOVED***number***REMOVED*** - Index of the character after this scalar
   */
  parse(context, start) ***REMOVED***
    this.context = context;
    const ***REMOVED***
      src
***REMOVED*** = context;
    let offset = PlainValue.Node.endOfIdentifier(src, start + 1);
    this.valueRange = new PlainValue.Range(start + 1, offset);
    offset = PlainValue.Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);
    return offset;
***REMOVED***

***REMOVED***

const Chomp = ***REMOVED***
  CLIP: 'CLIP',
  KEEP: 'KEEP',
  STRIP: 'STRIP'
***REMOVED***;
class BlockValue extends PlainValue.Node ***REMOVED***
  constructor(type, props) ***REMOVED***
    super(type, props);
    this.blockIndent = null;
    this.chomping = Chomp.CLIP;
    this.header = null;
***REMOVED***

  get includesTrailingLines() ***REMOVED***
    return this.chomping === Chomp.KEEP;
***REMOVED***

  get strValue() ***REMOVED***
    if (!this.valueRange || !this.context) return null;
    let ***REMOVED***
      start,
      end
***REMOVED*** = this.valueRange;
    const ***REMOVED***
      indent,
      src
***REMOVED*** = this.context;
    if (this.valueRange.isEmpty()) return '';
    let lastNewLine = null;
    let ch = src[end - 1];

    while (ch === '\n' || ch === '\t' || ch === ' ') ***REMOVED***
      end -= 1;

      if (end <= start) ***REMOVED***
        if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens
  ***REMOVED***

      if (ch === '\n') lastNewLine = end;
      ch = src[end - 1];
***REMOVED***

    let keepStart = end + 1;

    if (lastNewLine) ***REMOVED***
      if (this.chomping === Chomp.KEEP) ***REMOVED***
        keepStart = lastNewLine;
        end = this.valueRange.end;
  ***REMOVED*** else ***REMOVED***
        end = lastNewLine;
  ***REMOVED***
***REMOVED***

    const bi = indent + this.blockIndent;
    const folded = this.type === PlainValue.Type.BLOCK_FOLDED;
    let atStart = true;
    let str = '';
    let sep = '';
    let prevMoreIndented = false;

    for (let i = start; i < end; ++i) ***REMOVED***
      for (let j = 0; j < bi; ++j) ***REMOVED***
        if (src[i] !== ' ') break;
        i += 1;
  ***REMOVED***

      const ch = src[i];

      if (ch === '\n') ***REMOVED***
        if (sep === '\n') str += '\n';else sep = '\n';
  ***REMOVED*** else ***REMOVED***
        const lineEnd = PlainValue.Node.endOfLine(src, i);
        const line = src.slice(i, lineEnd);
        i = lineEnd;

        if (folded && (ch === ' ' || ch === '\t') && i < keepStart) ***REMOVED***
          if (sep === ' ') sep = '\n';else if (!prevMoreIndented && !atStart && sep === '\n') sep = '\n\n';
          str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')

          sep = lineEnd < end && src[lineEnd] || '';
          prevMoreIndented = true;
    ***REMOVED*** else ***REMOVED***
          str += sep + line;
          sep = folded && i < keepStart ? ' ' : '\n';
          prevMoreIndented = false;
    ***REMOVED***

        if (atStart && line !== '') atStart = false;
  ***REMOVED***
***REMOVED***

    return this.chomping === Chomp.STRIP ? str : str + '\n';
***REMOVED***

  parseBlockHeader(start) ***REMOVED***
    const ***REMOVED***
      src
***REMOVED*** = this.context;
    let offset = start + 1;
    let bi = '';

    while (true) ***REMOVED***
      const ch = src[offset];

      switch (ch) ***REMOVED***
        case '-':
          this.chomping = Chomp.STRIP;
          break;

        case '+':
          this.chomping = Chomp.KEEP;
          break;

        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          bi += ch;
          break;

        default:
          this.blockIndent = Number(bi) || null;
          this.header = new PlainValue.Range(start, offset);
          return offset;
  ***REMOVED***

      offset += 1;
***REMOVED***
***REMOVED***

  parseBlockValue(start) ***REMOVED***
    const ***REMOVED***
      indent,
      src
***REMOVED*** = this.context;
    const explicit = !!this.blockIndent;
    let offset = start;
    let valueEnd = start;
    let minBlockIndent = 1;

    for (let ch = src[offset]; ch === '\n'; ch = src[offset]) ***REMOVED***
      offset += 1;
      if (PlainValue.Node.atDocumentBoundary(src, offset)) break;
      const end = PlainValue.Node.endOfBlockIndent(src, indent, offset); // should not include tab?

      if (end === null) break;
      const ch = src[end];
      const lineIndent = end - (offset + indent);

      if (!this.blockIndent) ***REMOVED***
        // no explicit block indent, none yet detected
        if (src[end] !== '\n') ***REMOVED***
          // first line with non-whitespace content
          if (lineIndent < minBlockIndent) ***REMOVED***
            const msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';
            this.error = new PlainValue.YAMLSemanticError(this, msg);
      ***REMOVED***

          this.blockIndent = lineIndent;
    ***REMOVED*** else if (lineIndent > minBlockIndent) ***REMOVED***
          // empty line with more whitespace
          minBlockIndent = lineIndent;
    ***REMOVED***
  ***REMOVED*** else if (ch && ch !== '\n' && lineIndent < this.blockIndent) ***REMOVED***
        if (src[end] === '#') break;

        if (!this.error) ***REMOVED***
          const src = explicit ? 'explicit indentation indicator' : 'first line';
          const msg = `Block scalars must not be less indented than their $***REMOVED***src***REMOVED***`;
          this.error = new PlainValue.YAMLSemanticError(this, msg);
    ***REMOVED***
  ***REMOVED***

      if (src[end] === '\n') ***REMOVED***
        offset = end;
  ***REMOVED*** else ***REMOVED***
        offset = valueEnd = PlainValue.Node.endOfLine(src, end);
  ***REMOVED***
***REMOVED***

    if (this.chomping !== Chomp.KEEP) ***REMOVED***
      offset = src[valueEnd] ? valueEnd + 1 : valueEnd;
***REMOVED***

    this.valueRange = new PlainValue.Range(start + 1, offset);
    return offset;
***REMOVED***
  /**
   * Parses a block value from the source
   *
   * Accepted forms are:
   * ```
   * BS
   * block
   * lines
   *
   * BS #comment
   * block
   * lines
   * ```
   * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines
   * are empty or have an indent level greater than `indent`.
   *
   * @param ***REMOVED***ParseContext***REMOVED*** context
   * @param ***REMOVED***number***REMOVED*** start - Index of first character
   * @returns ***REMOVED***number***REMOVED*** - Index of the character after this block
   */


  parse(context, start) ***REMOVED***
    this.context = context;
    const ***REMOVED***
      src
***REMOVED*** = context;
    let offset = this.parseBlockHeader(start);
    offset = PlainValue.Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);
    offset = this.parseBlockValue(offset);
    return offset;
***REMOVED***

  setOrigRanges(cr, offset) ***REMOVED***
    offset = super.setOrigRanges(cr, offset);
    return this.header ? this.header.setOrigRange(cr, offset) : offset;
***REMOVED***

***REMOVED***

class FlowCollection extends PlainValue.Node ***REMOVED***
  constructor(type, props) ***REMOVED***
    super(type, props);
    this.items = null;
***REMOVED***

  prevNodeIsJsonLike(idx = this.items.length) ***REMOVED***
    const node = this.items[idx - 1];
    return !!node && (node.jsonLike || node.type === PlainValue.Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));
***REMOVED***
  /**
   * @param ***REMOVED***ParseContext***REMOVED*** context
   * @param ***REMOVED***number***REMOVED*** start - Index of first character
   * @returns ***REMOVED***number***REMOVED*** - Index of the character after this
   */


  parse(context, start) ***REMOVED***
    this.context = context;
    const ***REMOVED***
      parseNode,
      src
***REMOVED*** = context;
    let ***REMOVED***
      indent,
      lineStart
***REMOVED*** = context;
    let char = src[start]; // ***REMOVED*** or [

    this.items = [***REMOVED***
      char,
      offset: start
***REMOVED***];
    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);
    char = src[offset];

    while (char && char !== ']' && char !== '***REMOVED***') ***REMOVED***
      switch (char) ***REMOVED***
        case '\n':
          ***REMOVED***
            lineStart = offset + 1;
            const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);

            if (src[wsEnd] === '\n') ***REMOVED***
              const blankLine = new BlankLine();
              lineStart = blankLine.parse(***REMOVED***
                src
          ***REMOVED***, lineStart);
              this.items.push(blankLine);
        ***REMOVED***

            offset = PlainValue.Node.endOfIndent(src, lineStart);

            if (offset <= lineStart + indent) ***REMOVED***
              char = src[offset];

              if (offset < lineStart + indent || char !== ']' && char !== '***REMOVED***') ***REMOVED***
                const msg = 'Insufficient indentation in flow collection';
                this.error = new PlainValue.YAMLSemanticError(this, msg);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
          break;

        case ',':
          ***REMOVED***
            this.items.push(***REMOVED***
              char,
              offset
        ***REMOVED***);
            offset += 1;
      ***REMOVED***
          break;

        case '#':
          ***REMOVED***
            const comment = new Comment();
            offset = comment.parse(***REMOVED***
              src
        ***REMOVED***, offset);
            this.items.push(comment);
      ***REMOVED***
          break;

        case '?':
        case ':':
          ***REMOVED***
            const next = src[offset + 1];

            if (next === '\n' || next === '\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace
            char === ':' && this.prevNodeIsJsonLike()) ***REMOVED***
              this.items.push(***REMOVED***
                char,
                offset
          ***REMOVED***);
              offset += 1;
              break;
        ***REMOVED***
      ***REMOVED***
        // fallthrough

        default:
          ***REMOVED***
            const node = parseNode(***REMOVED***
              atLineStart: false,
              inCollection: false,
              inFlow: true,
              indent: -1,
              lineStart,
              parent: this
        ***REMOVED***, offset);

            if (!node) ***REMOVED***
              // at next document start
              this.valueRange = new PlainValue.Range(start, offset);
              return offset;
        ***REMOVED***

            this.items.push(node);
            offset = PlainValue.Node.normalizeOffset(src, node.range.end);
      ***REMOVED***
  ***REMOVED***

      offset = PlainValue.Node.endOfWhiteSpace(src, offset);
      char = src[offset];
***REMOVED***

    this.valueRange = new PlainValue.Range(start, offset + 1);

    if (char) ***REMOVED***
      this.items.push(***REMOVED***
        char,
        offset
  ***REMOVED***);
      offset = PlainValue.Node.endOfWhiteSpace(src, offset + 1);
      offset = this.parseComment(offset);
***REMOVED***

    return offset;
***REMOVED***

  setOrigRanges(cr, offset) ***REMOVED***
    offset = super.setOrigRanges(cr, offset);
    this.items.forEach(node => ***REMOVED***
      if (node instanceof PlainValue.Node) ***REMOVED***
        offset = node.setOrigRanges(cr, offset);
  ***REMOVED*** else if (cr.length === 0) ***REMOVED***
        node.origOffset = node.offset;
  ***REMOVED*** else ***REMOVED***
        let i = offset;

        while (i < cr.length) ***REMOVED***
          if (cr[i] > node.offset) break;else ++i;
    ***REMOVED***

        node.origOffset = node.offset + i;
        offset = i;
  ***REMOVED***
***REMOVED***);
    return offset;
***REMOVED***

  toString() ***REMOVED***
    const ***REMOVED***
      context: ***REMOVED***
        src
  ***REMOVED***,
      items,
      range,
      value
***REMOVED*** = this;
    if (value != null) return value;
    const nodes = items.filter(item => item instanceof PlainValue.Node);
    let str = '';
    let prevEnd = range.start;
    nodes.forEach(node => ***REMOVED***
      const prefix = src.slice(prevEnd, node.range.start);
      prevEnd = node.range.end;
      str += prefix + String(node);

      if (str[str.length - 1] === '\n' && src[prevEnd - 1] !== '\n' && src[prevEnd] === '\n') ***REMOVED***
        // Comment range does not include the terminal newline, but its
        // stringified value does. Without this fix, newlines at comment ends
        // get duplicated.
        prevEnd += 1;
  ***REMOVED***
***REMOVED***);
    str += src.slice(prevEnd, range.end);
    return PlainValue.Node.addStringTerminator(src, range.end, str);
***REMOVED***

***REMOVED***

class QuoteDouble extends PlainValue.Node ***REMOVED***
  static endOfQuote(src, offset) ***REMOVED***
    let ch = src[offset];

    while (ch && ch !== '"') ***REMOVED***
      offset += ch === '\\' ? 2 : 1;
      ch = src[offset];
***REMOVED***

    return offset + 1;
***REMOVED***
  /**
   * @returns ***REMOVED***string | ***REMOVED*** str: string, errors: YAMLSyntaxError[] ***REMOVED******REMOVED***
   */


  get strValue() ***REMOVED***
    if (!this.valueRange || !this.context) return null;
    const errors = [];
    const ***REMOVED***
      start,
      end
***REMOVED*** = this.valueRange;
    const ***REMOVED***
      indent,
      src
***REMOVED*** = this.context;
    if (src[end - 1] !== '"') errors.push(new PlainValue.YAMLSyntaxError(this, 'Missing closing "quote')); // Using String#replace is too painful with escaped newlines preceded by
    // escaped backslashes; also, this should be faster.

    let str = '';

    for (let i = start + 1; i < end - 1; ++i) ***REMOVED***
      const ch = src[i];

      if (ch === '\n') ***REMOVED***
        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));
        const ***REMOVED***
          fold,
          offset,
          error
    ***REMOVED*** = PlainValue.Node.foldNewline(src, i, indent);
        str += fold;
        i = offset;
        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));
  ***REMOVED*** else if (ch === '\\') ***REMOVED***
        i += 1;

        switch (src[i]) ***REMOVED***
          case '0':
            str += '\0';
            break;
          // null character

          case 'a':
            str += '\x07';
            break;
          // bell character

          case 'b':
            str += '\b';
            break;
          // backspace

          case 'e':
            str += '\x1b';
            break;
          // escape character

          case 'f':
            str += '\f';
            break;
          // form feed

          case 'n':
            str += '\n';
            break;
          // line feed

          case 'r':
            str += '\r';
            break;
          // carriage return

          case 't':
            str += '\t';
            break;
          // horizontal tab

          case 'v':
            str += '\v';
            break;
          // vertical tab

          case 'N':
            str += '\u0085';
            break;
          // Unicode next line

          case '_':
            str += '\u00a0';
            break;
          // Unicode non-breaking space

          case 'L':
            str += '\u2028';
            break;
          // Unicode line separator

          case 'P':
            str += '\u2029';
            break;
          // Unicode paragraph separator

          case ' ':
            str += ' ';
            break;

          case '"':
            str += '"';
            break;

          case '/':
            str += '/';
            break;

          case '\\':
            str += '\\';
            break;

          case '\t':
            str += '\t';
            break;

          case 'x':
            str += this.parseCharCode(i + 1, 2, errors);
            i += 2;
            break;

          case 'u':
            str += this.parseCharCode(i + 1, 4, errors);
            i += 4;
            break;

          case 'U':
            str += this.parseCharCode(i + 1, 8, errors);
            i += 8;
            break;

          case '\n':
            // skip escaped newlines, but still trim the following line
            while (src[i + 1] === ' ' || src[i + 1] === '\t') i += 1;

            break;

          default:
            errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence $***REMOVED***src.substr(i - 1, 2)***REMOVED***`));
            str += '\\' + src[i];
    ***REMOVED***
  ***REMOVED*** else if (ch === ' ' || ch === '\t') ***REMOVED***
        // trim trailing whitespace
        const wsStart = i;
        let next = src[i + 1];

        while (next === ' ' || next === '\t') ***REMOVED***
          i += 1;
          next = src[i + 1];
    ***REMOVED***

        if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
  ***REMOVED*** else ***REMOVED***
        str += ch;
  ***REMOVED***
***REMOVED***

    return errors.length > 0 ? ***REMOVED***
      errors,
      str
***REMOVED*** : str;
***REMOVED***

  parseCharCode(offset, length, errors) ***REMOVED***
    const ***REMOVED***
      src
***REMOVED*** = this.context;
    const cc = src.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;

    if (isNaN(code)) ***REMOVED***
      errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence $***REMOVED***src.substr(offset - 2, length + 2)***REMOVED***`));
      return src.substr(offset - 2, length + 2);
***REMOVED***

    return String.fromCodePoint(code);
***REMOVED***
  /**
   * Parses a "double quoted" value from the source
   *
   * @param ***REMOVED***ParseContext***REMOVED*** context
   * @param ***REMOVED***number***REMOVED*** start - Index of first character
   * @returns ***REMOVED***number***REMOVED*** - Index of the character after this scalar
   */


  parse(context, start) ***REMOVED***
    this.context = context;
    const ***REMOVED***
      src
***REMOVED*** = context;
    let offset = QuoteDouble.endOfQuote(src, start + 1);
    this.valueRange = new PlainValue.Range(start, offset);
    offset = PlainValue.Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);
    return offset;
***REMOVED***

***REMOVED***

class QuoteSingle extends PlainValue.Node ***REMOVED***
  static endOfQuote(src, offset) ***REMOVED***
    let ch = src[offset];

    while (ch) ***REMOVED***
      if (ch === "'") ***REMOVED***
        if (src[offset + 1] !== "'") break;
        ch = src[offset += 2];
  ***REMOVED*** else ***REMOVED***
        ch = src[offset += 1];
  ***REMOVED***
***REMOVED***

    return offset + 1;
***REMOVED***
  /**
   * @returns ***REMOVED***string | ***REMOVED*** str: string, errors: YAMLSyntaxError[] ***REMOVED******REMOVED***
   */


  get strValue() ***REMOVED***
    if (!this.valueRange || !this.context) return null;
    const errors = [];
    const ***REMOVED***
      start,
      end
***REMOVED*** = this.valueRange;
    const ***REMOVED***
      indent,
      src
***REMOVED*** = this.context;
    if (src[end - 1] !== "'") errors.push(new PlainValue.YAMLSyntaxError(this, "Missing closing 'quote"));
    let str = '';

    for (let i = start + 1; i < end - 1; ++i) ***REMOVED***
      const ch = src[i];

      if (ch === '\n') ***REMOVED***
        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));
        const ***REMOVED***
          fold,
          offset,
          error
    ***REMOVED*** = PlainValue.Node.foldNewline(src, i, indent);
        str += fold;
        i = offset;
        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));
  ***REMOVED*** else if (ch === "'") ***REMOVED***
        str += ch;
        i += 1;
        if (src[i] !== "'") errors.push(new PlainValue.YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));
  ***REMOVED*** else if (ch === ' ' || ch === '\t') ***REMOVED***
        // trim trailing whitespace
        const wsStart = i;
        let next = src[i + 1];

        while (next === ' ' || next === '\t') ***REMOVED***
          i += 1;
          next = src[i + 1];
    ***REMOVED***

        if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
  ***REMOVED*** else ***REMOVED***
        str += ch;
  ***REMOVED***
***REMOVED***

    return errors.length > 0 ? ***REMOVED***
      errors,
      str
***REMOVED*** : str;
***REMOVED***
  /**
   * Parses a 'single quoted' value from the source
   *
   * @param ***REMOVED***ParseContext***REMOVED*** context
   * @param ***REMOVED***number***REMOVED*** start - Index of first character
   * @returns ***REMOVED***number***REMOVED*** - Index of the character after this scalar
   */


  parse(context, start) ***REMOVED***
    this.context = context;
    const ***REMOVED***
      src
***REMOVED*** = context;
    let offset = QuoteSingle.endOfQuote(src, start + 1);
    this.valueRange = new PlainValue.Range(start, offset);
    offset = PlainValue.Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);
    return offset;
***REMOVED***

***REMOVED***

function createNewNode(type, props) ***REMOVED***
  switch (type) ***REMOVED***
    case PlainValue.Type.ALIAS:
      return new Alias(type, props);

    case PlainValue.Type.BLOCK_FOLDED:
    case PlainValue.Type.BLOCK_LITERAL:
      return new BlockValue(type, props);

    case PlainValue.Type.FLOW_MAP:
    case PlainValue.Type.FLOW_SEQ:
      return new FlowCollection(type, props);

    case PlainValue.Type.MAP_KEY:
    case PlainValue.Type.MAP_VALUE:
    case PlainValue.Type.SEQ_ITEM:
      return new CollectionItem(type, props);

    case PlainValue.Type.COMMENT:
    case PlainValue.Type.PLAIN:
      return new PlainValue.PlainValue(type, props);

    case PlainValue.Type.QUOTE_DOUBLE:
      return new QuoteDouble(type, props);

    case PlainValue.Type.QUOTE_SINGLE:
      return new QuoteSingle(type, props);

    /* istanbul ignore next */

    default:
      return null;
    // should never happen
***REMOVED***
***REMOVED***
/**
 * @param ***REMOVED***boolean***REMOVED*** atLineStart - Node starts at beginning of line
 * @param ***REMOVED***boolean***REMOVED*** inFlow - true if currently in a flow context
 * @param ***REMOVED***boolean***REMOVED*** inCollection - true if currently in a collection context
 * @param ***REMOVED***number***REMOVED*** indent - Current level of indentation
 * @param ***REMOVED***number***REMOVED*** lineStart - Start of the current line
 * @param ***REMOVED***Node***REMOVED*** parent - The parent of the node
 * @param ***REMOVED***string***REMOVED*** src - Source of the YAML document
 */


class ParseContext ***REMOVED***
  static parseType(src, offset, inFlow) ***REMOVED***
    switch (src[offset]) ***REMOVED***
      case '*':
        return PlainValue.Type.ALIAS;

      case '>':
        return PlainValue.Type.BLOCK_FOLDED;

      case '|':
        return PlainValue.Type.BLOCK_LITERAL;

      case '***REMOVED***':
        return PlainValue.Type.FLOW_MAP;

      case '[':
        return PlainValue.Type.FLOW_SEQ;

      case '?':
        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_KEY : PlainValue.Type.PLAIN;

      case ':':
        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_VALUE : PlainValue.Type.PLAIN;

      case '-':
        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.SEQ_ITEM : PlainValue.Type.PLAIN;

      case '"':
        return PlainValue.Type.QUOTE_DOUBLE;

      case "'":
        return PlainValue.Type.QUOTE_SINGLE;

      default:
        return PlainValue.Type.PLAIN;
***REMOVED***
***REMOVED***

  constructor(orig = ***REMOVED******REMOVED***, ***REMOVED***
    atLineStart,
    inCollection,
    inFlow,
    indent,
    lineStart,
    parent
***REMOVED*** = ***REMOVED******REMOVED***) ***REMOVED***
    PlainValue._defineProperty(this, "parseNode", (overlay, start) => ***REMOVED***
      if (PlainValue.Node.atDocumentBoundary(this.src, start)) return null;
      const context = new ParseContext(this, overlay);
      const ***REMOVED***
        props,
        type,
        valueStart
  ***REMOVED*** = context.parseProps(start);
      const node = createNewNode(type, props);
      let offset = node.parse(context, valueStart);
      node.range = new PlainValue.Range(start, offset);
      /* istanbul ignore if */

      if (offset <= start) ***REMOVED***
        // This should never happen, but if it does, let's make sure to at least
        // step one character forward to avoid a busy loop.
        node.error = new Error(`Node#parse consumed no characters`);
        node.error.parseEnd = offset;
        node.error.source = node;
        node.range.end = start + 1;
  ***REMOVED***

      if (context.nodeStartsCollection(node)) ***REMOVED***
        if (!node.error && !context.atLineStart && context.parent.type === PlainValue.Type.DOCUMENT) ***REMOVED***
          node.error = new PlainValue.YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');
    ***REMOVED***

        const collection = new Collection(node);
        offset = collection.parse(new ParseContext(context), offset);
        collection.range = new PlainValue.Range(start, offset);
        return collection;
  ***REMOVED***

      return node;
***REMOVED***);

    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;
    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;
    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;
    this.indent = indent != null ? indent : orig.indent;
    this.lineStart = lineStart != null ? lineStart : orig.lineStart;
    this.parent = parent != null ? parent : orig.parent || ***REMOVED******REMOVED***;
    this.root = orig.root;
    this.src = orig.src;
***REMOVED***

  nodeStartsCollection(node) ***REMOVED***
    const ***REMOVED***
      inCollection,
      inFlow,
      src
***REMOVED*** = this;
    if (inCollection || inFlow) return false;
    if (node instanceof CollectionItem) return true; // check for implicit key

    let offset = node.range.end;
    if (src[offset] === '\n' || src[offset - 1] === '\n') return false;
    offset = PlainValue.Node.endOfWhiteSpace(src, offset);
    return src[offset] === ':';
***REMOVED*** // Anchor and tag are before type, which determines the node implementation
  // class; hence this intermediate step.


  parseProps(offset) ***REMOVED***
    const ***REMOVED***
      inFlow,
      parent,
      src
***REMOVED*** = this;
    const props = [];
    let lineHasProps = false;
    offset = this.atLineStart ? PlainValue.Node.endOfIndent(src, offset) : PlainValue.Node.endOfWhiteSpace(src, offset);
    let ch = src[offset];

    while (ch === PlainValue.Char.ANCHOR || ch === PlainValue.Char.COMMENT || ch === PlainValue.Char.TAG || ch === '\n') ***REMOVED***
      if (ch === '\n') ***REMOVED***
        let inEnd = offset;
        let lineStart;

        do ***REMOVED***
          lineStart = inEnd + 1;
          inEnd = PlainValue.Node.endOfIndent(src, lineStart);
    ***REMOVED*** while (src[inEnd] === '\n');

        const indentDiff = inEnd - (lineStart + this.indent);
        const noIndicatorAsIndent = parent.type === PlainValue.Type.SEQ_ITEM && parent.context.atLineStart;
        if (src[inEnd] !== '#' && !PlainValue.Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;
        this.atLineStart = true;
        this.lineStart = lineStart;
        lineHasProps = false;
        offset = inEnd;
  ***REMOVED*** else if (ch === PlainValue.Char.COMMENT) ***REMOVED***
        const end = PlainValue.Node.endOfLine(src, offset + 1);
        props.push(new PlainValue.Range(offset, end));
        offset = end;
  ***REMOVED*** else ***REMOVED***
        let end = PlainValue.Node.endOfIdentifier(src, offset + 1);

        if (ch === PlainValue.Char.TAG && src[end] === ',' && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d)***REMOVED***0,2***REMOVED***\/\S/.test(src.slice(offset + 1, end + 13))) ***REMOVED***
          // Let's presume we're dealing with a YAML 1.0 domain tag here, rather
          // than an empty but 'foo.bar' private-tagged node in a flow collection
          // followed without whitespace by a plain string starting with a year
          // or date divided by something.
          end = PlainValue.Node.endOfIdentifier(src, end + 5);
    ***REMOVED***

        props.push(new PlainValue.Range(offset, end));
        lineHasProps = true;
        offset = PlainValue.Node.endOfWhiteSpace(src, end);
  ***REMOVED***

      ch = src[offset];
***REMOVED*** // '- &a : b' has an anchor on an empty node


    if (lineHasProps && ch === ':' && PlainValue.Node.atBlank(src, offset + 1, true)) offset -= 1;
    const type = ParseContext.parseType(src, offset, inFlow);
    return ***REMOVED***
      props,
      type,
      valueStart: offset
***REMOVED***;
***REMOVED***
  /**
   * Parses a node from the source
   * @param ***REMOVED***ParseContext***REMOVED*** overlay
   * @param ***REMOVED***number***REMOVED*** start - Index of first non-whitespace character for the node
   * @returns ***REMOVED***?Node***REMOVED*** - null if at a document boundary
   */


***REMOVED***

// Published as 'yaml/parse-cst'
function parse(src) ***REMOVED***
  const cr = [];

  if (src.indexOf('\r') !== -1) ***REMOVED***
    src = src.replace(/\r\n?/g, (match, offset) => ***REMOVED***
      if (match.length > 1) cr.push(offset);
      return '\n';
***REMOVED***);
***REMOVED***

  const documents = [];
  let offset = 0;

  do ***REMOVED***
    const doc = new Document();
    const context = new ParseContext(***REMOVED***
      src
***REMOVED***);
    offset = doc.parse(context, offset);
    documents.push(doc);
***REMOVED*** while (offset < src.length);

  documents.setOrigRanges = () => ***REMOVED***
    if (cr.length === 0) return false;

    for (let i = 1; i < cr.length; ++i) cr[i] -= i;

    let crOffset = 0;

    for (let i = 0; i < documents.length; ++i) ***REMOVED***
      crOffset = documents[i].setOrigRanges(cr, crOffset);
***REMOVED***

    cr.splice(0, cr.length);
    return true;
***REMOVED***;

  documents.toString = () => documents.join('...\n');

  return documents;
***REMOVED***

exports.parse = parse;
