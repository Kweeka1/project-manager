import ***REMOVED*** d as defaultTagPrefix, _ as _createForOfIteratorHelper, a as _typeof, b as _createClass, c as _classCallCheck, e as _defineProperty, Y as YAMLSyntaxError, T as Type, f as YAMLWarning, g as YAMLSemanticError, h as _slicedToArray, i as YAMLError, j as _inherits, k as _createSuper ***REMOVED*** from './PlainValue-b8036b75.js';
import ***REMOVED*** parse as parse$1 ***REMOVED*** from './parse-cst.js';
import ***REMOVED*** b as binaryOptions, a as boolOptions, i as intOptions, n as nullOptions, s as strOptions, N as Node, P as Pair, S as Scalar, c as stringifyString, A as Alias, Y as YAMLSeq, d as YAMLMap, M as Merge, C as Collection, r as resolveNode, e as isEmptyPath, t as toJSON, f as addComment ***REMOVED*** from './resolveSeq-492ab440.js';
import ***REMOVED*** S as Schema ***REMOVED*** from './Schema-e94716c8.js';
import ***REMOVED*** w as warn ***REMOVED*** from './warnings-df54cb69.js';

var defaultOptions = ***REMOVED***
  anchorPrefix: 'a',
  customTags: null,
  indent: 2,
  indentSeq: true,
  keepCstNodes: false,
  keepNodeTypes: true,
  keepBlobsInJSON: true,
  mapAsMap: false,
  maxAliasCount: 100,
  prettyErrors: false,
  // TODO Set true in v2
  simpleKeys: false,
  version: '1.2'
***REMOVED***;
var scalarOptions = ***REMOVED***
  get binary() ***REMOVED***
    return binaryOptions;
***REMOVED***

  set binary(opt) ***REMOVED***
    Object.assign(binaryOptions, opt);
***REMOVED***

  get bool() ***REMOVED***
    return boolOptions;
***REMOVED***

  set bool(opt) ***REMOVED***
    Object.assign(boolOptions, opt);
***REMOVED***

  get int() ***REMOVED***
    return intOptions;
***REMOVED***

  set int(opt) ***REMOVED***
    Object.assign(intOptions, opt);
***REMOVED***

  get null() ***REMOVED***
    return nullOptions;
***REMOVED***

  set null(opt) ***REMOVED***
    Object.assign(nullOptions, opt);
***REMOVED***

  get str() ***REMOVED***
    return strOptions;
***REMOVED***

  set str(opt) ***REMOVED***
    Object.assign(strOptions, opt);
***REMOVED***

***REMOVED***;
var documentOptions = ***REMOVED***
  '1.0': ***REMOVED***
    schema: 'yaml-1.1',
    merge: true,
    tagPrefixes: [***REMOVED***
      handle: '!',
      prefix: defaultTagPrefix
***REMOVED***, ***REMOVED***
      handle: '!!',
      prefix: 'tag:private.yaml.org,2002:'
***REMOVED***]
***REMOVED***
  1.1: ***REMOVED***
    schema: 'yaml-1.1',
    merge: true,
    tagPrefixes: [***REMOVED***
      handle: '!',
      prefix: '!'
***REMOVED***, ***REMOVED***
      handle: '!!',
      prefix: defaultTagPrefix
***REMOVED***]
***REMOVED***
  1.2: ***REMOVED***
    schema: 'core',
    merge: false,
    tagPrefixes: [***REMOVED***
      handle: '!',
      prefix: '!'
***REMOVED***, ***REMOVED***
      handle: '!!',
      prefix: defaultTagPrefix
***REMOVED***]
***REMOVED***
***REMOVED***;

function stringifyTag(doc, tag) ***REMOVED***
  if ((doc.version || doc.options.version) === '1.0') ***REMOVED***
    var priv = tag.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
    if (priv) return '!' + priv[1];
    var vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
    return vocab ? "!".concat(vocab[1], "/").concat(vocab[2]) : "!".concat(tag.replace(/^tag:/, ''));
***REMOVED***

  var p = doc.tagPrefixes.find(function (p) ***REMOVED***
    return tag.indexOf(p.prefix) === 0;
***REMOVED***);

  if (!p) ***REMOVED***
    var dtp = doc.getDefaults().tagPrefixes;
    p = dtp && dtp.find(function (p) ***REMOVED***
      return tag.indexOf(p.prefix) === 0;
***REMOVED***);
***REMOVED***

  if (!p) return tag[0] === '!' ? tag : "!<".concat(tag, ">");
  var suffix = tag.substr(p.prefix.length).replace(/[!,[\]***REMOVED******REMOVED***]/g, function (ch) ***REMOVED***
    return ***REMOVED***
      '!': '%21',
      ',': '%2C',
      '[': '%5B',
      ']': '%5D',
      '***REMOVED***': '%7B',
      '***REMOVED***': '%7D'
***REMOVED***[ch];
***REMOVED***);
  return p.handle + suffix;
***REMOVED***

function getTagObject(tags, item) ***REMOVED***
  if (item instanceof Alias) return Alias;

  if (item.tag) ***REMOVED***
    var match = tags.filter(function (t) ***REMOVED***
      return t.tag === item.tag;
***REMOVED***);
    if (match.length > 0) return match.find(function (t) ***REMOVED***
      return t.format === item.format;
***REMOVED***) || match[0];
***REMOVED***

  var tagObj, obj;

  if (item instanceof Scalar) ***REMOVED***
    obj = item.value; // TODO: deprecate/remove class check

    var _match = tags.filter(function (t) ***REMOVED***
      return t.identify && t.identify(obj) || t.class && obj instanceof t.class;
***REMOVED***);

    tagObj = _match.find(function (t) ***REMOVED***
      return t.format === item.format;
***REMOVED***) || _match.find(function (t) ***REMOVED***
      return !t.format;
***REMOVED***);
***REMOVED*** else ***REMOVED***
    obj = item;
    tagObj = tags.find(function (t) ***REMOVED***
      return t.nodeClass && obj instanceof t.nodeClass;
***REMOVED***);
***REMOVED***

  if (!tagObj) ***REMOVED***
    var name = obj && obj.constructor ? obj.constructor.name : _typeof(obj);
    throw new Error("Tag not resolved for ".concat(name, " value"));
***REMOVED***

  return tagObj;
***REMOVED*** // needs to be called before value stringifier to allow for circular anchor refs


function stringifyProps(node, tagObj, _ref) ***REMOVED***
  var anchors = _ref.anchors,
      doc = _ref.doc;
  var props = [];
  var anchor = doc.anchors.getName(node);

  if (anchor) ***REMOVED***
    anchors[anchor] = node;
    props.push("&".concat(anchor));
***REMOVED***

  if (node.tag) ***REMOVED***
    props.push(stringifyTag(doc, node.tag));
***REMOVED*** else if (!tagObj.default) ***REMOVED***
    props.push(stringifyTag(doc, tagObj.tag));
***REMOVED***

  return props.join(' ');
***REMOVED***

function stringify$1(item, ctx, onComment, onChompKeep) ***REMOVED***
  var _ctx$doc = ctx.doc,
      anchors = _ctx$doc.anchors,
      schema = _ctx$doc.schema;
  var tagObj;

  if (!(item instanceof Node)) ***REMOVED***
    var createCtx = ***REMOVED***
      aliasNodes: [],
      onTagObj: function onTagObj(o) ***REMOVED***
        return tagObj = o;
  ***REMOVED***,
      prevObjects: new Map()
***REMOVED***;
    item = schema.createNode(item, true, null, createCtx);

    var _iterator = _createForOfIteratorHelper(createCtx.aliasNodes),
        _step;

    try ***REMOVED***
      for (_iterator.s(); !(_step = _iterator.n()).done;) ***REMOVED***
        var alias = _step.value;
        alias.source = alias.source.node;
        var name = anchors.getName(alias.source);

        if (!name) ***REMOVED***
          name = anchors.newName();
          anchors.map[name] = alias.source;
    ***REMOVED***
  ***REMOVED***
***REMOVED*** catch (err) ***REMOVED***
      _iterator.e(err);
***REMOVED*** finally ***REMOVED***
      _iterator.f();
***REMOVED***
***REMOVED***

  if (item instanceof Pair) return item.toString(ctx, onComment, onChompKeep);
  if (!tagObj) tagObj = getTagObject(schema.tags, item);
  var props = stringifyProps(item, tagObj, ctx);
  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
  var str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof Scalar ? stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);
  if (!props) return str;
  return item instanceof Scalar || str[0] === '***REMOVED***' || str[0] === '[' ? "".concat(props, " ").concat(str) : "".concat(props, "\n").concat(ctx.indent).concat(str);
***REMOVED***

var Anchors = /*#__PURE__*/function () ***REMOVED***
  function Anchors(prefix) ***REMOVED***
    _classCallCheck(this, Anchors);

    _defineProperty(this, "map", Object.create(null));

    this.prefix = prefix;
***REMOVED***

  _createClass(Anchors, [***REMOVED***
    key: "createAlias",
    value: function createAlias(node, name) ***REMOVED***
      this.setAnchor(node, name);
      return new Alias(node);
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "createMergePair",
    value: function createMergePair() ***REMOVED***
      var _this = this;

      var merge = new Merge();

      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) ***REMOVED***
        sources[_key] = arguments[_key];
  ***REMOVED***

      merge.value.items = sources.map(function (s) ***REMOVED***
        if (s instanceof Alias) ***REMOVED***
          if (s.source instanceof YAMLMap) return s;
    ***REMOVED*** else if (s instanceof YAMLMap) ***REMOVED***
          return _this.createAlias(s);
    ***REMOVED***

        throw new Error('Merge sources must be Map nodes or their Aliases');
  ***REMOVED***);
      return merge;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "getName",
    value: function getName(node) ***REMOVED***
      var map = this.map;
      return Object.keys(map).find(function (a) ***REMOVED***
        return map[a] === node;
  ***REMOVED***);
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "getNames",
    value: function getNames() ***REMOVED***
      return Object.keys(this.map);
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "getNode",
    value: function getNode(name) ***REMOVED***
      return this.map[name];
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "newName",
    value: function newName(prefix) ***REMOVED***
      if (!prefix) prefix = this.prefix;
      var names = Object.keys(this.map);

      for (var i = 1; true; ++i) ***REMOVED***
        var name = "".concat(prefix).concat(i);
        if (!names.includes(name)) return name;
  ***REMOVED***
***REMOVED*** // During parsing, map & aliases contain CST nodes

***REMOVED*** ***REMOVED***
    key: "resolveNodes",
    value: function resolveNodes() ***REMOVED***
      var map = this.map,
          _cstAliases = this._cstAliases;
      Object.keys(map).forEach(function (a) ***REMOVED***
        map[a] = map[a].resolved;
  ***REMOVED***);

      _cstAliases.forEach(function (a) ***REMOVED***
        a.source = a.source.resolved;
  ***REMOVED***);

      delete this._cstAliases;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "setAnchor",
    value: function setAnchor(node, name) ***REMOVED***
      if (node != null && !Anchors.validAnchorNode(node)) ***REMOVED***
        throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');
  ***REMOVED***

      if (name && /[\x00-\x19\s,[\]***REMOVED******REMOVED***]/.test(name)) ***REMOVED***
        throw new Error('Anchor names must not contain whitespace or control characters');
  ***REMOVED***

      var map = this.map;
      var prev = node && Object.keys(map).find(function (a) ***REMOVED***
        return map[a] === node;
  ***REMOVED***);

      if (prev) ***REMOVED***
        if (!name) ***REMOVED***
          return prev;
    ***REMOVED*** else if (prev !== name) ***REMOVED***
          delete map[prev];
          map[name] = node;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
        if (!name) ***REMOVED***
          if (!node) return null;
          name = this.newName();
    ***REMOVED***

        map[name] = node;
  ***REMOVED***

      return name;
***REMOVED***
***REMOVED***], [***REMOVED***
    key: "validAnchorNode",
    value: function validAnchorNode(node) ***REMOVED***
      return node instanceof Scalar || node instanceof YAMLSeq || node instanceof YAMLMap;
***REMOVED***
***REMOVED***]);

  return Anchors;
***REMOVED***();

var visit = function visit(node, tags) ***REMOVED***
  if (node && _typeof(node) === 'object') ***REMOVED***
    var tag = node.tag;

    if (node instanceof Collection) ***REMOVED***
      if (tag) tags[tag] = true;
      node.items.forEach(function (n) ***REMOVED***
        return visit(n, tags);
  ***REMOVED***);
***REMOVED*** else if (node instanceof Pair) ***REMOVED***
      visit(node.key, tags);
      visit(node.value, tags);
***REMOVED*** else if (node instanceof Scalar) ***REMOVED***
      if (tag) tags[tag] = true;
***REMOVED***
***REMOVED***

  return tags;
***REMOVED***;

var listTagNames = function listTagNames(node) ***REMOVED***
  return Object.keys(visit(node, ***REMOVED******REMOVED***));
***REMOVED***;

function parseContents(doc, contents) ***REMOVED***
  var comments = ***REMOVED***
    before: [],
    after: []
***REMOVED***;
  var body = undefined;
  var spaceBefore = false;

  var _iterator = _createForOfIteratorHelper(contents),
      _step;

  try ***REMOVED***
    for (_iterator.s(); !(_step = _iterator.n()).done;) ***REMOVED***
      var node = _step.value;

      if (node.valueRange) ***REMOVED***
        if (body !== undefined) ***REMOVED***
          var msg = 'Document contains trailing content not separated by a ... or --- line';
          doc.errors.push(new YAMLSyntaxError(node, msg));
          break;
    ***REMOVED***

        var res = resolveNode(doc, node);

        if (spaceBefore) ***REMOVED***
          res.spaceBefore = true;
          spaceBefore = false;
    ***REMOVED***

        body = res;
  ***REMOVED*** else if (node.comment !== null) ***REMOVED***
        var cc = body === undefined ? comments.before : comments.after;
        cc.push(node.comment);
  ***REMOVED*** else if (node.type === Type.BLANK_LINE) ***REMOVED***
        spaceBefore = true;

        if (body === undefined && comments.before.length > 0 && !doc.commentBefore) ***REMOVED***
          // space-separated comments at start are parsed as document comments
          doc.commentBefore = comments.before.join('\n');
          comments.before = [];
    ***REMOVED***
  ***REMOVED***
***REMOVED***
***REMOVED*** catch (err) ***REMOVED***
    _iterator.e(err);
***REMOVED*** finally ***REMOVED***
    _iterator.f();
***REMOVED***

  doc.contents = body || null;

  if (!body) ***REMOVED***
    doc.comment = comments.before.concat(comments.after).join('\n') || null;
***REMOVED*** else ***REMOVED***
    var cb = comments.before.join('\n');

    if (cb) ***REMOVED***
      var cbNode = body instanceof Collection && body.items[0] ? body.items[0] : body;
      cbNode.commentBefore = cbNode.commentBefore ? "".concat(cb, "\n").concat(cbNode.commentBefore) : cb;
***REMOVED***

    doc.comment = comments.after.join('\n') || null;
***REMOVED***
***REMOVED***

function resolveTagDirective(_ref, directive) ***REMOVED***
  var tagPrefixes = _ref.tagPrefixes;

  var _directive$parameters = _slicedToArray(directive.parameters, 2),
      handle = _directive$parameters[0],
      prefix = _directive$parameters[1];

  if (!handle || !prefix) ***REMOVED***
    var msg = 'Insufficient parameters given for %TAG directive';
    throw new YAMLSemanticError(directive, msg);
***REMOVED***

  if (tagPrefixes.some(function (p) ***REMOVED***
    return p.handle === handle;
***REMOVED***)) ***REMOVED***
    var _msg = 'The %TAG directive must only be given at most once per handle in the same document.';
    throw new YAMLSemanticError(directive, _msg);
***REMOVED***

  return ***REMOVED***
    handle: handle,
    prefix: prefix
***REMOVED***;
***REMOVED***

function resolveYamlDirective(doc, directive) ***REMOVED***
  var _directive$parameters2 = _slicedToArray(directive.parameters, 1),
      version = _directive$parameters2[0];

  if (directive.name === 'YAML:1.0') version = '1.0';

  if (!version) ***REMOVED***
    var msg = 'Insufficient parameters given for %YAML directive';
    throw new YAMLSemanticError(directive, msg);
***REMOVED***

  if (!documentOptions[version]) ***REMOVED***
    var v0 = doc.version || doc.options.version;

    var _msg2 = "Document will be parsed as YAML ".concat(v0, " rather than YAML ").concat(version);

    doc.warnings.push(new YAMLWarning(directive, _msg2));
***REMOVED***

  return version;
***REMOVED***

function parseDirectives(doc, directives, prevDoc) ***REMOVED***
  var directiveComments = [];
  var hasDirectives = false;

  var _iterator = _createForOfIteratorHelper(directives),
      _step;

  try ***REMOVED***
    for (_iterator.s(); !(_step = _iterator.n()).done;) ***REMOVED***
      var directive = _step.value;
      var comment = directive.comment,
          name = directive.name;

      switch (name) ***REMOVED***
        case 'TAG':
          try ***REMOVED***
            doc.tagPrefixes.push(resolveTagDirective(doc, directive));
      ***REMOVED*** catch (error) ***REMOVED***
            doc.errors.push(error);
      ***REMOVED***

          hasDirectives = true;
          break;

        case 'YAML':
        case 'YAML:1.0':
          if (doc.version) ***REMOVED***
            var msg = 'The %YAML directive must only be given at most once per document.';
            doc.errors.push(new YAMLSemanticError(directive, msg));
      ***REMOVED***

          try ***REMOVED***
            doc.version = resolveYamlDirective(doc, directive);
      ***REMOVED*** catch (error) ***REMOVED***
            doc.errors.push(error);
      ***REMOVED***

          hasDirectives = true;
          break;

        default:
          if (name) ***REMOVED***
            var _msg3 = "YAML only supports %TAG and %YAML directives, and not %".concat(name);

            doc.warnings.push(new YAMLWarning(directive, _msg3));
      ***REMOVED***

  ***REMOVED***

      if (comment) directiveComments.push(comment);
***REMOVED***
***REMOVED*** catch (err) ***REMOVED***
    _iterator.e(err);
***REMOVED*** finally ***REMOVED***
    _iterator.f();
***REMOVED***

  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) ***REMOVED***
    var copyTagPrefix = function copyTagPrefix(_ref2) ***REMOVED***
      var handle = _ref2.handle,
          prefix = _ref2.prefix;
      return ***REMOVED***
        handle: handle,
        prefix: prefix
  ***REMOVED***;
***REMOVED***;

    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);
    doc.version = prevDoc.version;
***REMOVED***

  doc.commentBefore = directiveComments.join('\n') || null;
***REMOVED***

function assertCollection(contents) ***REMOVED***
  if (contents instanceof Collection) return true;
  throw new Error('Expected a YAML collection as document contents');
***REMOVED***

var Document$1 = /*#__PURE__*/function () ***REMOVED***
  function Document(options) ***REMOVED***
    _classCallCheck(this, Document);

    this.anchors = new Anchors(options.anchorPrefix);
    this.commentBefore = null;
    this.comment = null;
    this.contents = null;
    this.directivesEndMarker = null;
    this.errors = [];
    this.options = options;
    this.schema = null;
    this.tagPrefixes = [];
    this.version = null;
    this.warnings = [];
***REMOVED***

  _createClass(Document, [***REMOVED***
    key: "add",
    value: function add(value) ***REMOVED***
      assertCollection(this.contents);
      return this.contents.add(value);
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "addIn",
    value: function addIn(path, value) ***REMOVED***
      assertCollection(this.contents);
      this.contents.addIn(path, value);
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "delete",
    value: function _delete(key) ***REMOVED***
      assertCollection(this.contents);
      return this.contents.delete(key);
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "deleteIn",
    value: function deleteIn(path) ***REMOVED***
      if (isEmptyPath(path)) ***REMOVED***
        if (this.contents == null) return false;
        this.contents = null;
        return true;
  ***REMOVED***

      assertCollection(this.contents);
      return this.contents.deleteIn(path);
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "getDefaults",
    value: function getDefaults() ***REMOVED***
      return Document.defaults[this.version] || Document.defaults[this.options.version] || ***REMOVED******REMOVED***;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "get",
    value: function get(key, keepScalar) ***REMOVED***
      return this.contents instanceof Collection ? this.contents.get(key, keepScalar) : undefined;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "getIn",
    value: function getIn(path, keepScalar) ***REMOVED***
      if (isEmptyPath(path)) return !keepScalar && this.contents instanceof Scalar ? this.contents.value : this.contents;
      return this.contents instanceof Collection ? this.contents.getIn(path, keepScalar) : undefined;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "has",
    value: function has(key) ***REMOVED***
      return this.contents instanceof Collection ? this.contents.has(key) : false;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "hasIn",
    value: function hasIn(path) ***REMOVED***
      if (isEmptyPath(path)) return this.contents !== undefined;
      return this.contents instanceof Collection ? this.contents.hasIn(path) : false;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "set",
    value: function set(key, value) ***REMOVED***
      assertCollection(this.contents);
      this.contents.set(key, value);
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "setIn",
    value: function setIn(path, value) ***REMOVED***
      if (isEmptyPath(path)) this.contents = value;else ***REMOVED***
        assertCollection(this.contents);
        this.contents.setIn(path, value);
  ***REMOVED***
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "setSchema",
    value: function setSchema(id, customTags) ***REMOVED***
      if (!id && !customTags && this.schema) return;
      if (typeof id === 'number') id = id.toFixed(1);

      if (id === '1.0' || id === '1.1' || id === '1.2') ***REMOVED***
        if (this.version) this.version = id;else this.options.version = id;
        delete this.options.schema;
  ***REMOVED*** else if (id && typeof id === 'string') ***REMOVED***
        this.options.schema = id;
  ***REMOVED***

      if (Array.isArray(customTags)) this.options.customTags = customTags;
      var opt = Object.assign(***REMOVED******REMOVED***, this.getDefaults(), this.options);
      this.schema = new Schema(opt);
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "parse",
    value: function parse(node, prevDoc) ***REMOVED***
      if (this.options.keepCstNodes) this.cstNode = node;
      if (this.options.keepNodeTypes) this.type = 'DOCUMENT';
      var _node$directives = node.directives,
          directives = _node$directives === void 0 ? [] : _node$directives,
          _node$contents = node.contents,
          contents = _node$contents === void 0 ? [] : _node$contents,
          directivesEndMarker = node.directivesEndMarker,
          error = node.error,
          valueRange = node.valueRange;

      if (error) ***REMOVED***
        if (!error.source) error.source = this;
        this.errors.push(error);
  ***REMOVED***

      parseDirectives(this, directives, prevDoc);
      if (directivesEndMarker) this.directivesEndMarker = true;
      this.range = valueRange ? [valueRange.start, valueRange.end] : null;
      this.setSchema();
      this.anchors._cstAliases = [];
      parseContents(this, contents);
      this.anchors.resolveNodes();

      if (this.options.prettyErrors) ***REMOVED***
        var _iterator = _createForOfIteratorHelper(this.errors),
            _step;

        try ***REMOVED***
          for (_iterator.s(); !(_step = _iterator.n()).done;) ***REMOVED***
            var _error = _step.value;
            if (_error instanceof YAMLError) _error.makePretty();
      ***REMOVED***
    ***REMOVED*** catch (err) ***REMOVED***
          _iterator.e(err);
    ***REMOVED*** finally ***REMOVED***
          _iterator.f();
    ***REMOVED***

        var _iterator2 = _createForOfIteratorHelper(this.warnings),
            _step2;

        try ***REMOVED***
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) ***REMOVED***
            var warn = _step2.value;
            if (warn instanceof YAMLError) warn.makePretty();
      ***REMOVED***
    ***REMOVED*** catch (err) ***REMOVED***
          _iterator2.e(err);
    ***REMOVED*** finally ***REMOVED***
          _iterator2.f();
    ***REMOVED***
  ***REMOVED***

      return this;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "listNonDefaultTags",
    value: function listNonDefaultTags() ***REMOVED***
      return listTagNames(this.contents).filter(function (t) ***REMOVED***
        return t.indexOf(Schema.defaultPrefix) !== 0;
  ***REMOVED***);
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "setTagPrefix",
    value: function setTagPrefix(handle, prefix) ***REMOVED***
      if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');

      if (prefix) ***REMOVED***
        var prev = this.tagPrefixes.find(function (p) ***REMOVED***
          return p.handle === handle;
    ***REMOVED***);
        if (prev) prev.prefix = prefix;else this.tagPrefixes.push(***REMOVED***
          handle: handle,
          prefix: prefix
    ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
        this.tagPrefixes = this.tagPrefixes.filter(function (p) ***REMOVED***
          return p.handle !== handle;
    ***REMOVED***);
  ***REMOVED***
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "toJSON",
    value: function toJSON$1(arg, onAnchor) ***REMOVED***
      var _this = this;

      var _this$options = this.options,
          keepBlobsInJSON = _this$options.keepBlobsInJSON,
          mapAsMap = _this$options.mapAsMap,
          maxAliasCount = _this$options.maxAliasCount;
      var keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof Scalar));
      var ctx = ***REMOVED***
        doc: this,
        indentStep: '  ',
        keep: keep,
        mapAsMap: keep && !!mapAsMap,
        maxAliasCount: maxAliasCount,
        stringify: stringify$1 // Requiring directly in Pair would create circular dependencies

  ***REMOVED***;
      var anchorNames = Object.keys(this.anchors.map);
      if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(function (name) ***REMOVED***
        return [_this.anchors.map[name], ***REMOVED***
          alias: [],
          aliasCount: 0,
          count: 1
    ***REMOVED***];
  ***REMOVED***));

      var res = toJSON(this.contents, arg, ctx);

      if (typeof onAnchor === 'function' && ctx.anchors) ***REMOVED***
        var _iterator3 = _createForOfIteratorHelper(ctx.anchors.values()),
            _step3;

        try ***REMOVED***
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) ***REMOVED***
            var _step3$value = _step3.value,
                count = _step3$value.count,
                _res = _step3$value.res;
            onAnchor(_res, count);
      ***REMOVED***
    ***REMOVED*** catch (err) ***REMOVED***
          _iterator3.e(err);
    ***REMOVED*** finally ***REMOVED***
          _iterator3.f();
    ***REMOVED***
  ***REMOVED***

      return res;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "toString",
    value: function toString() ***REMOVED***
      if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');
      var indentSize = this.options.indent;

      if (!Number.isInteger(indentSize) || indentSize <= 0) ***REMOVED***
        var s = JSON.stringify(indentSize);
        throw new Error("\"indent\" option must be a positive integer, not ".concat(s));
  ***REMOVED***

      this.setSchema();
      var lines = [];
      var hasDirectives = false;

      if (this.version) ***REMOVED***
        var vd = '%YAML 1.2';

        if (this.schema.name === 'yaml-1.1') ***REMOVED***
          if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';
    ***REMOVED***

        lines.push(vd);
        hasDirectives = true;
  ***REMOVED***

      var tagNames = this.listNonDefaultTags();
      this.tagPrefixes.forEach(function (_ref) ***REMOVED***
        var handle = _ref.handle,
            prefix = _ref.prefix;

        if (tagNames.some(function (t) ***REMOVED***
          return t.indexOf(prefix) === 0;
    ***REMOVED***)) ***REMOVED***
          lines.push("%TAG ".concat(handle, " ").concat(prefix));
          hasDirectives = true;
    ***REMOVED***
  ***REMOVED***);
      if (hasDirectives || this.directivesEndMarker) lines.push('---');

      if (this.commentBefore) ***REMOVED***
        if (hasDirectives || !this.directivesEndMarker) lines.unshift('');
        lines.unshift(this.commentBefore.replace(/^/gm, '#'));
  ***REMOVED***

      var ctx = ***REMOVED***
        anchors: Object.create(null),
        doc: this,
        indent: '',
        indentStep: ' '.repeat(indentSize),
        stringify: stringify$1 // Requiring directly in nodes would create circular dependencies

  ***REMOVED***;
      var chompKeep = false;
      var contentComment = null;

      if (this.contents) ***REMOVED***
        if (this.contents instanceof Node) ***REMOVED***
          if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');
          if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment

          ctx.forceBlockIndent = !!this.comment;
          contentComment = this.contents.comment;
    ***REMOVED***

        var onChompKeep = contentComment ? null : function () ***REMOVED***
          return chompKeep = true;
    ***REMOVED***;
        var body = stringify$1(this.contents, ctx, function () ***REMOVED***
          return contentComment = null;
    ***REMOVED***, onChompKeep);
        lines.push(addComment(body, '', contentComment));
  ***REMOVED*** else if (this.contents !== undefined) ***REMOVED***
        lines.push(stringify$1(this.contents, ctx));
  ***REMOVED***

      if (this.comment) ***REMOVED***
        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');
        lines.push(this.comment.replace(/^/gm, '#'));
  ***REMOVED***

      return lines.join('\n') + '\n';
***REMOVED***
***REMOVED***]);

  return Document;
***REMOVED***();

_defineProperty(Document$1, "defaults", documentOptions);

function createNode(value) ***REMOVED***
  var wrapScalars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var tag = arguments.length > 2 ? arguments[2] : undefined;

  if (tag === undefined && typeof wrapScalars === 'string') ***REMOVED***
    tag = wrapScalars;
    wrapScalars = true;
***REMOVED***

  var options = Object.assign(***REMOVED******REMOVED***, Document$1.defaults[defaultOptions.version], defaultOptions);
  var schema = new Schema(options);
  return schema.createNode(value, wrapScalars, tag);
***REMOVED***

var Document = /*#__PURE__*/function (_YAMLDocument) ***REMOVED***
  _inherits(Document, _YAMLDocument);

  var _super = _createSuper(Document);

  function Document(options) ***REMOVED***
    _classCallCheck(this, Document);

    return _super.call(this, Object.assign(***REMOVED******REMOVED***, defaultOptions, options));
***REMOVED***

  return Document;
***REMOVED***(Document$1);

function parseAllDocuments(src, options) ***REMOVED***
  var stream = [];
  var prev;

  var _iterator = _createForOfIteratorHelper(parse$1(src)),
      _step;

  try ***REMOVED***
    for (_iterator.s(); !(_step = _iterator.n()).done;) ***REMOVED***
      var cstDoc = _step.value;
      var doc = new Document(options);
      doc.parse(cstDoc, prev);
      stream.push(doc);
      prev = doc;
***REMOVED***
***REMOVED*** catch (err) ***REMOVED***
    _iterator.e(err);
***REMOVED*** finally ***REMOVED***
    _iterator.f();
***REMOVED***

  return stream;
***REMOVED***

function parseDocument(src, options) ***REMOVED***
  var cst = parse$1(src);
  var doc = new Document(options).parse(cst[0]);

  if (cst.length > 1) ***REMOVED***
    var errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';
    doc.errors.unshift(new YAMLSemanticError(cst[1], errMsg));
***REMOVED***

  return doc;
***REMOVED***

function parse(src, options) ***REMOVED***
  var doc = parseDocument(src, options);
  doc.warnings.forEach(function (warning) ***REMOVED***
    return warn(warning);
***REMOVED***);
  if (doc.errors.length > 0) throw doc.errors[0];
  return doc.toJSON();
***REMOVED***

function stringify(value, options) ***REMOVED***
  var doc = new Document(options);
  doc.contents = value;
  return String(doc);
***REMOVED***

var YAML = ***REMOVED***
  createNode: createNode,
  defaultOptions: defaultOptions,
  Document: Document,
  parse: parse,
  parseAllDocuments: parseAllDocuments,
  parseCST: parse$1,
  parseDocument: parseDocument,
  scalarOptions: scalarOptions,
  stringify: stringify
***REMOVED***;

export ***REMOVED*** YAML ***REMOVED***;
