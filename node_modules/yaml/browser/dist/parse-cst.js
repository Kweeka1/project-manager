import ***REMOVED*** j as _inherits, k as _createSuper, c as _classCallCheck, T as Type, b as _createClass, R as Range, N as Node, g as YAMLSemanticError, l as _get, m as _getPrototypeOf, Y as YAMLSyntaxError, C as Char, e as _defineProperty, P as PlainValue ***REMOVED*** from './PlainValue-b8036b75.js';

var BlankLine = /*#__PURE__*/function (_Node) ***REMOVED***
  _inherits(BlankLine, _Node);

  var _super = _createSuper(BlankLine);

  function BlankLine() ***REMOVED***
    _classCallCheck(this, BlankLine);

    return _super.call(this, Type.BLANK_LINE);
***REMOVED***
  /* istanbul ignore next */


  _createClass(BlankLine, [***REMOVED***
    key: "includesTrailingLines",
    get: function get() ***REMOVED***
      // This is never called from anywhere, but if it were,
      // this is the value it should return.
      return true;
***REMOVED***
    /**
     * Parses a blank line from the source
     *
     * @param ***REMOVED***ParseContext***REMOVED*** context
     * @param ***REMOVED***number***REMOVED*** start - Index of first \n character
     * @returns ***REMOVED***number***REMOVED*** - Index of the character after this
     */

***REMOVED*** ***REMOVED***
    key: "parse",
    value: function parse(context, start) ***REMOVED***
      this.context = context;
      this.range = new Range(start, start + 1);
      return start + 1;
***REMOVED***
***REMOVED***]);

  return BlankLine;
***REMOVED***(Node);

var CollectionItem = /*#__PURE__*/function (_Node) ***REMOVED***
  _inherits(CollectionItem, _Node);

  var _super = _createSuper(CollectionItem);

  function CollectionItem(type, props) ***REMOVED***
    var _this;

    _classCallCheck(this, CollectionItem);

    _this = _super.call(this, type, props);
    _this.node = null;
    return _this;
***REMOVED***

  _createClass(CollectionItem, [***REMOVED***
    key: "includesTrailingLines",
    get: function get() ***REMOVED***
      return !!this.node && this.node.includesTrailingLines;
***REMOVED***
    /**
     * @param ***REMOVED***ParseContext***REMOVED*** context
     * @param ***REMOVED***number***REMOVED*** start - Index of first character
     * @returns ***REMOVED***number***REMOVED*** - Index of the character after this
     */

***REMOVED*** ***REMOVED***
    key: "parse",
    value: function parse(context, start) ***REMOVED***
      this.context = context;
      var parseNode = context.parseNode,
          src = context.src;
      var atLineStart = context.atLineStart,
          lineStart = context.lineStart;
      if (!atLineStart && this.type === Type.SEQ_ITEM) this.error = new YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');
      var indent = atLineStart ? start - lineStart : context.indent;
      var offset = Node.endOfWhiteSpace(src, start + 1);
      var ch = src[offset];
      var inlineComment = ch === '#';
      var comments = [];
      var blankLine = null;

      while (ch === '\n' || ch === '#') ***REMOVED***
        if (ch === '#') ***REMOVED***
          var _end = Node.endOfLine(src, offset + 1);

          comments.push(new Range(offset, _end));
          offset = _end;
    ***REMOVED*** else ***REMOVED***
          atLineStart = true;
          lineStart = offset + 1;
          var wsEnd = Node.endOfWhiteSpace(src, lineStart);

          if (src[wsEnd] === '\n' && comments.length === 0) ***REMOVED***
            blankLine = new BlankLine();
            lineStart = blankLine.parse(***REMOVED***
              src: src
        ***REMOVED***, lineStart);
      ***REMOVED***

          offset = Node.endOfIndent(src, lineStart);
    ***REMOVED***

        ch = src[offset];
  ***REMOVED***

      if (Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== Type.SEQ_ITEM)) ***REMOVED***
        this.node = parseNode(***REMOVED***
          atLineStart: atLineStart,
          inCollection: false,
          indent: indent,
          lineStart: lineStart,
          parent: this
    ***REMOVED***, offset);
  ***REMOVED*** else if (ch && lineStart > start + 1) ***REMOVED***
        offset = lineStart - 1;
  ***REMOVED***

      if (this.node) ***REMOVED***
        if (blankLine) ***REMOVED***
          // Only blank lines preceding non-empty nodes are captured. Note that
          // this means that collection item range start indices do not always
          // increase monotonically. -- eemeli/yaml#126
          var items = context.parent.items || context.parent.contents;
          if (items) items.push(blankLine);
    ***REMOVED***

        if (comments.length) Array.prototype.push.apply(this.props, comments);
        offset = this.node.range.end;
  ***REMOVED*** else ***REMOVED***
        if (inlineComment) ***REMOVED***
          var c = comments[0];
          this.props.push(c);
          offset = c.end;
    ***REMOVED*** else ***REMOVED***
          offset = Node.endOfLine(src, start + 1);
    ***REMOVED***
  ***REMOVED***

      var end = this.node ? this.node.valueRange.end : offset;
      this.valueRange = new Range(start, end);
      return offset;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "setOrigRanges",
    value: function setOrigRanges(cr, offset) ***REMOVED***
      offset = _get(_getPrototypeOf(CollectionItem.prototype), "setOrigRanges", this).call(this, cr, offset);
      return this.node ? this.node.setOrigRanges(cr, offset) : offset;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "toString",
    value: function toString() ***REMOVED***
      var src = this.context.src,
          node = this.node,
          range = this.range,
          value = this.value;
      if (value != null) return value;
      var str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);
      return Node.addStringTerminator(src, range.end, str);
***REMOVED***
***REMOVED***]);

  return CollectionItem;
***REMOVED***(Node);

var Comment = /*#__PURE__*/function (_Node) ***REMOVED***
  _inherits(Comment, _Node);

  var _super = _createSuper(Comment);

  function Comment() ***REMOVED***
    _classCallCheck(this, Comment);

    return _super.call(this, Type.COMMENT);
***REMOVED***
  /**
   * Parses a comment line from the source
   *
   * @param ***REMOVED***ParseContext***REMOVED*** context
   * @param ***REMOVED***number***REMOVED*** start - Index of first character
   * @returns ***REMOVED***number***REMOVED*** - Index of the character after this scalar
   */


  _createClass(Comment, [***REMOVED***
    key: "parse",
    value: function parse(context, start) ***REMOVED***
      this.context = context;
      var offset = this.parseComment(start);
      this.range = new Range(start, offset);
      return offset;
***REMOVED***
***REMOVED***]);

  return Comment;
***REMOVED***(Node);

function grabCollectionEndComments(node) ***REMOVED***
  var cnode = node;

  while (cnode instanceof CollectionItem) ***REMOVED***
    cnode = cnode.node;
***REMOVED***

  if (!(cnode instanceof Collection)) return null;
  var len = cnode.items.length;
  var ci = -1;

  for (var i = len - 1; i >= 0; --i) ***REMOVED***
    var n = cnode.items[i];

    if (n.type === Type.COMMENT) ***REMOVED***
      // Keep sufficiently indented comments with preceding node
      var _n$context = n.context,
          indent = _n$context.indent,
          lineStart = _n$context.lineStart;
      if (indent > 0 && n.range.start >= lineStart + indent) break;
      ci = i;
***REMOVED*** else if (n.type === Type.BLANK_LINE) ci = i;else break;
***REMOVED***

  if (ci === -1) return null;
  var ca = cnode.items.splice(ci, len - ci);
  var prevEnd = ca[0].range.start;

  while (true) ***REMOVED***
    cnode.range.end = prevEnd;
    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;
    if (cnode === node) break;
    cnode = cnode.context.parent;
***REMOVED***

  return ca;
***REMOVED***
var Collection = /*#__PURE__*/function (_Node) ***REMOVED***
  _inherits(Collection, _Node);

  var _super = _createSuper(Collection);

  function Collection(firstItem) ***REMOVED***
    var _this;

    _classCallCheck(this, Collection);

    _this = _super.call(this, firstItem.type === Type.SEQ_ITEM ? Type.SEQ : Type.MAP);

    for (var i = firstItem.props.length - 1; i >= 0; --i) ***REMOVED***
      if (firstItem.props[i].start < firstItem.context.lineStart) ***REMOVED***
        // props on previous line are assumed by the collection
        _this.props = firstItem.props.slice(0, i + 1);
        firstItem.props = firstItem.props.slice(i + 1);
        var itemRange = firstItem.props[0] || firstItem.valueRange;
        firstItem.range.start = itemRange.start;
        break;
  ***REMOVED***
***REMOVED***

    _this.items = [firstItem];
    var ec = grabCollectionEndComments(firstItem);
    if (ec) Array.prototype.push.apply(_this.items, ec);
    return _this;
***REMOVED***

  _createClass(Collection, [***REMOVED***
    key: "includesTrailingLines",
    get: function get() ***REMOVED***
      return this.items.length > 0;
***REMOVED***
    /**
     * @param ***REMOVED***ParseContext***REMOVED*** context
     * @param ***REMOVED***number***REMOVED*** start - Index of first character
     * @returns ***REMOVED***number***REMOVED*** - Index of the character after this
     */

***REMOVED*** ***REMOVED***
    key: "parse",
    value: function parse(context, start) ***REMOVED***
      this.context = context;
      var parseNode = context.parseNode,
          src = context.src; // It's easier to recalculate lineStart here rather than tracking down the
      // last context from which to read it -- eemeli/yaml#2

      var lineStart = Node.startOfLine(src, start);
      var firstItem = this.items[0]; // First-item context needs to be correct for later comment handling
      // -- eemeli/yaml#17

      firstItem.context.parent = this;
      this.valueRange = Range.copy(firstItem.valueRange);
      var indent = firstItem.range.start - firstItem.context.lineStart;
      var offset = start;
      offset = Node.normalizeOffset(src, offset);
      var ch = src[offset];
      var atLineStart = Node.endOfWhiteSpace(src, lineStart) === offset;
      var prevIncludesTrailingLines = false;

      while (ch) ***REMOVED***
        while (ch === '\n' || ch === '#') ***REMOVED***
          if (atLineStart && ch === '\n' && !prevIncludesTrailingLines) ***REMOVED***
            var blankLine = new BlankLine();
            offset = blankLine.parse(***REMOVED***
              src: src
        ***REMOVED***, offset);
            this.valueRange.end = offset;

            if (offset >= src.length) ***REMOVED***
              ch = null;
              break;
        ***REMOVED***

            this.items.push(blankLine);
            offset -= 1; // blankLine.parse() consumes terminal newline
      ***REMOVED*** else if (ch === '#') ***REMOVED***
            if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) ***REMOVED***
              return offset;
        ***REMOVED***

            var comment = new Comment();
            offset = comment.parse(***REMOVED***
              indent: indent,
              lineStart: lineStart,
              src: src
        ***REMOVED***, offset);
            this.items.push(comment);
            this.valueRange.end = offset;

            if (offset >= src.length) ***REMOVED***
              ch = null;
              break;
        ***REMOVED***
      ***REMOVED***

          lineStart = offset + 1;
          offset = Node.endOfIndent(src, lineStart);

          if (Node.atBlank(src, offset)) ***REMOVED***
            var wsEnd = Node.endOfWhiteSpace(src, offset);
            var next = src[wsEnd];

            if (!next || next === '\n' || next === '#') ***REMOVED***
              offset = wsEnd;
        ***REMOVED***
      ***REMOVED***

          ch = src[offset];
          atLineStart = true;
    ***REMOVED***

        if (!ch) ***REMOVED***
          break;
    ***REMOVED***

        if (offset !== lineStart + indent && (atLineStart || ch !== ':')) ***REMOVED***
          if (offset < lineStart + indent) ***REMOVED***
            if (lineStart > start) offset = lineStart;
            break;
      ***REMOVED*** else if (!this.error) ***REMOVED***
            var msg = 'All collection items must start at the same column';
            this.error = new YAMLSyntaxError(this, msg);
      ***REMOVED***
    ***REMOVED***

        if (firstItem.type === Type.SEQ_ITEM) ***REMOVED***
          if (ch !== '-') ***REMOVED***
            if (lineStart > start) offset = lineStart;
            break;
      ***REMOVED***
    ***REMOVED*** else if (ch === '-' && !this.error) ***REMOVED***
          // map key may start with -, as long as it's followed by a non-whitespace char
          var _next = src[offset + 1];

          if (!_next || _next === '\n' || _next === '\t' || _next === ' ') ***REMOVED***
            var _msg = 'A collection cannot be both a mapping and a sequence';
            this.error = new YAMLSyntaxError(this, _msg);
      ***REMOVED***
    ***REMOVED***

        var node = parseNode(***REMOVED***
          atLineStart: atLineStart,
          inCollection: true,
          indent: indent,
          lineStart: lineStart,
          parent: this
    ***REMOVED***, offset);
        if (!node) return offset; // at next document start

        this.items.push(node);
        this.valueRange.end = node.valueRange.end;
        offset = Node.normalizeOffset(src, node.range.end);
        ch = src[offset];
        atLineStart = false;
        prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range
        // has advanced to check the current line's indentation level
        // -- eemeli/yaml#10 & eemeli/yaml#38

        if (ch) ***REMOVED***
          var ls = offset - 1;
          var prev = src[ls];

          while (prev === ' ' || prev === '\t') ***REMOVED***
            prev = src[--ls];
      ***REMOVED***

          if (prev === '\n') ***REMOVED***
            lineStart = ls + 1;
            atLineStart = true;
      ***REMOVED***
    ***REMOVED***

        var ec = grabCollectionEndComments(node);
        if (ec) Array.prototype.push.apply(this.items, ec);
  ***REMOVED***

      return offset;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "setOrigRanges",
    value: function setOrigRanges(cr, offset) ***REMOVED***
      offset = _get(_getPrototypeOf(Collection.prototype), "setOrigRanges", this).call(this, cr, offset);
      this.items.forEach(function (node) ***REMOVED***
        offset = node.setOrigRanges(cr, offset);
  ***REMOVED***);
      return offset;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "toString",
    value: function toString() ***REMOVED***
      var src = this.context.src,
          items = this.items,
          range = this.range,
          value = this.value;
      if (value != null) return value;
      var str = src.slice(range.start, items[0].range.start) + String(items[0]);

      for (var i = 1; i < items.length; ++i) ***REMOVED***
        var item = items[i];
        var _item$context = item.context,
            atLineStart = _item$context.atLineStart,
            indent = _item$context.indent;
        if (atLineStart) for (var _i = 0; _i < indent; ++_i) ***REMOVED***
          str += ' ';
    ***REMOVED***
        str += String(item);
  ***REMOVED***

      return Node.addStringTerminator(src, range.end, str);
***REMOVED***
***REMOVED***], [***REMOVED***
    key: "nextContentHasIndent",
    value: function nextContentHasIndent(src, offset, indent) ***REMOVED***
      var lineStart = Node.endOfLine(src, offset) + 1;
      offset = Node.endOfWhiteSpace(src, lineStart);
      var ch = src[offset];
      if (!ch) return false;
      if (offset >= lineStart + indent) return true;
      if (ch !== '#' && ch !== '\n') return false;
      return Collection.nextContentHasIndent(src, offset, indent);
***REMOVED***
***REMOVED***]);

  return Collection;
***REMOVED***(Node);

var Directive = /*#__PURE__*/function (_Node) ***REMOVED***
  _inherits(Directive, _Node);

  var _super = _createSuper(Directive);

  function Directive() ***REMOVED***
    var _this;

    _classCallCheck(this, Directive);

    _this = _super.call(this, Type.DIRECTIVE);
    _this.name = null;
    return _this;
***REMOVED***

  _createClass(Directive, [***REMOVED***
    key: "parameters",
    get: function get() ***REMOVED***
      var raw = this.rawValue;
      return raw ? raw.trim().split(/[ \t]+/) : [];
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "parseName",
    value: function parseName(start) ***REMOVED***
      var src = this.context.src;
      var offset = start;
      var ch = src[offset];

      while (ch && ch !== '\n' && ch !== '\t' && ch !== ' ') ***REMOVED***
        ch = src[offset += 1];
  ***REMOVED***

      this.name = src.slice(start, offset);
      return offset;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "parseParameters",
    value: function parseParameters(start) ***REMOVED***
      var src = this.context.src;
      var offset = start;
      var ch = src[offset];

      while (ch && ch !== '\n' && ch !== '#') ***REMOVED***
        ch = src[offset += 1];
  ***REMOVED***

      this.valueRange = new Range(start, offset);
      return offset;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "parse",
    value: function parse(context, start) ***REMOVED***
      this.context = context;
      var offset = this.parseName(start + 1);
      offset = this.parseParameters(offset);
      offset = this.parseComment(offset);
      this.range = new Range(start, offset);
      return offset;
***REMOVED***
***REMOVED***]);

  return Directive;
***REMOVED***(Node);

var Document = /*#__PURE__*/function (_Node) ***REMOVED***
  _inherits(Document, _Node);

  var _super = _createSuper(Document);

  function Document() ***REMOVED***
    var _this;

    _classCallCheck(this, Document);

    _this = _super.call(this, Type.DOCUMENT);
    _this.directives = null;
    _this.contents = null;
    _this.directivesEndMarker = null;
    _this.documentEndMarker = null;
    return _this;
***REMOVED***

  _createClass(Document, [***REMOVED***
    key: "parseDirectives",
    value: function parseDirectives(start) ***REMOVED***
      var src = this.context.src;
      this.directives = [];
      var atLineStart = true;
      var hasDirectives = false;
      var offset = start;

      while (!Node.atDocumentBoundary(src, offset, Char.DIRECTIVES_END)) ***REMOVED***
        offset = Document.startCommentOrEndBlankLine(src, offset);

        switch (src[offset]) ***REMOVED***
          case '\n':
            if (atLineStart) ***REMOVED***
              var blankLine = new BlankLine();
              offset = blankLine.parse(***REMOVED***
                src: src
          ***REMOVED***, offset);

              if (offset < src.length) ***REMOVED***
                this.directives.push(blankLine);
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
              offset += 1;
              atLineStart = true;
        ***REMOVED***

            break;

          case '#':
            ***REMOVED***
              var comment = new Comment();
              offset = comment.parse(***REMOVED***
                src: src
          ***REMOVED***, offset);
              this.directives.push(comment);
              atLineStart = false;
        ***REMOVED***
            break;

          case '%':
            ***REMOVED***
              var directive = new Directive();
              offset = directive.parse(***REMOVED***
                parent: this,
                src: src
          ***REMOVED***, offset);
              this.directives.push(directive);
              hasDirectives = true;
              atLineStart = false;
        ***REMOVED***
            break;

          default:
            if (hasDirectives) ***REMOVED***
              this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');
        ***REMOVED*** else if (this.directives.length > 0) ***REMOVED***
              this.contents = this.directives;
              this.directives = [];
        ***REMOVED***

            return offset;
    ***REMOVED***
  ***REMOVED***

      if (src[offset]) ***REMOVED***
        this.directivesEndMarker = new Range(offset, offset + 3);
        return offset + 3;
  ***REMOVED***

      if (hasDirectives) ***REMOVED***
        this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');
  ***REMOVED*** else if (this.directives.length > 0) ***REMOVED***
        this.contents = this.directives;
        this.directives = [];
  ***REMOVED***

      return offset;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "parseContents",
    value: function parseContents(start) ***REMOVED***
      var _this$context = this.context,
          parseNode = _this$context.parseNode,
          src = _this$context.src;
      if (!this.contents) this.contents = [];
      var lineStart = start;

      while (src[lineStart - 1] === '-') ***REMOVED***
        lineStart -= 1;
  ***REMOVED***

      var offset = Node.endOfWhiteSpace(src, start);
      var atLineStart = lineStart === start;
      this.valueRange = new Range(offset);

      while (!Node.atDocumentBoundary(src, offset, Char.DOCUMENT_END)) ***REMOVED***
        switch (src[offset]) ***REMOVED***
          case '\n':
            if (atLineStart) ***REMOVED***
              var blankLine = new BlankLine();
              offset = blankLine.parse(***REMOVED***
                src: src
          ***REMOVED***, offset);

              if (offset < src.length) ***REMOVED***
                this.contents.push(blankLine);
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
              offset += 1;
              atLineStart = true;
        ***REMOVED***

            lineStart = offset;
            break;

          case '#':
            ***REMOVED***
              var comment = new Comment();
              offset = comment.parse(***REMOVED***
                src: src
          ***REMOVED***, offset);
              this.contents.push(comment);
              atLineStart = false;
        ***REMOVED***
            break;

          default:
            ***REMOVED***
              var iEnd = Node.endOfIndent(src, offset);
              var context = ***REMOVED***
                atLineStart: atLineStart,
                indent: -1,
                inFlow: false,
                inCollection: false,
                lineStart: lineStart,
                parent: this
          ***REMOVED***;
              var node = parseNode(context, iEnd);
              if (!node) return this.valueRange.end = iEnd; // at next document start

              this.contents.push(node);
              offset = node.range.end;
              atLineStart = false;
              var ec = grabCollectionEndComments(node);
              if (ec) Array.prototype.push.apply(this.contents, ec);
        ***REMOVED***
    ***REMOVED***

        offset = Document.startCommentOrEndBlankLine(src, offset);
  ***REMOVED***

      this.valueRange.end = offset;

      if (src[offset]) ***REMOVED***
        this.documentEndMarker = new Range(offset, offset + 3);
        offset += 3;

        if (src[offset]) ***REMOVED***
          offset = Node.endOfWhiteSpace(src, offset);

          if (src[offset] === '#') ***REMOVED***
            var _comment = new Comment();

            offset = _comment.parse(***REMOVED***
              src: src
        ***REMOVED***, offset);
            this.contents.push(_comment);
      ***REMOVED***

          switch (src[offset]) ***REMOVED***
            case '\n':
              offset += 1;
              break;

            case undefined:
              break;

            default:
              this.error = new YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

      return offset;
***REMOVED***
    /**
     * @param ***REMOVED***ParseContext***REMOVED*** context
     * @param ***REMOVED***number***REMOVED*** start - Index of first character
     * @returns ***REMOVED***number***REMOVED*** - Index of the character after this
     */

***REMOVED*** ***REMOVED***
    key: "parse",
    value: function parse(context, start) ***REMOVED***
      context.root = this;
      this.context = context;
      var src = context.src;
      var offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM

      offset = this.parseDirectives(offset);
      offset = this.parseContents(offset);
      return offset;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "setOrigRanges",
    value: function setOrigRanges(cr, offset) ***REMOVED***
      offset = _get(_getPrototypeOf(Document.prototype), "setOrigRanges", this).call(this, cr, offset);
      this.directives.forEach(function (node) ***REMOVED***
        offset = node.setOrigRanges(cr, offset);
  ***REMOVED***);
      if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);
      this.contents.forEach(function (node) ***REMOVED***
        offset = node.setOrigRanges(cr, offset);
  ***REMOVED***);
      if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);
      return offset;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "toString",
    value: function toString() ***REMOVED***
      var contents = this.contents,
          directives = this.directives,
          value = this.value;
      if (value != null) return value;
      var str = directives.join('');

      if (contents.length > 0) ***REMOVED***
        if (directives.length > 0 || contents[0].type === Type.COMMENT) str += '---\n';
        str += contents.join('');
  ***REMOVED***

      if (str[str.length - 1] !== '\n') str += '\n';
      return str;
***REMOVED***
***REMOVED***], [***REMOVED***
    key: "startCommentOrEndBlankLine",
    value: function startCommentOrEndBlankLine(src, start) ***REMOVED***
      var offset = Node.endOfWhiteSpace(src, start);
      var ch = src[offset];
      return ch === '#' || ch === '\n' ? offset : start;
***REMOVED***
***REMOVED***]);

  return Document;
***REMOVED***(Node);

var Alias = /*#__PURE__*/function (_Node) ***REMOVED***
  _inherits(Alias, _Node);

  var _super = _createSuper(Alias);

  function Alias() ***REMOVED***
    _classCallCheck(this, Alias);

    return _super.apply(this, arguments);
***REMOVED***

  _createClass(Alias, [***REMOVED***
    key: "parse",
    value:
    /**
     * Parses an *alias from the source
     *
     * @param ***REMOVED***ParseContext***REMOVED*** context
     * @param ***REMOVED***number***REMOVED*** start - Index of first character
     * @returns ***REMOVED***number***REMOVED*** - Index of the character after this scalar
     */
    function parse(context, start) ***REMOVED***
      this.context = context;
      var src = context.src;
      var offset = Node.endOfIdentifier(src, start + 1);
      this.valueRange = new Range(start + 1, offset);
      offset = Node.endOfWhiteSpace(src, offset);
      offset = this.parseComment(offset);
      return offset;
***REMOVED***
***REMOVED***]);

  return Alias;
***REMOVED***(Node);

var Chomp = ***REMOVED***
  CLIP: 'CLIP',
  KEEP: 'KEEP',
  STRIP: 'STRIP'
***REMOVED***;
var BlockValue = /*#__PURE__*/function (_Node) ***REMOVED***
  _inherits(BlockValue, _Node);

  var _super = _createSuper(BlockValue);

  function BlockValue(type, props) ***REMOVED***
    var _this;

    _classCallCheck(this, BlockValue);

    _this = _super.call(this, type, props);
    _this.blockIndent = null;
    _this.chomping = Chomp.CLIP;
    _this.header = null;
    return _this;
***REMOVED***

  _createClass(BlockValue, [***REMOVED***
    key: "includesTrailingLines",
    get: function get() ***REMOVED***
      return this.chomping === Chomp.KEEP;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "strValue",
    get: function get() ***REMOVED***
      if (!this.valueRange || !this.context) return null;
      var _this$valueRange = this.valueRange,
          start = _this$valueRange.start,
          end = _this$valueRange.end;
      var _this$context = this.context,
          indent = _this$context.indent,
          src = _this$context.src;
      if (this.valueRange.isEmpty()) return '';
      var lastNewLine = null;
      var ch = src[end - 1];

      while (ch === '\n' || ch === '\t' || ch === ' ') ***REMOVED***
        end -= 1;

        if (end <= start) ***REMOVED***
          if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens
    ***REMOVED***

        if (ch === '\n') lastNewLine = end;
        ch = src[end - 1];
  ***REMOVED***

      var keepStart = end + 1;

      if (lastNewLine) ***REMOVED***
        if (this.chomping === Chomp.KEEP) ***REMOVED***
          keepStart = lastNewLine;
          end = this.valueRange.end;
    ***REMOVED*** else ***REMOVED***
          end = lastNewLine;
    ***REMOVED***
  ***REMOVED***

      var bi = indent + this.blockIndent;
      var folded = this.type === Type.BLOCK_FOLDED;
      var atStart = true;
      var str = '';
      var sep = '';
      var prevMoreIndented = false;

      for (var i = start; i < end; ++i) ***REMOVED***
        for (var j = 0; j < bi; ++j) ***REMOVED***
          if (src[i] !== ' ') break;
          i += 1;
    ***REMOVED***

        var _ch = src[i];

        if (_ch === '\n') ***REMOVED***
          if (sep === '\n') str += '\n';else sep = '\n';
    ***REMOVED*** else ***REMOVED***
          var lineEnd = Node.endOfLine(src, i);
          var line = src.slice(i, lineEnd);
          i = lineEnd;

          if (folded && (_ch === ' ' || _ch === '\t') && i < keepStart) ***REMOVED***
            if (sep === ' ') sep = '\n';else if (!prevMoreIndented && !atStart && sep === '\n') sep = '\n\n';
            str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')

            sep = lineEnd < end && src[lineEnd] || '';
            prevMoreIndented = true;
      ***REMOVED*** else ***REMOVED***
            str += sep + line;
            sep = folded && i < keepStart ? ' ' : '\n';
            prevMoreIndented = false;
      ***REMOVED***

          if (atStart && line !== '') atStart = false;
    ***REMOVED***
  ***REMOVED***

      return this.chomping === Chomp.STRIP ? str : str + '\n';
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "parseBlockHeader",
    value: function parseBlockHeader(start) ***REMOVED***
      var src = this.context.src;
      var offset = start + 1;
      var bi = '';

      while (true) ***REMOVED***
        var ch = src[offset];

        switch (ch) ***REMOVED***
          case '-':
            this.chomping = Chomp.STRIP;
            break;

          case '+':
            this.chomping = Chomp.KEEP;
            break;

          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            bi += ch;
            break;

          default:
            this.blockIndent = Number(bi) || null;
            this.header = new Range(start, offset);
            return offset;
    ***REMOVED***

        offset += 1;
  ***REMOVED***
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "parseBlockValue",
    value: function parseBlockValue(start) ***REMOVED***
      var _this$context2 = this.context,
          indent = _this$context2.indent,
          src = _this$context2.src;
      var explicit = !!this.blockIndent;
      var offset = start;
      var valueEnd = start;
      var minBlockIndent = 1;

      for (var ch = src[offset]; ch === '\n'; ch = src[offset]) ***REMOVED***
        offset += 1;
        if (Node.atDocumentBoundary(src, offset)) break;
        var end = Node.endOfBlockIndent(src, indent, offset); // should not include tab?

        if (end === null) break;
        var _ch2 = src[end];
        var lineIndent = end - (offset + indent);

        if (!this.blockIndent) ***REMOVED***
          // no explicit block indent, none yet detected
          if (src[end] !== '\n') ***REMOVED***
            // first line with non-whitespace content
            if (lineIndent < minBlockIndent) ***REMOVED***
              var msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';
              this.error = new YAMLSemanticError(this, msg);
        ***REMOVED***

            this.blockIndent = lineIndent;
      ***REMOVED*** else if (lineIndent > minBlockIndent) ***REMOVED***
            // empty line with more whitespace
            minBlockIndent = lineIndent;
      ***REMOVED***
    ***REMOVED*** else if (_ch2 && _ch2 !== '\n' && lineIndent < this.blockIndent) ***REMOVED***
          if (src[end] === '#') break;

          if (!this.error) ***REMOVED***
            var _src = explicit ? 'explicit indentation indicator' : 'first line';

            var _msg = "Block scalars must not be less indented than their ".concat(_src);

            this.error = new YAMLSemanticError(this, _msg);
      ***REMOVED***
    ***REMOVED***

        if (src[end] === '\n') ***REMOVED***
          offset = end;
    ***REMOVED*** else ***REMOVED***
          offset = valueEnd = Node.endOfLine(src, end);
    ***REMOVED***
  ***REMOVED***

      if (this.chomping !== Chomp.KEEP) ***REMOVED***
        offset = src[valueEnd] ? valueEnd + 1 : valueEnd;
  ***REMOVED***

      this.valueRange = new Range(start + 1, offset);
      return offset;
***REMOVED***
    /**
     * Parses a block value from the source
     *
     * Accepted forms are:
     * ```
     * BS
     * block
     * lines
     *
     * BS #comment
     * block
     * lines
     * ```
     * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines
     * are empty or have an indent level greater than `indent`.
     *
     * @param ***REMOVED***ParseContext***REMOVED*** context
     * @param ***REMOVED***number***REMOVED*** start - Index of first character
     * @returns ***REMOVED***number***REMOVED*** - Index of the character after this block
     */

***REMOVED*** ***REMOVED***
    key: "parse",
    value: function parse(context, start) ***REMOVED***
      this.context = context;
      var src = context.src;
      var offset = this.parseBlockHeader(start);
      offset = Node.endOfWhiteSpace(src, offset);
      offset = this.parseComment(offset);
      offset = this.parseBlockValue(offset);
      return offset;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "setOrigRanges",
    value: function setOrigRanges(cr, offset) ***REMOVED***
      offset = _get(_getPrototypeOf(BlockValue.prototype), "setOrigRanges", this).call(this, cr, offset);
      return this.header ? this.header.setOrigRange(cr, offset) : offset;
***REMOVED***
***REMOVED***]);

  return BlockValue;
***REMOVED***(Node);

var FlowCollection = /*#__PURE__*/function (_Node) ***REMOVED***
  _inherits(FlowCollection, _Node);

  var _super = _createSuper(FlowCollection);

  function FlowCollection(type, props) ***REMOVED***
    var _this;

    _classCallCheck(this, FlowCollection);

    _this = _super.call(this, type, props);
    _this.items = null;
    return _this;
***REMOVED***

  _createClass(FlowCollection, [***REMOVED***
    key: "prevNodeIsJsonLike",
    value: function prevNodeIsJsonLike() ***REMOVED***
      var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;
      var node = this.items[idx - 1];
      return !!node && (node.jsonLike || node.type === Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));
***REMOVED***
    /**
     * @param ***REMOVED***ParseContext***REMOVED*** context
     * @param ***REMOVED***number***REMOVED*** start - Index of first character
     * @returns ***REMOVED***number***REMOVED*** - Index of the character after this
     */

***REMOVED*** ***REMOVED***
    key: "parse",
    value: function parse(context, start) ***REMOVED***
      this.context = context;
      var parseNode = context.parseNode,
          src = context.src;
      var indent = context.indent,
          lineStart = context.lineStart;
      var char = src[start]; // ***REMOVED*** or [

      this.items = [***REMOVED***
        char: char,
        offset: start
  ***REMOVED***];
      var offset = Node.endOfWhiteSpace(src, start + 1);
      char = src[offset];

      while (char && char !== ']' && char !== '***REMOVED***') ***REMOVED***
        switch (char) ***REMOVED***
          case '\n':
            ***REMOVED***
              lineStart = offset + 1;
              var wsEnd = Node.endOfWhiteSpace(src, lineStart);

              if (src[wsEnd] === '\n') ***REMOVED***
                var blankLine = new BlankLine();
                lineStart = blankLine.parse(***REMOVED***
                  src: src
            ***REMOVED***, lineStart);
                this.items.push(blankLine);
          ***REMOVED***

              offset = Node.endOfIndent(src, lineStart);

              if (offset <= lineStart + indent) ***REMOVED***
                char = src[offset];

                if (offset < lineStart + indent || char !== ']' && char !== '***REMOVED***') ***REMOVED***
                  var msg = 'Insufficient indentation in flow collection';
                  this.error = new YAMLSemanticError(this, msg);
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
            break;

          case ',':
            ***REMOVED***
              this.items.push(***REMOVED***
                char: char,
                offset: offset
          ***REMOVED***);
              offset += 1;
        ***REMOVED***
            break;

          case '#':
            ***REMOVED***
              var comment = new Comment();
              offset = comment.parse(***REMOVED***
                src: src
          ***REMOVED***, offset);
              this.items.push(comment);
        ***REMOVED***
            break;

          case '?':
          case ':':
            ***REMOVED***
              var next = src[offset + 1];

              if (next === '\n' || next === '\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace
              char === ':' && this.prevNodeIsJsonLike()) ***REMOVED***
                this.items.push(***REMOVED***
                  char: char,
                  offset: offset
            ***REMOVED***);
                offset += 1;
                break;
          ***REMOVED***
        ***REMOVED***
          // fallthrough

          default:
            ***REMOVED***
              var node = parseNode(***REMOVED***
                atLineStart: false,
                inCollection: false,
                inFlow: true,
                indent: -1,
                lineStart: lineStart,
                parent: this
          ***REMOVED***, offset);

              if (!node) ***REMOVED***
                // at next document start
                this.valueRange = new Range(start, offset);
                return offset;
          ***REMOVED***

              this.items.push(node);
              offset = Node.normalizeOffset(src, node.range.end);
        ***REMOVED***
    ***REMOVED***

        offset = Node.endOfWhiteSpace(src, offset);
        char = src[offset];
  ***REMOVED***

      this.valueRange = new Range(start, offset + 1);

      if (char) ***REMOVED***
        this.items.push(***REMOVED***
          char: char,
          offset: offset
    ***REMOVED***);
        offset = Node.endOfWhiteSpace(src, offset + 1);
        offset = this.parseComment(offset);
  ***REMOVED***

      return offset;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "setOrigRanges",
    value: function setOrigRanges(cr, offset) ***REMOVED***
      offset = _get(_getPrototypeOf(FlowCollection.prototype), "setOrigRanges", this).call(this, cr, offset);
      this.items.forEach(function (node) ***REMOVED***
        if (node instanceof Node) ***REMOVED***
          offset = node.setOrigRanges(cr, offset);
    ***REMOVED*** else if (cr.length === 0) ***REMOVED***
          node.origOffset = node.offset;
    ***REMOVED*** else ***REMOVED***
          var i = offset;

          while (i < cr.length) ***REMOVED***
            if (cr[i] > node.offset) break;else ++i;
      ***REMOVED***

          node.origOffset = node.offset + i;
          offset = i;
    ***REMOVED***
  ***REMOVED***);
      return offset;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "toString",
    value: function toString() ***REMOVED***
      var src = this.context.src,
          items = this.items,
          range = this.range,
          value = this.value;
      if (value != null) return value;
      var nodes = items.filter(function (item) ***REMOVED***
        return item instanceof Node;
  ***REMOVED***);
      var str = '';
      var prevEnd = range.start;
      nodes.forEach(function (node) ***REMOVED***
        var prefix = src.slice(prevEnd, node.range.start);
        prevEnd = node.range.end;
        str += prefix + String(node);

        if (str[str.length - 1] === '\n' && src[prevEnd - 1] !== '\n' && src[prevEnd] === '\n') ***REMOVED***
          // Comment range does not include the terminal newline, but its
          // stringified value does. Without this fix, newlines at comment ends
          // get duplicated.
          prevEnd += 1;
    ***REMOVED***
  ***REMOVED***);
      str += src.slice(prevEnd, range.end);
      return Node.addStringTerminator(src, range.end, str);
***REMOVED***
***REMOVED***]);

  return FlowCollection;
***REMOVED***(Node);

var QuoteDouble = /*#__PURE__*/function (_Node) ***REMOVED***
  _inherits(QuoteDouble, _Node);

  var _super = _createSuper(QuoteDouble);

  function QuoteDouble() ***REMOVED***
    _classCallCheck(this, QuoteDouble);

    return _super.apply(this, arguments);
***REMOVED***

  _createClass(QuoteDouble, [***REMOVED***
    key: "strValue",
    get:
    /**
     * @returns ***REMOVED***string | ***REMOVED*** str: string, errors: YAMLSyntaxError[] ***REMOVED******REMOVED***
     */
    function get() ***REMOVED***
      if (!this.valueRange || !this.context) return null;
      var errors = [];
      var _this$valueRange = this.valueRange,
          start = _this$valueRange.start,
          end = _this$valueRange.end;
      var _this$context = this.context,
          indent = _this$context.indent,
          src = _this$context.src;
      if (src[end - 1] !== '"') errors.push(new YAMLSyntaxError(this, 'Missing closing "quote')); // Using String#replace is too painful with escaped newlines preceded by
      // escaped backslashes; also, this should be faster.

      var str = '';

      for (var i = start + 1; i < end - 1; ++i) ***REMOVED***
        var ch = src[i];

        if (ch === '\n') ***REMOVED***
          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));

          var _Node$foldNewline = Node.foldNewline(src, i, indent),
              fold = _Node$foldNewline.fold,
              offset = _Node$foldNewline.offset,
              error = _Node$foldNewline.error;

          str += fold;
          i = offset;
          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));
    ***REMOVED*** else if (ch === '\\') ***REMOVED***
          i += 1;

          switch (src[i]) ***REMOVED***
            case '0':
              str += '\0';
              break;
            // null character

            case 'a':
              str += '\x07';
              break;
            // bell character

            case 'b':
              str += '\b';
              break;
            // backspace

            case 'e':
              str += '\x1b';
              break;
            // escape character

            case 'f':
              str += '\f';
              break;
            // form feed

            case 'n':
              str += '\n';
              break;
            // line feed

            case 'r':
              str += '\r';
              break;
            // carriage return

            case 't':
              str += '\t';
              break;
            // horizontal tab

            case 'v':
              str += '\v';
              break;
            // vertical tab

            case 'N':
              str += "\x85";
              break;
            // Unicode next line

            case '_':
              str += "\xA0";
              break;
            // Unicode non-breaking space

            case 'L':
              str += "\u2028";
              break;
            // Unicode line separator

            case 'P':
              str += "\u2029";
              break;
            // Unicode paragraph separator

            case ' ':
              str += ' ';
              break;

            case '"':
              str += '"';
              break;

            case '/':
              str += '/';
              break;

            case '\\':
              str += '\\';
              break;

            case '\t':
              str += '\t';
              break;

            case 'x':
              str += this.parseCharCode(i + 1, 2, errors);
              i += 2;
              break;

            case 'u':
              str += this.parseCharCode(i + 1, 4, errors);
              i += 4;
              break;

            case 'U':
              str += this.parseCharCode(i + 1, 8, errors);
              i += 8;
              break;

            case '\n':
              // skip escaped newlines, but still trim the following line
              while (src[i + 1] === ' ' || src[i + 1] === '\t') ***REMOVED***
                i += 1;
          ***REMOVED***

              break;

            default:
              errors.push(new YAMLSyntaxError(this, "Invalid escape sequence ".concat(src.substr(i - 1, 2))));
              str += '\\' + src[i];
      ***REMOVED***
    ***REMOVED*** else if (ch === ' ' || ch === '\t') ***REMOVED***
          // trim trailing whitespace
          var wsStart = i;
          var next = src[i + 1];

          while (next === ' ' || next === '\t') ***REMOVED***
            i += 1;
            next = src[i + 1];
      ***REMOVED***

          if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
    ***REMOVED*** else ***REMOVED***
          str += ch;
    ***REMOVED***
  ***REMOVED***

      return errors.length > 0 ? ***REMOVED***
        errors: errors,
        str: str
  ***REMOVED*** : str;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "parseCharCode",
    value: function parseCharCode(offset, length, errors) ***REMOVED***
      var src = this.context.src;
      var cc = src.substr(offset, length);
      var ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
      var code = ok ? parseInt(cc, 16) : NaN;

      if (isNaN(code)) ***REMOVED***
        errors.push(new YAMLSyntaxError(this, "Invalid escape sequence ".concat(src.substr(offset - 2, length + 2))));
        return src.substr(offset - 2, length + 2);
  ***REMOVED***

      return String.fromCodePoint(code);
***REMOVED***
    /**
     * Parses a "double quoted" value from the source
     *
     * @param ***REMOVED***ParseContext***REMOVED*** context
     * @param ***REMOVED***number***REMOVED*** start - Index of first character
     * @returns ***REMOVED***number***REMOVED*** - Index of the character after this scalar
     */

***REMOVED*** ***REMOVED***
    key: "parse",
    value: function parse(context, start) ***REMOVED***
      this.context = context;
      var src = context.src;
      var offset = QuoteDouble.endOfQuote(src, start + 1);
      this.valueRange = new Range(start, offset);
      offset = Node.endOfWhiteSpace(src, offset);
      offset = this.parseComment(offset);
      return offset;
***REMOVED***
***REMOVED***], [***REMOVED***
    key: "endOfQuote",
    value: function endOfQuote(src, offset) ***REMOVED***
      var ch = src[offset];

      while (ch && ch !== '"') ***REMOVED***
        offset += ch === '\\' ? 2 : 1;
        ch = src[offset];
  ***REMOVED***

      return offset + 1;
***REMOVED***
***REMOVED***]);

  return QuoteDouble;
***REMOVED***(Node);

var QuoteSingle = /*#__PURE__*/function (_Node) ***REMOVED***
  _inherits(QuoteSingle, _Node);

  var _super = _createSuper(QuoteSingle);

  function QuoteSingle() ***REMOVED***
    _classCallCheck(this, QuoteSingle);

    return _super.apply(this, arguments);
***REMOVED***

  _createClass(QuoteSingle, [***REMOVED***
    key: "strValue",
    get:
    /**
     * @returns ***REMOVED***string | ***REMOVED*** str: string, errors: YAMLSyntaxError[] ***REMOVED******REMOVED***
     */
    function get() ***REMOVED***
      if (!this.valueRange || !this.context) return null;
      var errors = [];
      var _this$valueRange = this.valueRange,
          start = _this$valueRange.start,
          end = _this$valueRange.end;
      var _this$context = this.context,
          indent = _this$context.indent,
          src = _this$context.src;
      if (src[end - 1] !== "'") errors.push(new YAMLSyntaxError(this, "Missing closing 'quote"));
      var str = '';

      for (var i = start + 1; i < end - 1; ++i) ***REMOVED***
        var ch = src[i];

        if (ch === '\n') ***REMOVED***
          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));

          var _Node$foldNewline = Node.foldNewline(src, i, indent),
              fold = _Node$foldNewline.fold,
              offset = _Node$foldNewline.offset,
              error = _Node$foldNewline.error;

          str += fold;
          i = offset;
          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));
    ***REMOVED*** else if (ch === "'") ***REMOVED***
          str += ch;
          i += 1;
          if (src[i] !== "'") errors.push(new YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));
    ***REMOVED*** else if (ch === ' ' || ch === '\t') ***REMOVED***
          // trim trailing whitespace
          var wsStart = i;
          var next = src[i + 1];

          while (next === ' ' || next === '\t') ***REMOVED***
            i += 1;
            next = src[i + 1];
      ***REMOVED***

          if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
    ***REMOVED*** else ***REMOVED***
          str += ch;
    ***REMOVED***
  ***REMOVED***

      return errors.length > 0 ? ***REMOVED***
        errors: errors,
        str: str
  ***REMOVED*** : str;
***REMOVED***
    /**
     * Parses a 'single quoted' value from the source
     *
     * @param ***REMOVED***ParseContext***REMOVED*** context
     * @param ***REMOVED***number***REMOVED*** start - Index of first character
     * @returns ***REMOVED***number***REMOVED*** - Index of the character after this scalar
     */

***REMOVED*** ***REMOVED***
    key: "parse",
    value: function parse(context, start) ***REMOVED***
      this.context = context;
      var src = context.src;
      var offset = QuoteSingle.endOfQuote(src, start + 1);
      this.valueRange = new Range(start, offset);
      offset = Node.endOfWhiteSpace(src, offset);
      offset = this.parseComment(offset);
      return offset;
***REMOVED***
***REMOVED***], [***REMOVED***
    key: "endOfQuote",
    value: function endOfQuote(src, offset) ***REMOVED***
      var ch = src[offset];

      while (ch) ***REMOVED***
        if (ch === "'") ***REMOVED***
          if (src[offset + 1] !== "'") break;
          ch = src[offset += 2];
    ***REMOVED*** else ***REMOVED***
          ch = src[offset += 1];
    ***REMOVED***
  ***REMOVED***

      return offset + 1;
***REMOVED***
***REMOVED***]);

  return QuoteSingle;
***REMOVED***(Node);

function createNewNode(type, props) ***REMOVED***
  switch (type) ***REMOVED***
    case Type.ALIAS:
      return new Alias(type, props);

    case Type.BLOCK_FOLDED:
    case Type.BLOCK_LITERAL:
      return new BlockValue(type, props);

    case Type.FLOW_MAP:
    case Type.FLOW_SEQ:
      return new FlowCollection(type, props);

    case Type.MAP_KEY:
    case Type.MAP_VALUE:
    case Type.SEQ_ITEM:
      return new CollectionItem(type, props);

    case Type.COMMENT:
    case Type.PLAIN:
      return new PlainValue(type, props);

    case Type.QUOTE_DOUBLE:
      return new QuoteDouble(type, props);

    case Type.QUOTE_SINGLE:
      return new QuoteSingle(type, props);

    /* istanbul ignore next */

    default:
      return null;
    // should never happen
***REMOVED***
***REMOVED***
/**
 * @param ***REMOVED***boolean***REMOVED*** atLineStart - Node starts at beginning of line
 * @param ***REMOVED***boolean***REMOVED*** inFlow - true if currently in a flow context
 * @param ***REMOVED***boolean***REMOVED*** inCollection - true if currently in a collection context
 * @param ***REMOVED***number***REMOVED*** indent - Current level of indentation
 * @param ***REMOVED***number***REMOVED*** lineStart - Start of the current line
 * @param ***REMOVED***Node***REMOVED*** parent - The parent of the node
 * @param ***REMOVED***string***REMOVED*** src - Source of the YAML document
 */


var ParseContext = /*#__PURE__*/function () ***REMOVED***
  function ParseContext() ***REMOVED***
    var _this = this;

    var orig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ***REMOVED******REMOVED***;

    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ***REMOVED******REMOVED***,
        atLineStart = _ref.atLineStart,
        inCollection = _ref.inCollection,
        inFlow = _ref.inFlow,
        indent = _ref.indent,
        lineStart = _ref.lineStart,
        parent = _ref.parent;

    _classCallCheck(this, ParseContext);

    _defineProperty(this, "parseNode", function (overlay, start) ***REMOVED***
      if (Node.atDocumentBoundary(_this.src, start)) return null;
      var context = new ParseContext(_this, overlay);

      var _context$parseProps = context.parseProps(start),
          props = _context$parseProps.props,
          type = _context$parseProps.type,
          valueStart = _context$parseProps.valueStart;

      var node = createNewNode(type, props);
      var offset = node.parse(context, valueStart);
      node.range = new Range(start, offset);
      /* istanbul ignore if */

      if (offset <= start) ***REMOVED***
        // This should never happen, but if it does, let's make sure to at least
        // step one character forward to avoid a busy loop.
        node.error = new Error("Node#parse consumed no characters");
        node.error.parseEnd = offset;
        node.error.source = node;
        node.range.end = start + 1;
  ***REMOVED***

      if (context.nodeStartsCollection(node)) ***REMOVED***
        if (!node.error && !context.atLineStart && context.parent.type === Type.DOCUMENT) ***REMOVED***
          node.error = new YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');
    ***REMOVED***

        var collection = new Collection(node);
        offset = collection.parse(new ParseContext(context), offset);
        collection.range = new Range(start, offset);
        return collection;
  ***REMOVED***

      return node;
***REMOVED***);

    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;
    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;
    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;
    this.indent = indent != null ? indent : orig.indent;
    this.lineStart = lineStart != null ? lineStart : orig.lineStart;
    this.parent = parent != null ? parent : orig.parent || ***REMOVED******REMOVED***;
    this.root = orig.root;
    this.src = orig.src;
***REMOVED***

  _createClass(ParseContext, [***REMOVED***
    key: "nodeStartsCollection",
    value: function nodeStartsCollection(node) ***REMOVED***
      var inCollection = this.inCollection,
          inFlow = this.inFlow,
          src = this.src;
      if (inCollection || inFlow) return false;
      if (node instanceof CollectionItem) return true; // check for implicit key

      var offset = node.range.end;
      if (src[offset] === '\n' || src[offset - 1] === '\n') return false;
      offset = Node.endOfWhiteSpace(src, offset);
      return src[offset] === ':';
***REMOVED*** // Anchor and tag are before type, which determines the node implementation
    // class; hence this intermediate step.

***REMOVED*** ***REMOVED***
    key: "parseProps",
    value: function parseProps(offset) ***REMOVED***
      var inFlow = this.inFlow,
          parent = this.parent,
          src = this.src;
      var props = [];
      var lineHasProps = false;
      offset = this.atLineStart ? Node.endOfIndent(src, offset) : Node.endOfWhiteSpace(src, offset);
      var ch = src[offset];

      while (ch === Char.ANCHOR || ch === Char.COMMENT || ch === Char.TAG || ch === '\n') ***REMOVED***
        if (ch === '\n') ***REMOVED***
          var inEnd = offset;
          var lineStart = void 0;

          do ***REMOVED***
            lineStart = inEnd + 1;
            inEnd = Node.endOfIndent(src, lineStart);
      ***REMOVED*** while (src[inEnd] === '\n');

          var indentDiff = inEnd - (lineStart + this.indent);
          var noIndicatorAsIndent = parent.type === Type.SEQ_ITEM && parent.context.atLineStart;
          if (src[inEnd] !== '#' && !Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;
          this.atLineStart = true;
          this.lineStart = lineStart;
          lineHasProps = false;
          offset = inEnd;
    ***REMOVED*** else if (ch === Char.COMMENT) ***REMOVED***
          var end = Node.endOfLine(src, offset + 1);
          props.push(new Range(offset, end));
          offset = end;
    ***REMOVED*** else ***REMOVED***
          var _end = Node.endOfIdentifier(src, offset + 1);

          if (ch === Char.TAG && src[_end] === ',' && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d)***REMOVED***0,2***REMOVED***\/\S/.test(src.slice(offset + 1, _end + 13))) ***REMOVED***
            // Let's presume we're dealing with a YAML 1.0 domain tag here, rather
            // than an empty but 'foo.bar' private-tagged node in a flow collection
            // followed without whitespace by a plain string starting with a year
            // or date divided by something.
            _end = Node.endOfIdentifier(src, _end + 5);
      ***REMOVED***

          props.push(new Range(offset, _end));
          lineHasProps = true;
          offset = Node.endOfWhiteSpace(src, _end);
    ***REMOVED***

        ch = src[offset];
  ***REMOVED*** // '- &a : b' has an anchor on an empty node


      if (lineHasProps && ch === ':' && Node.atBlank(src, offset + 1, true)) offset -= 1;
      var type = ParseContext.parseType(src, offset, inFlow);
      return ***REMOVED***
        props: props,
        type: type,
        valueStart: offset
  ***REMOVED***;
***REMOVED***
    /**
     * Parses a node from the source
     * @param ***REMOVED***ParseContext***REMOVED*** overlay
     * @param ***REMOVED***number***REMOVED*** start - Index of first non-whitespace character for the node
     * @returns ***REMOVED***?Node***REMOVED*** - null if at a document boundary
     */

***REMOVED***], [***REMOVED***
    key: "parseType",
    value: function parseType(src, offset, inFlow) ***REMOVED***
      switch (src[offset]) ***REMOVED***
        case '*':
          return Type.ALIAS;

        case '>':
          return Type.BLOCK_FOLDED;

        case '|':
          return Type.BLOCK_LITERAL;

        case '***REMOVED***':
          return Type.FLOW_MAP;

        case '[':
          return Type.FLOW_SEQ;

        case '?':
          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_KEY : Type.PLAIN;

        case ':':
          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_VALUE : Type.PLAIN;

        case '-':
          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.SEQ_ITEM : Type.PLAIN;

        case '"':
          return Type.QUOTE_DOUBLE;

        case "'":
          return Type.QUOTE_SINGLE;

        default:
          return Type.PLAIN;
  ***REMOVED***
***REMOVED***
***REMOVED***]);

  return ParseContext;
***REMOVED***();

// Published as 'yaml/parse-cst'
function parse(src) ***REMOVED***
  var cr = [];

  if (src.indexOf('\r') !== -1) ***REMOVED***
    src = src.replace(/\r\n?/g, function (match, offset) ***REMOVED***
      if (match.length > 1) cr.push(offset);
      return '\n';
***REMOVED***);
***REMOVED***

  var documents = [];
  var offset = 0;

  do ***REMOVED***
    var doc = new Document();
    var context = new ParseContext(***REMOVED***
      src: src
***REMOVED***);
    offset = doc.parse(context, offset);
    documents.push(doc);
***REMOVED*** while (offset < src.length);

  documents.setOrigRanges = function () ***REMOVED***
    if (cr.length === 0) return false;

    for (var i = 1; i < cr.length; ++i) ***REMOVED***
      cr[i] -= i;
***REMOVED***

    var crOffset = 0;

    for (var _i = 0; _i < documents.length; ++_i) ***REMOVED***
      crOffset = documents[_i].setOrigRanges(cr, crOffset);
***REMOVED***

    cr.splice(0, cr.length);
    return true;
***REMOVED***;

  documents.toString = function () ***REMOVED***
    return documents.join('...\n');
***REMOVED***;

  return documents;
***REMOVED***

export ***REMOVED*** parse ***REMOVED***;
