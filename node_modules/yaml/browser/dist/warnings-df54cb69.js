import ***REMOVED*** o as YAMLReferenceError, T as Type, g as YAMLSemanticError, _ as _createForOfIteratorHelper, e as _defineProperty, j as _inherits, k as _createSuper, c as _classCallCheck, p as _assertThisInitialized, b as _createClass, a as _typeof, l as _get, m as _getPrototypeOf ***REMOVED*** from './PlainValue-b8036b75.js';
import ***REMOVED*** j as resolveString, b as binaryOptions, c as stringifyString, h as resolveSeq, P as Pair, d as YAMLMap, Y as YAMLSeq, t as toJSON, S as Scalar, l as findPair, g as resolveMap, k as stringifyNumber ***REMOVED*** from './resolveSeq-492ab440.js';

/* global atob, btoa, Buffer */
var binary = ***REMOVED***
  identify: function identify(value) ***REMOVED***
    return value instanceof Uint8Array;
***REMOVED***
  // Buffer inherits from Uint8Array
  default: false,
  tag: 'tag:yaml.org,2002:binary',

  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], ***REMOVED*** type: 'image/jpeg' ***REMOVED***)
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve: function resolve(doc, node) ***REMOVED***
    var src = resolveString(doc, node);

    if (typeof Buffer === 'function') ***REMOVED***
      return Buffer.from(src, 'base64');
***REMOVED*** else if (typeof atob === 'function') ***REMOVED***
      // On IE 11, atob() can't handle newlines
      var str = atob(src.replace(/[\n\r]/g, ''));
      var buffer = new Uint8Array(str.length);

      for (var i = 0; i < str.length; ++i) ***REMOVED***
        buffer[i] = str.charCodeAt(i);
  ***REMOVED***

      return buffer;
***REMOVED*** else ***REMOVED***
      var msg = 'This environment does not support reading binary tags; either Buffer or atob is required';
      doc.errors.push(new YAMLReferenceError(node, msg));
      return null;
***REMOVED***
***REMOVED***
  options: binaryOptions,
  stringify: function stringify(_ref, ctx, onComment, onChompKeep) ***REMOVED***
    var comment = _ref.comment,
        type = _ref.type,
        value = _ref.value;
    var src;

    if (typeof Buffer === 'function') ***REMOVED***
      src = value instanceof Buffer ? value.toString('base64') : Buffer.from(value.buffer).toString('base64');
***REMOVED*** else if (typeof btoa === 'function') ***REMOVED***
      var s = '';

      for (var i = 0; i < value.length; ++i) ***REMOVED***
        s += String.fromCharCode(value[i]);
  ***REMOVED***

      src = btoa(s);
***REMOVED*** else ***REMOVED***
      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
***REMOVED***

    if (!type) type = binaryOptions.defaultType;

    if (type === Type.QUOTE_DOUBLE) ***REMOVED***
      value = src;
***REMOVED*** else ***REMOVED***
      var lineWidth = binaryOptions.lineWidth;
      var n = Math.ceil(src.length / lineWidth);
      var lines = new Array(n);

      for (var _i = 0, o = 0; _i < n; ++_i, o += lineWidth) ***REMOVED***
        lines[_i] = src.substr(o, lineWidth);
  ***REMOVED***

      value = lines.join(type === Type.BLOCK_LITERAL ? '\n' : ' ');
***REMOVED***

    return stringifyString(***REMOVED***
      comment: comment,
      type: type,
      value: value
***REMOVED***, ctx, onComment, onChompKeep);
***REMOVED***
***REMOVED***;

function parsePairs(doc, cst) ***REMOVED***
  var seq = resolveSeq(doc, cst);

  for (var i = 0; i < seq.items.length; ++i) ***REMOVED***
    var item = seq.items[i];
    if (item instanceof Pair) continue;else if (item instanceof YAMLMap) ***REMOVED***
      if (item.items.length > 1) ***REMOVED***
        var msg = 'Each pair must have its own sequence indicator';
        throw new YAMLSemanticError(cst, msg);
  ***REMOVED***

      var pair = item.items[0] || new Pair();
      if (item.commentBefore) pair.commentBefore = pair.commentBefore ? "".concat(item.commentBefore, "\n").concat(pair.commentBefore) : item.commentBefore;
      if (item.comment) pair.comment = pair.comment ? "".concat(item.comment, "\n").concat(pair.comment) : item.comment;
      item = pair;
***REMOVED***
    seq.items[i] = item instanceof Pair ? item : new Pair(item);
***REMOVED***

  return seq;
***REMOVED***
function createPairs(schema, iterable, ctx) ***REMOVED***
  var pairs = new YAMLSeq(schema);
  pairs.tag = 'tag:yaml.org,2002:pairs';

  var _iterator = _createForOfIteratorHelper(iterable),
      _step;

  try ***REMOVED***
    for (_iterator.s(); !(_step = _iterator.n()).done;) ***REMOVED***
      var it = _step.value;
      var key = void 0,
          value = void 0;

      if (Array.isArray(it)) ***REMOVED***
        if (it.length === 2) ***REMOVED***
          key = it[0];
          value = it[1];
    ***REMOVED*** else throw new TypeError("Expected [key, value] tuple: ".concat(it));
  ***REMOVED*** else if (it && it instanceof Object) ***REMOVED***
        var keys = Object.keys(it);

        if (keys.length === 1) ***REMOVED***
          key = keys[0];
          value = it[key];
    ***REMOVED*** else throw new TypeError("Expected ***REMOVED*** key: value ***REMOVED*** tuple: ".concat(it));
  ***REMOVED*** else ***REMOVED***
        key = it;
  ***REMOVED***

      var pair = schema.createPair(key, value, ctx);
      pairs.items.push(pair);
***REMOVED***
***REMOVED*** catch (err) ***REMOVED***
    _iterator.e(err);
***REMOVED*** finally ***REMOVED***
    _iterator.f();
***REMOVED***

  return pairs;
***REMOVED***
var pairs = ***REMOVED***
  default: false,
  tag: 'tag:yaml.org,2002:pairs',
  resolve: parsePairs,
  createNode: createPairs
***REMOVED***;

var YAMLOMap = /*#__PURE__*/function (_YAMLSeq) ***REMOVED***
  _inherits(YAMLOMap, _YAMLSeq);

  var _super = _createSuper(YAMLOMap);

  function YAMLOMap() ***REMOVED***
    var _this;

    _classCallCheck(this, YAMLOMap);

    _this = _super.call(this);

    _defineProperty(_assertThisInitialized(_this), "add", YAMLMap.prototype.add.bind(_assertThisInitialized(_this)));

    _defineProperty(_assertThisInitialized(_this), "delete", YAMLMap.prototype.delete.bind(_assertThisInitialized(_this)));

    _defineProperty(_assertThisInitialized(_this), "get", YAMLMap.prototype.get.bind(_assertThisInitialized(_this)));

    _defineProperty(_assertThisInitialized(_this), "has", YAMLMap.prototype.has.bind(_assertThisInitialized(_this)));

    _defineProperty(_assertThisInitialized(_this), "set", YAMLMap.prototype.set.bind(_assertThisInitialized(_this)));

    _this.tag = YAMLOMap.tag;
    return _this;
***REMOVED***

  _createClass(YAMLOMap, [***REMOVED***
    key: "toJSON",
    value: function toJSON$1(_, ctx) ***REMOVED***
      var map = new Map();
      if (ctx && ctx.onCreate) ctx.onCreate(map);

      var _iterator = _createForOfIteratorHelper(this.items),
          _step;

      try ***REMOVED***
        for (_iterator.s(); !(_step = _iterator.n()).done;) ***REMOVED***
          var pair = _step.value;
          var key = void 0,
              value = void 0;

          if (pair instanceof Pair) ***REMOVED***
            key = toJSON(pair.key, '', ctx);
            value = toJSON(pair.value, key, ctx);
      ***REMOVED*** else ***REMOVED***
            key = toJSON(pair, '', ctx);
      ***REMOVED***

          if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');
          map.set(key, value);
    ***REMOVED***
  ***REMOVED*** catch (err) ***REMOVED***
        _iterator.e(err);
  ***REMOVED*** finally ***REMOVED***
        _iterator.f();
  ***REMOVED***

      return map;
***REMOVED***
***REMOVED***]);

  return YAMLOMap;
***REMOVED***(YAMLSeq);

_defineProperty(YAMLOMap, "tag", 'tag:yaml.org,2002:omap');

function parseOMap(doc, cst) ***REMOVED***
  var pairs = parsePairs(doc, cst);
  var seenKeys = [];

  var _iterator2 = _createForOfIteratorHelper(pairs.items),
      _step2;

  try ***REMOVED***
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) ***REMOVED***
      var key = _step2.value.key;

      if (key instanceof Scalar) ***REMOVED***
        if (seenKeys.includes(key.value)) ***REMOVED***
          var msg = 'Ordered maps must not include duplicate keys';
          throw new YAMLSemanticError(cst, msg);
    ***REMOVED*** else ***REMOVED***
          seenKeys.push(key.value);
    ***REMOVED***
  ***REMOVED***
***REMOVED***
***REMOVED*** catch (err) ***REMOVED***
    _iterator2.e(err);
***REMOVED*** finally ***REMOVED***
    _iterator2.f();
***REMOVED***

  return Object.assign(new YAMLOMap(), pairs);
***REMOVED***

function createOMap(schema, iterable, ctx) ***REMOVED***
  var pairs = createPairs(schema, iterable, ctx);
  var omap = new YAMLOMap();
  omap.items = pairs.items;
  return omap;
***REMOVED***

var omap = ***REMOVED***
  identify: function identify(value) ***REMOVED***
    return value instanceof Map;
***REMOVED***
  nodeClass: YAMLOMap,
  default: false,
  tag: 'tag:yaml.org,2002:omap',
  resolve: parseOMap,
  createNode: createOMap
***REMOVED***;

var YAMLSet = /*#__PURE__*/function (_YAMLMap) ***REMOVED***
  _inherits(YAMLSet, _YAMLMap);

  var _super = _createSuper(YAMLSet);

  function YAMLSet() ***REMOVED***
    var _this;

    _classCallCheck(this, YAMLSet);

    _this = _super.call(this);
    _this.tag = YAMLSet.tag;
    return _this;
***REMOVED***

  _createClass(YAMLSet, [***REMOVED***
    key: "add",
    value: function add(key) ***REMOVED***
      var pair = key instanceof Pair ? key : new Pair(key);
      var prev = findPair(this.items, pair.key);
      if (!prev) this.items.push(pair);
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "get",
    value: function get(key, keepPair) ***REMOVED***
      var pair = findPair(this.items, key);
      return !keepPair && pair instanceof Pair ? pair.key instanceof Scalar ? pair.key.value : pair.key : pair;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "set",
    value: function set(key, value) ***REMOVED***
      if (typeof value !== 'boolean') throw new Error("Expected boolean value for set(key, value) in a YAML set, not ".concat(_typeof(value)));
      var prev = findPair(this.items, key);

      if (prev && !value) ***REMOVED***
        this.items.splice(this.items.indexOf(prev), 1);
  ***REMOVED*** else if (!prev && value) ***REMOVED***
        this.items.push(new Pair(key));
  ***REMOVED***
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "toJSON",
    value: function toJSON(_, ctx) ***REMOVED***
      return _get(_getPrototypeOf(YAMLSet.prototype), "toJSON", this).call(this, _, ctx, Set);
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "toString",
    value: function toString(ctx, onComment, onChompKeep) ***REMOVED***
      if (!ctx) return JSON.stringify(this);
      if (this.hasAllNullValues()) return _get(_getPrototypeOf(YAMLSet.prototype), "toString", this).call(this, ctx, onComment, onChompKeep);else throw new Error('Set items must all have null values');
***REMOVED***
***REMOVED***]);

  return YAMLSet;
***REMOVED***(YAMLMap);

_defineProperty(YAMLSet, "tag", 'tag:yaml.org,2002:set');

function parseSet(doc, cst) ***REMOVED***
  var map = resolveMap(doc, cst);
  if (!map.hasAllNullValues()) throw new YAMLSemanticError(cst, 'Set items must all have null values');
  return Object.assign(new YAMLSet(), map);
***REMOVED***

function createSet(schema, iterable, ctx) ***REMOVED***
  var set = new YAMLSet();

  var _iterator = _createForOfIteratorHelper(iterable),
      _step;

  try ***REMOVED***
    for (_iterator.s(); !(_step = _iterator.n()).done;) ***REMOVED***
      var value = _step.value;
      set.items.push(schema.createPair(value, null, ctx));
***REMOVED***
***REMOVED*** catch (err) ***REMOVED***
    _iterator.e(err);
***REMOVED*** finally ***REMOVED***
    _iterator.f();
***REMOVED***

  return set;
***REMOVED***

var set = ***REMOVED***
  identify: function identify(value) ***REMOVED***
    return value instanceof Set;
***REMOVED***
  nodeClass: YAMLSet,
  default: false,
  tag: 'tag:yaml.org,2002:set',
  resolve: parseSet,
  createNode: createSet
***REMOVED***;

var parseSexagesimal = function parseSexagesimal(sign, parts) ***REMOVED***
  var n = parts.split(':').reduce(function (n, p) ***REMOVED***
    return n * 60 + Number(p);
***REMOVED*** 0);
  return sign === '-' ? -n : n;
***REMOVED***; // hhhh:mm:ss.sss


var stringifySexagesimal = function stringifySexagesimal(_ref) ***REMOVED***
  var value = _ref.value;
  if (isNaN(value) || !isFinite(value)) return stringifyNumber(value);
  var sign = '';

  if (value < 0) ***REMOVED***
    sign = '-';
    value = Math.abs(value);
***REMOVED***

  var parts = [value % 60]; // seconds, including ms

  if (value < 60) ***REMOVED***
    parts.unshift(0); // at least one : is required
***REMOVED*** else ***REMOVED***
    value = Math.round((value - parts[0]) / 60);
    parts.unshift(value % 60); // minutes

    if (value >= 60) ***REMOVED***
      value = Math.round((value - parts[0]) / 60);
      parts.unshift(value); // hours
***REMOVED***
***REMOVED***

  return sign + parts.map(function (n) ***REMOVED***
    return n < 10 ? '0' + String(n) : String(n);
***REMOVED***).join(':').replace(/000000\d*$/, '') // % 60 may introduce error
  ;
***REMOVED***;

var intTime = ***REMOVED***
  identify: function identify(value) ***REMOVED***
    return typeof value === 'number';
***REMOVED***
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'TIME',
  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
  resolve: function resolve(str, sign, parts) ***REMOVED***
    return parseSexagesimal(sign, parts.replace(/_/g, ''));
***REMOVED***
  stringify: stringifySexagesimal
***REMOVED***;
var floatTime = ***REMOVED***
  identify: function identify(value) ***REMOVED***
    return typeof value === 'number';
***REMOVED***
  default: true,
  tag: 'tag:yaml.org,2002:float',
  format: 'TIME',
  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
  resolve: function resolve(str, sign, parts) ***REMOVED***
    return parseSexagesimal(sign, parts.replace(/_/g, ''));
***REMOVED***
  stringify: stringifySexagesimal
***REMOVED***;
var timestamp = ***REMOVED***
  identify: function identify(value) ***REMOVED***
    return value instanceof Date;
***REMOVED***
  default: true,
  tag: 'tag:yaml.org,2002:timestamp',
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp('^(?:' + '([0-9]***REMOVED***4***REMOVED***)-([0-9]***REMOVED***1,2***REMOVED***)-([0-9]***REMOVED***1,2***REMOVED***)' + // YYYY-Mm-Dd
  '(?:(?:t|T|[ \\t]+)' + // t | T | whitespace
  '([0-9]***REMOVED***1,2***REMOVED***):([0-9]***REMOVED***1,2***REMOVED***):([0-9]***REMOVED***1,2***REMOVED***(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
  '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]***REMOVED***2***REMOVED***)?))?' + // Z | +5 | -03:30
  ')?' + ')$'),
  resolve: function resolve(str, year, month, day, hour, minute, second, millisec, tz) ***REMOVED***
    if (millisec) millisec = (millisec + '00').substr(1, 3);
    var date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);

    if (tz && tz !== 'Z') ***REMOVED***
      var d = parseSexagesimal(tz[0], tz.slice(1));
      if (Math.abs(d) < 30) d *= 60;
      date -= 60000 * d;
***REMOVED***

    return new Date(date);
***REMOVED***
  stringify: function stringify(_ref2) ***REMOVED***
    var value = _ref2.value;
    return value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, '');
***REMOVED***
***REMOVED***;

/* global console, process, YAML_SILENCE_DEPRECATION_WARNINGS, YAML_SILENCE_WARNINGS */
function shouldWarn(deprecation) ***REMOVED***
  var env = typeof process !== 'undefined' && process.env || ***REMOVED******REMOVED***;

  if (deprecation) ***REMOVED***
    if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== 'undefined') return !YAML_SILENCE_DEPRECATION_WARNINGS;
    return !env.YAML_SILENCE_DEPRECATION_WARNINGS;
***REMOVED***

  if (typeof YAML_SILENCE_WARNINGS !== 'undefined') return !YAML_SILENCE_WARNINGS;
  return !env.YAML_SILENCE_WARNINGS;
***REMOVED***

function warn(warning, type) ***REMOVED***
  if (shouldWarn(false)) ***REMOVED***
    var emit = typeof process !== 'undefined' && process.emitWarning; // This will throw in Jest if `warning` is an Error instance due to
    // https://github.com/facebook/jest/issues/2549

    if (emit) emit(warning, type);else ***REMOVED***
      // eslint-disable-next-line no-console
      console.warn(type ? "".concat(type, ": ").concat(warning) : warning);
***REMOVED***
***REMOVED***
***REMOVED***
function warnFileDeprecation(filename) ***REMOVED***
  if (shouldWarn(true)) ***REMOVED***
    var path = filename.replace(/.*yaml[/\\]/i, '').replace(/\.js$/, '').replace(/\\/g, '/');
    warn("The endpoint 'yaml/".concat(path, "' will be removed in a future release."), 'DeprecationWarning');
***REMOVED***
***REMOVED***
var warned = ***REMOVED******REMOVED***;
function warnOptionDeprecation(name, alternative) ***REMOVED***
  if (!warned[name] && shouldWarn(true)) ***REMOVED***
    warned[name] = true;
    var msg = "The option '".concat(name, "' will be removed in a future release");
    msg += alternative ? ", use '".concat(alternative, "' instead.") : '.';
    warn(msg, 'DeprecationWarning');
***REMOVED***
***REMOVED***

export ***REMOVED*** warnOptionDeprecation as a, binary as b, warnFileDeprecation as c, floatTime as f, intTime as i, omap as o, pairs as p, set as s, timestamp as t, warn as w ***REMOVED***;
