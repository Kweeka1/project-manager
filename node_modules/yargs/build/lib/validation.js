import ***REMOVED*** argsert ***REMOVED*** from './argsert.js';
import ***REMOVED*** assertNotStrictEqual, ***REMOVED*** from './typings/common-types.js';
import ***REMOVED*** levenshtein as distance ***REMOVED*** from './utils/levenshtein.js';
import ***REMOVED*** objFilter ***REMOVED*** from './utils/obj-filter.js';
const specialKeys = ['$0', '--', '_'];
export function validation(yargs, usage, shim) ***REMOVED***
    const __ = shim.y18n.__;
    const __n = shim.y18n.__n;
    const self = ***REMOVED******REMOVED***;
    self.nonOptionCount = function nonOptionCount(argv) ***REMOVED***
        const demandedCommands = yargs.getDemandedCommands();
        const positionalCount = argv._.length + (argv['--'] ? argv['--'].length : 0);
        const _s = positionalCount - yargs.getInternalMethods().getContext().commands.length;
        if (demandedCommands._ &&
            (_s < demandedCommands._.min || _s > demandedCommands._.max)) ***REMOVED***
            if (_s < demandedCommands._.min) ***REMOVED***
                if (demandedCommands._.minMsg !== undefined) ***REMOVED***
                    usage.fail(demandedCommands._.minMsg
                        ? demandedCommands._.minMsg
                            .replace(/\$0/g, _s.toString())
                            .replace(/\$1/, demandedCommands._.min.toString())
                        : null);
            ***REMOVED***
                else ***REMOVED***
                    usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s.toString(), demandedCommands._.min.toString()));
            ***REMOVED***
        ***REMOVED***
            else if (_s > demandedCommands._.max) ***REMOVED***
                if (demandedCommands._.maxMsg !== undefined) ***REMOVED***
                    usage.fail(demandedCommands._.maxMsg
                        ? demandedCommands._.maxMsg
                            .replace(/\$0/g, _s.toString())
                            .replace(/\$1/, demandedCommands._.max.toString())
                        : null);
            ***REMOVED***
                else ***REMOVED***
                    usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s.toString(), demandedCommands._.max.toString()));
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
***REMOVED***;
    self.positionalCount = function positionalCount(required, observed) ***REMOVED***
        if (observed < required) ***REMOVED***
            usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed + '', required + ''));
    ***REMOVED***
***REMOVED***;
    self.requiredArguments = function requiredArguments(argv, demandedOptions) ***REMOVED***
        let missing = null;
        for (const key of Object.keys(demandedOptions)) ***REMOVED***
            if (!Object.prototype.hasOwnProperty.call(argv, key) ||
                typeof argv[key] === 'undefined') ***REMOVED***
                missing = missing || ***REMOVED******REMOVED***;
                missing[key] = demandedOptions[key];
        ***REMOVED***
    ***REMOVED***
        if (missing) ***REMOVED***
            const customMsgs = [];
            for (const key of Object.keys(missing)) ***REMOVED***
                const msg = missing[key];
                if (msg && customMsgs.indexOf(msg) < 0) ***REMOVED***
                    customMsgs.push(msg);
            ***REMOVED***
        ***REMOVED***
            const customMsg = customMsgs.length ? `\n$***REMOVED***customMsgs.join('\n')***REMOVED***` : '';
            usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));
    ***REMOVED***
***REMOVED***;
    self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand, checkPositionals = true) ***REMOVED***
        var _a;
        const commandKeys = yargs
            .getInternalMethods()
            .getCommandInstance()
            .getCommands();
        const unknown = [];
        const currentContext = yargs.getInternalMethods().getContext();
        Object.keys(argv).forEach(key => ***REMOVED***
            if (!specialKeys.includes(key) &&
                !Object.prototype.hasOwnProperty.call(positionalMap, key) &&
                !Object.prototype.hasOwnProperty.call(yargs.getInternalMethods().getParseContext(), key) &&
                !self.isValidAndSomeAliasIsNotNew(key, aliases)) ***REMOVED***
                unknown.push(key);
        ***REMOVED***
    ***REMOVED***);
        if (checkPositionals &&
            (currentContext.commands.length > 0 ||
                commandKeys.length > 0 ||
                isDefaultCommand)) ***REMOVED***
            argv._.slice(currentContext.commands.length).forEach(key => ***REMOVED***
                if (!commandKeys.includes('' + key)) ***REMOVED***
                    unknown.push('' + key);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***
        if (checkPositionals) ***REMOVED***
            const demandedCommands = yargs.getDemandedCommands();
            const maxNonOptDemanded = ((_a = demandedCommands._) === null || _a === void 0 ? void 0 : _a.max) || 0;
            const expected = currentContext.commands.length + maxNonOptDemanded;
            if (expected < argv._.length) ***REMOVED***
                argv._.slice(expected).forEach(key => ***REMOVED***
                    key = String(key);
                    if (!currentContext.commands.includes(key) &&
                        !unknown.includes(key)) ***REMOVED***
                        unknown.push(key);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***
    ***REMOVED***
        if (unknown.length) ***REMOVED***
            usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.map(s => (s.trim() ? s : `"$***REMOVED***s***REMOVED***"`)).join(', ')));
    ***REMOVED***
***REMOVED***;
    self.unknownCommands = function unknownCommands(argv) ***REMOVED***
        const commandKeys = yargs
            .getInternalMethods()
            .getCommandInstance()
            .getCommands();
        const unknown = [];
        const currentContext = yargs.getInternalMethods().getContext();
        if (currentContext.commands.length > 0 || commandKeys.length > 0) ***REMOVED***
            argv._.slice(currentContext.commands.length).forEach(key => ***REMOVED***
                if (!commandKeys.includes('' + key)) ***REMOVED***
                    unknown.push('' + key);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***
        if (unknown.length > 0) ***REMOVED***
            usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));
            return true;
    ***REMOVED***
        else ***REMOVED***
            return false;
    ***REMOVED***
***REMOVED***;
    self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) ***REMOVED***
        if (!Object.prototype.hasOwnProperty.call(aliases, key)) ***REMOVED***
            return false;
    ***REMOVED***
        const newAliases = yargs.parsed.newAliases;
        return [key, ...aliases[key]].some(a => !Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]);
***REMOVED***;
    self.limitedChoices = function limitedChoices(argv) ***REMOVED***
        const options = yargs.getOptions();
        const invalid = ***REMOVED******REMOVED***;
        if (!Object.keys(options.choices).length)
            return;
        Object.keys(argv).forEach(key => ***REMOVED***
            if (specialKeys.indexOf(key) === -1 &&
                Object.prototype.hasOwnProperty.call(options.choices, key)) ***REMOVED***
                [].concat(argv[key]).forEach(value => ***REMOVED***
                    if (options.choices[key].indexOf(value) === -1 &&
                        value !== undefined) ***REMOVED***
                        invalid[key] = (invalid[key] || []).concat(value);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***
    ***REMOVED***);
        const invalidKeys = Object.keys(invalid);
        if (!invalidKeys.length)
            return;
        let msg = __('Invalid values:');
        invalidKeys.forEach(key => ***REMOVED***
            msg += `\n  $***REMOVED***__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))***REMOVED***`;
    ***REMOVED***);
        usage.fail(msg);
***REMOVED***;
    let implied = ***REMOVED******REMOVED***;
    self.implies = function implies(key, value) ***REMOVED***
        argsert('<string|object> [array|number|string]', [key, value], arguments.length);
        if (typeof key === 'object') ***REMOVED***
            Object.keys(key).forEach(k => ***REMOVED***
                self.implies(k, key[k]);
        ***REMOVED***);
    ***REMOVED***
        else ***REMOVED***
            yargs.global(key);
            if (!implied[key]) ***REMOVED***
                implied[key] = [];
        ***REMOVED***
            if (Array.isArray(value)) ***REMOVED***
                value.forEach(i => self.implies(key, i));
        ***REMOVED***
            else ***REMOVED***
                assertNotStrictEqual(value, undefined, shim);
                implied[key].push(value);
        ***REMOVED***
    ***REMOVED***
***REMOVED***;
    self.getImplied = function getImplied() ***REMOVED***
        return implied;
***REMOVED***;
    function keyExists(argv, val) ***REMOVED***
        const num = Number(val);
        val = isNaN(num) ? val : num;
        if (typeof val === 'number') ***REMOVED***
            val = argv._.length >= val;
    ***REMOVED***
        else if (val.match(/^--no-.+/)) ***REMOVED***
            val = val.match(/^--no-(.+)/)[1];
            val = !Object.prototype.hasOwnProperty.call(argv, val);
    ***REMOVED***
        else ***REMOVED***
            val = Object.prototype.hasOwnProperty.call(argv, val);
    ***REMOVED***
        return val;
***REMOVED***
    self.implications = function implications(argv) ***REMOVED***
        const implyFail = [];
        Object.keys(implied).forEach(key => ***REMOVED***
            const origKey = key;
            (implied[key] || []).forEach(value => ***REMOVED***
                let key = origKey;
                const origValue = value;
                key = keyExists(argv, key);
                value = keyExists(argv, value);
                if (key && !value) ***REMOVED***
                    implyFail.push(` $***REMOVED***origKey***REMOVED*** -> $***REMOVED***origValue***REMOVED***`);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***);
        if (implyFail.length) ***REMOVED***
            let msg = `$***REMOVED***__('Implications failed:')***REMOVED***\n`;
            implyFail.forEach(value => ***REMOVED***
                msg += value;
        ***REMOVED***);
            usage.fail(msg);
    ***REMOVED***
***REMOVED***;
    let conflicting = ***REMOVED******REMOVED***;
    self.conflicts = function conflicts(key, value) ***REMOVED***
        argsert('<string|object> [array|string]', [key, value], arguments.length);
        if (typeof key === 'object') ***REMOVED***
            Object.keys(key).forEach(k => ***REMOVED***
                self.conflicts(k, key[k]);
        ***REMOVED***);
    ***REMOVED***
        else ***REMOVED***
            yargs.global(key);
            if (!conflicting[key]) ***REMOVED***
                conflicting[key] = [];
        ***REMOVED***
            if (Array.isArray(value)) ***REMOVED***
                value.forEach(i => self.conflicts(key, i));
        ***REMOVED***
            else ***REMOVED***
                conflicting[key].push(value);
        ***REMOVED***
    ***REMOVED***
***REMOVED***;
    self.getConflicting = () => conflicting;
    self.conflicting = function conflictingFn(argv) ***REMOVED***
        Object.keys(argv).forEach(key => ***REMOVED***
            if (conflicting[key]) ***REMOVED***
                conflicting[key].forEach(value => ***REMOVED***
                    if (value && argv[key] !== undefined && argv[value] !== undefined) ***REMOVED***
                        usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***
    ***REMOVED***);
        if (yargs.getInternalMethods().getParserConfiguration()['strip-dashed']) ***REMOVED***
            Object.keys(conflicting).forEach(key => ***REMOVED***
                conflicting[key].forEach(value => ***REMOVED***
                    if (value &&
                        argv[shim.Parser.camelCase(key)] !== undefined &&
                        argv[shim.Parser.camelCase(value)] !== undefined) ***REMOVED***
                        usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***
***REMOVED***;
    self.recommendCommands = function recommendCommands(cmd, potentialCommands) ***REMOVED***
        const threshold = 3;
        potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);
        let recommended = null;
        let bestDistance = Infinity;
        for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) ***REMOVED***
            const d = distance(cmd, candidate);
            if (d <= threshold && d < bestDistance) ***REMOVED***
                bestDistance = d;
                recommended = candidate;
        ***REMOVED***
    ***REMOVED***
        if (recommended)
            usage.fail(__('Did you mean %s?', recommended));
***REMOVED***;
    self.reset = function reset(localLookup) ***REMOVED***
        implied = objFilter(implied, k => !localLookup[k]);
        conflicting = objFilter(conflicting, k => !localLookup[k]);
        return self;
***REMOVED***;
    const frozens = [];
    self.freeze = function freeze() ***REMOVED***
        frozens.push(***REMOVED***
            implied,
            conflicting,
    ***REMOVED***);
***REMOVED***;
    self.unfreeze = function unfreeze() ***REMOVED***
        const frozen = frozens.pop();
        assertNotStrictEqual(frozen, undefined, shim);
        (***REMOVED*** implied, conflicting ***REMOVED*** = frozen);
***REMOVED***;
    return self;
***REMOVED***
