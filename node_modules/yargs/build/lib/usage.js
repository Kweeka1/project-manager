import ***REMOVED*** objFilter ***REMOVED*** from './utils/obj-filter.js';
import ***REMOVED*** YError ***REMOVED*** from './yerror.js';
import setBlocking from './utils/set-blocking.js';
function isBoolean(fail) ***REMOVED***
    return typeof fail === 'boolean';
***REMOVED***
export function usage(yargs, shim) ***REMOVED***
    const __ = shim.y18n.__;
    const self = ***REMOVED******REMOVED***;
    const fails = [];
    self.failFn = function failFn(f) ***REMOVED***
        fails.push(f);
***REMOVED***;
    let failMessage = null;
    let globalFailMessage = null;
    let showHelpOnFail = true;
    self.showHelpOnFail = function showHelpOnFailFn(arg1 = true, arg2) ***REMOVED***
        const [enabled, message] = typeof arg1 === 'string' ? [true, arg1] : [arg1, arg2];
        if (yargs.getInternalMethods().isGlobalContext()) ***REMOVED***
            globalFailMessage = message;
    ***REMOVED***
        failMessage = message;
        showHelpOnFail = enabled;
        return self;
***REMOVED***;
    let failureOutput = false;
    self.fail = function fail(msg, err) ***REMOVED***
        const logger = yargs.getInternalMethods().getLoggerInstance();
        if (fails.length) ***REMOVED***
            for (let i = fails.length - 1; i >= 0; --i) ***REMOVED***
                const fail = fails[i];
                if (isBoolean(fail)) ***REMOVED***
                    if (err)
                        throw err;
                    else if (msg)
                        throw Error(msg);
            ***REMOVED***
                else ***REMOVED***
                    fail(msg, err, self);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
        else ***REMOVED***
            if (yargs.getExitProcess())
                setBlocking(true);
            if (!failureOutput) ***REMOVED***
                failureOutput = true;
                if (showHelpOnFail) ***REMOVED***
                    yargs.showHelp('error');
                    logger.error();
            ***REMOVED***
                if (msg || err)
                    logger.error(msg || err);
                const globalOrCommandFailMessage = failMessage || globalFailMessage;
                if (globalOrCommandFailMessage) ***REMOVED***
                    if (msg || err)
                        logger.error('');
                    logger.error(globalOrCommandFailMessage);
            ***REMOVED***
        ***REMOVED***
            err = err || new YError(msg);
            if (yargs.getExitProcess()) ***REMOVED***
                return yargs.exit(1);
        ***REMOVED***
            else if (yargs.getInternalMethods().hasParseCallback()) ***REMOVED***
                return yargs.exit(1, err);
        ***REMOVED***
            else ***REMOVED***
                throw err;
        ***REMOVED***
    ***REMOVED***
***REMOVED***;
    let usages = [];
    let usageDisabled = false;
    self.usage = (msg, description) => ***REMOVED***
        if (msg === null) ***REMOVED***
            usageDisabled = true;
            usages = [];
            return self;
    ***REMOVED***
        usageDisabled = false;
        usages.push([msg, description || '']);
        return self;
***REMOVED***;
    self.getUsage = () => ***REMOVED***
        return usages;
***REMOVED***;
    self.getUsageDisabled = () => ***REMOVED***
        return usageDisabled;
***REMOVED***;
    self.getPositionalGroupName = () => ***REMOVED***
        return __('Positionals:');
***REMOVED***;
    let examples = [];
    self.example = (cmd, description) => ***REMOVED***
        examples.push([cmd, description || '']);
***REMOVED***;
    let commands = [];
    self.command = function command(cmd, description, isDefault, aliases, deprecated = false) ***REMOVED***
        if (isDefault) ***REMOVED***
            commands = commands.map(cmdArray => ***REMOVED***
                cmdArray[2] = false;
                return cmdArray;
        ***REMOVED***);
    ***REMOVED***
        commands.push([cmd, description || '', isDefault, aliases, deprecated]);
***REMOVED***;
    self.getCommands = () => commands;
    let descriptions = ***REMOVED******REMOVED***;
    self.describe = function describe(keyOrKeys, desc) ***REMOVED***
        if (Array.isArray(keyOrKeys)) ***REMOVED***
            keyOrKeys.forEach(k => ***REMOVED***
                self.describe(k, desc);
        ***REMOVED***);
    ***REMOVED***
        else if (typeof keyOrKeys === 'object') ***REMOVED***
            Object.keys(keyOrKeys).forEach(k => ***REMOVED***
                self.describe(k, keyOrKeys[k]);
        ***REMOVED***);
    ***REMOVED***
        else ***REMOVED***
            descriptions[keyOrKeys] = desc;
    ***REMOVED***
***REMOVED***;
    self.getDescriptions = () => descriptions;
    let epilogs = [];
    self.epilog = msg => ***REMOVED***
        epilogs.push(msg);
***REMOVED***;
    let wrapSet = false;
    let wrap;
    self.wrap = cols => ***REMOVED***
        wrapSet = true;
        wrap = cols;
***REMOVED***;
    function getWrap() ***REMOVED***
        if (!wrapSet) ***REMOVED***
            wrap = windowWidth();
            wrapSet = true;
    ***REMOVED***
        return wrap;
***REMOVED***
    const deferY18nLookupPrefix = '__yargsString__:';
    self.deferY18nLookup = str => deferY18nLookupPrefix + str;
    self.help = function help() ***REMOVED***
        if (cachedHelpMessage)
            return cachedHelpMessage;
        normalizeAliases();
        const base$0 = yargs.customScriptName
            ? yargs.$0
            : shim.path.basename(yargs.$0);
        const demandedOptions = yargs.getDemandedOptions();
        const demandedCommands = yargs.getDemandedCommands();
        const deprecatedOptions = yargs.getDeprecatedOptions();
        const groups = yargs.getGroups();
        const options = yargs.getOptions();
        let keys = [];
        keys = keys.concat(Object.keys(descriptions));
        keys = keys.concat(Object.keys(demandedOptions));
        keys = keys.concat(Object.keys(demandedCommands));
        keys = keys.concat(Object.keys(options.default));
        keys = keys.filter(filterHiddenOptions);
        keys = Object.keys(keys.reduce((acc, key) => ***REMOVED***
            if (key !== '_')
                acc[key] = true;
            return acc;
    ***REMOVED***, ***REMOVED******REMOVED***));
        const theWrap = getWrap();
        const ui = shim.cliui(***REMOVED***
            width: theWrap,
            wrap: !!theWrap,
    ***REMOVED***);
        if (!usageDisabled) ***REMOVED***
            if (usages.length) ***REMOVED***
                usages.forEach(usage => ***REMOVED***
                    ui.div(***REMOVED*** text: `$***REMOVED***usage[0].replace(/\$0/g, base$0)***REMOVED***` ***REMOVED***);
                    if (usage[1]) ***REMOVED***
                        ui.div(***REMOVED*** text: `$***REMOVED***usage[1]***REMOVED***`, padding: [1, 0, 0, 0] ***REMOVED***);
                ***REMOVED***
            ***REMOVED***);
                ui.div();
        ***REMOVED***
            else if (commands.length) ***REMOVED***
                let u = null;
                if (demandedCommands._) ***REMOVED***
                    u = `$***REMOVED***base$0***REMOVED*** <$***REMOVED***__('command')***REMOVED***>\n`;
            ***REMOVED***
                else ***REMOVED***
                    u = `$***REMOVED***base$0***REMOVED*** [$***REMOVED***__('command')***REMOVED***]\n`;
            ***REMOVED***
                ui.div(`$***REMOVED***u***REMOVED***`);
        ***REMOVED***
    ***REMOVED***
        if (commands.length > 1 || (commands.length === 1 && !commands[0][2])) ***REMOVED***
            ui.div(__('Commands:'));
            const context = yargs.getInternalMethods().getContext();
            const parentCommands = context.commands.length
                ? `$***REMOVED***context.commands.join(' ')***REMOVED*** `
                : '';
            if (yargs.getInternalMethods().getParserConfiguration()['sort-commands'] ===
                true) ***REMOVED***
                commands = commands.sort((a, b) => a[0].localeCompare(b[0]));
        ***REMOVED***
            const prefix = base$0 ? `$***REMOVED***base$0***REMOVED*** ` : '';
            commands.forEach(command => ***REMOVED***
                const commandString = `$***REMOVED***prefix***REMOVED***$***REMOVED***parentCommands***REMOVED***$***REMOVED***command[0].replace(/^\$0 ?/, '')***REMOVED***`;
                ui.span(***REMOVED***
                    text: commandString,
                    padding: [0, 2, 0, 2],
                    width: maxWidth(commands, theWrap, `$***REMOVED***base$0***REMOVED***$***REMOVED***parentCommands***REMOVED***`) + 4,
            ***REMOVED***, ***REMOVED*** text: command[1] ***REMOVED***);
                const hints = [];
                if (command[2])
                    hints.push(`[$***REMOVED***__('default')***REMOVED***]`);
                if (command[3] && command[3].length) ***REMOVED***
                    hints.push(`[$***REMOVED***__('aliases:')***REMOVED*** $***REMOVED***command[3].join(', ')***REMOVED***]`);
            ***REMOVED***
                if (command[4]) ***REMOVED***
                    if (typeof command[4] === 'string') ***REMOVED***
                        hints.push(`[$***REMOVED***__('deprecated: %s', command[4])***REMOVED***]`);
                ***REMOVED***
                    else ***REMOVED***
                        hints.push(`[$***REMOVED***__('deprecated')***REMOVED***]`);
                ***REMOVED***
            ***REMOVED***
                if (hints.length) ***REMOVED***
                    ui.div(***REMOVED***
                        text: hints.join(' '),
                        padding: [0, 0, 0, 2],
                        align: 'right',
                ***REMOVED***);
            ***REMOVED***
                else ***REMOVED***
                    ui.div();
            ***REMOVED***
        ***REMOVED***);
            ui.div();
    ***REMOVED***
        const aliasKeys = (Object.keys(options.alias) || []).concat(Object.keys(yargs.parsed.newAliases) || []);
        keys = keys.filter(key => !yargs.parsed.newAliases[key] &&
            aliasKeys.every(alias => (options.alias[alias] || []).indexOf(key) === -1));
        const defaultGroup = __('Options:');
        if (!groups[defaultGroup])
            groups[defaultGroup] = [];
        addUngroupedKeys(keys, options.alias, groups, defaultGroup);
        const isLongSwitch = (sw) => /^--/.test(getText(sw));
        const displayedGroups = Object.keys(groups)
            .filter(groupName => groups[groupName].length > 0)
            .map(groupName => ***REMOVED***
            const normalizedKeys = groups[groupName]
                .filter(filterHiddenOptions)
                .map(key => ***REMOVED***
                if (aliasKeys.includes(key))
                    return key;
                for (let i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++) ***REMOVED***
                    if ((options.alias[aliasKey] || []).includes(key))
                        return aliasKey;
            ***REMOVED***
                return key;
        ***REMOVED***);
            return ***REMOVED*** groupName, normalizedKeys ***REMOVED***;
    ***REMOVED***)
            .filter((***REMOVED*** normalizedKeys ***REMOVED***) => normalizedKeys.length > 0)
            .map((***REMOVED*** groupName, normalizedKeys ***REMOVED***) => ***REMOVED***
            const switches = normalizedKeys.reduce((acc, key) => ***REMOVED***
                acc[key] = [key]
                    .concat(options.alias[key] || [])
                    .map(sw => ***REMOVED***
                    if (groupName === self.getPositionalGroupName())
                        return sw;
                    else ***REMOVED***
                        return ((/^[0-9]$/.test(sw)
                            ? options.boolean.includes(key)
                                ? '-'
                                : '--'
                            : sw.length > 1
                                ? '--'
                                : '-') + sw);
                ***REMOVED***
            ***REMOVED***)
                    .sort((sw1, sw2) => isLongSwitch(sw1) === isLongSwitch(sw2)
                    ? 0
                    : isLongSwitch(sw1)
                        ? 1
                        : -1)
                    .join(', ');
                return acc;
        ***REMOVED***, ***REMOVED******REMOVED***);
            return ***REMOVED*** groupName, normalizedKeys, switches ***REMOVED***;
    ***REMOVED***);
        const shortSwitchesUsed = displayedGroups
            .filter((***REMOVED*** groupName ***REMOVED***) => groupName !== self.getPositionalGroupName())
            .some((***REMOVED*** normalizedKeys, switches ***REMOVED***) => !normalizedKeys.every(key => isLongSwitch(switches[key])));
        if (shortSwitchesUsed) ***REMOVED***
            displayedGroups
                .filter((***REMOVED*** groupName ***REMOVED***) => groupName !== self.getPositionalGroupName())
                .forEach((***REMOVED*** normalizedKeys, switches ***REMOVED***) => ***REMOVED***
                normalizedKeys.forEach(key => ***REMOVED***
                    if (isLongSwitch(switches[key])) ***REMOVED***
                        switches[key] = addIndentation(switches[key], '-x, '.length);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***
        displayedGroups.forEach((***REMOVED*** groupName, normalizedKeys, switches ***REMOVED***) => ***REMOVED***
            ui.div(groupName);
            normalizedKeys.forEach(key => ***REMOVED***
                const kswitch = switches[key];
                let desc = descriptions[key] || '';
                let type = null;
                if (desc.includes(deferY18nLookupPrefix))
                    desc = __(desc.substring(deferY18nLookupPrefix.length));
                if (options.boolean.includes(key))
                    type = `[$***REMOVED***__('boolean')***REMOVED***]`;
                if (options.count.includes(key))
                    type = `[$***REMOVED***__('count')***REMOVED***]`;
                if (options.string.includes(key))
                    type = `[$***REMOVED***__('string')***REMOVED***]`;
                if (options.normalize.includes(key))
                    type = `[$***REMOVED***__('string')***REMOVED***]`;
                if (options.array.includes(key))
                    type = `[$***REMOVED***__('array')***REMOVED***]`;
                if (options.number.includes(key))
                    type = `[$***REMOVED***__('number')***REMOVED***]`;
                const deprecatedExtra = (deprecated) => typeof deprecated === 'string'
                    ? `[$***REMOVED***__('deprecated: %s', deprecated)***REMOVED***]`
                    : `[$***REMOVED***__('deprecated')***REMOVED***]`;
                const extra = [
                    key in deprecatedOptions
                        ? deprecatedExtra(deprecatedOptions[key])
                        : null,
                    type,
                    key in demandedOptions ? `[$***REMOVED***__('required')***REMOVED***]` : null,
                    options.choices && options.choices[key]
                        ? `[$***REMOVED***__('choices:')***REMOVED*** $***REMOVED***self.stringifiedValues(options.choices[key])***REMOVED***]`
                        : null,
                    defaultString(options.default[key], options.defaultDescription[key]),
                ]
                    .filter(Boolean)
                    .join(' ');
                ui.span(***REMOVED***
                    text: getText(kswitch),
                    padding: [0, 2, 0, 2 + getIndentation(kswitch)],
                    width: maxWidth(switches, theWrap) + 4,
            ***REMOVED***, desc);
                if (extra)
                    ui.div(***REMOVED*** text: extra, padding: [0, 0, 0, 2], align: 'right' ***REMOVED***);
                else
                    ui.div();
        ***REMOVED***);
            ui.div();
    ***REMOVED***);
        if (examples.length) ***REMOVED***
            ui.div(__('Examples:'));
            examples.forEach(example => ***REMOVED***
                example[0] = example[0].replace(/\$0/g, base$0);
        ***REMOVED***);
            examples.forEach(example => ***REMOVED***
                if (example[1] === '') ***REMOVED***
                    ui.div(***REMOVED***
                        text: example[0],
                        padding: [0, 2, 0, 2],
                ***REMOVED***);
            ***REMOVED***
                else ***REMOVED***
                    ui.div(***REMOVED***
                        text: example[0],
                        padding: [0, 2, 0, 2],
                        width: maxWidth(examples, theWrap) + 4,
                ***REMOVED***, ***REMOVED***
                        text: example[1],
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***);
            ui.div();
    ***REMOVED***
        if (epilogs.length > 0) ***REMOVED***
            const e = epilogs
                .map(epilog => epilog.replace(/\$0/g, base$0))
                .join('\n');
            ui.div(`$***REMOVED***e***REMOVED***\n`);
    ***REMOVED***
        return ui.toString().replace(/\s*$/, '');
***REMOVED***;
    function maxWidth(table, theWrap, modifier) ***REMOVED***
        let width = 0;
        if (!Array.isArray(table)) ***REMOVED***
            table = Object.values(table).map(v => [v]);
    ***REMOVED***
        table.forEach(v => ***REMOVED***
            width = Math.max(shim.stringWidth(modifier ? `$***REMOVED***modifier***REMOVED*** $***REMOVED***getText(v[0])***REMOVED***` : getText(v[0])) + getIndentation(v[0]), width);
    ***REMOVED***);
        if (theWrap)
            width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));
        return width;
***REMOVED***
    function normalizeAliases() ***REMOVED***
        const demandedOptions = yargs.getDemandedOptions();
        const options = yargs.getOptions();
        (Object.keys(options.alias) || []).forEach(key => ***REMOVED***
            options.alias[key].forEach(alias => ***REMOVED***
                if (descriptions[alias])
                    self.describe(key, descriptions[alias]);
                if (alias in demandedOptions)
                    yargs.demandOption(key, demandedOptions[alias]);
                if (options.boolean.includes(alias))
                    yargs.boolean(key);
                if (options.count.includes(alias))
                    yargs.count(key);
                if (options.string.includes(alias))
                    yargs.string(key);
                if (options.normalize.includes(alias))
                    yargs.normalize(key);
                if (options.array.includes(alias))
                    yargs.array(key);
                if (options.number.includes(alias))
                    yargs.number(key);
        ***REMOVED***);
    ***REMOVED***);
***REMOVED***
    let cachedHelpMessage;
    self.cacheHelpMessage = function () ***REMOVED***
        cachedHelpMessage = this.help();
***REMOVED***;
    self.clearCachedHelpMessage = function () ***REMOVED***
        cachedHelpMessage = undefined;
***REMOVED***;
    self.hasCachedHelpMessage = function () ***REMOVED***
        return !!cachedHelpMessage;
***REMOVED***;
    function addUngroupedKeys(keys, aliases, groups, defaultGroup) ***REMOVED***
        let groupedKeys = [];
        let toCheck = null;
        Object.keys(groups).forEach(group => ***REMOVED***
            groupedKeys = groupedKeys.concat(groups[group]);
    ***REMOVED***);
        keys.forEach(key => ***REMOVED***
            toCheck = [key].concat(aliases[key]);
            if (!toCheck.some(k => groupedKeys.indexOf(k) !== -1)) ***REMOVED***
                groups[defaultGroup].push(key);
        ***REMOVED***
    ***REMOVED***);
        return groupedKeys;
***REMOVED***
    function filterHiddenOptions(key) ***REMOVED***
        return (yargs.getOptions().hiddenOptions.indexOf(key) < 0 ||
            yargs.parsed.argv[yargs.getOptions().showHiddenOpt]);
***REMOVED***
    self.showHelp = (level) => ***REMOVED***
        const logger = yargs.getInternalMethods().getLoggerInstance();
        if (!level)
            level = 'error';
        const emit = typeof level === 'function' ? level : logger[level];
        emit(self.help());
***REMOVED***;
    self.functionDescription = fn => ***REMOVED***
        const description = fn.name
            ? shim.Parser.decamelize(fn.name, '-')
            : __('generated-value');
        return ['(', description, ')'].join('');
***REMOVED***;
    self.stringifiedValues = function stringifiedValues(values, separator) ***REMOVED***
        let string = '';
        const sep = separator || ', ';
        const array = [].concat(values);
        if (!values || !array.length)
            return string;
        array.forEach(value => ***REMOVED***
            if (string.length)
                string += sep;
            string += JSON.stringify(value);
    ***REMOVED***);
        return string;
***REMOVED***;
    function defaultString(value, defaultDescription) ***REMOVED***
        let string = `[$***REMOVED***__('default:')***REMOVED*** `;
        if (value === undefined && !defaultDescription)
            return null;
        if (defaultDescription) ***REMOVED***
            string += defaultDescription;
    ***REMOVED***
        else ***REMOVED***
            switch (typeof value) ***REMOVED***
                case 'string':
                    string += `"$***REMOVED***value***REMOVED***"`;
                    break;
                case 'object':
                    string += JSON.stringify(value);
                    break;
                default:
                    string += value;
        ***REMOVED***
    ***REMOVED***
        return `$***REMOVED***string***REMOVED***]`;
***REMOVED***
    function windowWidth() ***REMOVED***
        const maxWidth = 80;
        if (shim.process.stdColumns) ***REMOVED***
            return Math.min(maxWidth, shim.process.stdColumns);
    ***REMOVED***
        else ***REMOVED***
            return maxWidth;
    ***REMOVED***
***REMOVED***
    let version = null;
    self.version = ver => ***REMOVED***
        version = ver;
***REMOVED***;
    self.showVersion = level => ***REMOVED***
        const logger = yargs.getInternalMethods().getLoggerInstance();
        if (!level)
            level = 'error';
        const emit = typeof level === 'function' ? level : logger[level];
        emit(version);
***REMOVED***;
    self.reset = function reset(localLookup) ***REMOVED***
        failMessage = null;
        failureOutput = false;
        usages = [];
        usageDisabled = false;
        epilogs = [];
        examples = [];
        commands = [];
        descriptions = objFilter(descriptions, k => !localLookup[k]);
        return self;
***REMOVED***;
    const frozens = [];
    self.freeze = function freeze() ***REMOVED***
        frozens.push(***REMOVED***
            failMessage,
            failureOutput,
            usages,
            usageDisabled,
            epilogs,
            examples,
            commands,
            descriptions,
    ***REMOVED***);
***REMOVED***;
    self.unfreeze = function unfreeze(defaultCommand = false) ***REMOVED***
        const frozen = frozens.pop();
        if (!frozen)
            return;
        if (defaultCommand) ***REMOVED***
            descriptions = ***REMOVED*** ...frozen.descriptions, ...descriptions ***REMOVED***;
            commands = [...frozen.commands, ...commands];
            usages = [...frozen.usages, ...usages];
            examples = [...frozen.examples, ...examples];
            epilogs = [...frozen.epilogs, ...epilogs];
    ***REMOVED***
        else ***REMOVED***
            (***REMOVED***
                failMessage,
                failureOutput,
                usages,
                usageDisabled,
                epilogs,
                examples,
                commands,
                descriptions,
        ***REMOVED*** = frozen);
    ***REMOVED***
***REMOVED***;
    return self;
***REMOVED***
function isIndentedText(text) ***REMOVED***
    return typeof text === 'object';
***REMOVED***
function addIndentation(text, indent) ***REMOVED***
    return isIndentedText(text)
        ? ***REMOVED*** text: text.text, indentation: text.indentation + indent ***REMOVED***
        : ***REMOVED*** text, indentation: indent ***REMOVED***;
***REMOVED***
function getIndentation(text) ***REMOVED***
    return isIndentedText(text) ? text.indentation : 0;
***REMOVED***
function getText(text) ***REMOVED***
    return isIndentedText(text) ? text.text : text;
***REMOVED***
