import ***REMOVED*** assertNotStrictEqual, ***REMOVED*** from './typings/common-types.js';
import ***REMOVED*** isPromise ***REMOVED*** from './utils/is-promise.js';
import ***REMOVED*** applyMiddleware, commandMiddlewareFactory, ***REMOVED*** from './middleware.js';
import ***REMOVED*** parseCommand ***REMOVED*** from './parse-command.js';
import ***REMOVED*** isYargsInstance, ***REMOVED*** from './yargs-factory.js';
import ***REMOVED*** maybeAsyncResult ***REMOVED*** from './utils/maybe-async-result.js';
import whichModule from './utils/which-module.js';
const DEFAULT_MARKER = /(^\*)|(^\$0)/;
export class CommandInstance ***REMOVED***
    constructor(usage, validation, globalMiddleware, shim) ***REMOVED***
        this.requireCache = new Set();
        this.handlers = ***REMOVED******REMOVED***;
        this.aliasMap = ***REMOVED******REMOVED***;
        this.frozens = [];
        this.shim = shim;
        this.usage = usage;
        this.globalMiddleware = globalMiddleware;
        this.validation = validation;
***REMOVED***
    addDirectory(dir, req, callerFile, opts) ***REMOVED***
        opts = opts || ***REMOVED******REMOVED***;
        if (typeof opts.recurse !== 'boolean')
            opts.recurse = false;
        if (!Array.isArray(opts.extensions))
            opts.extensions = ['js'];
        const parentVisit = typeof opts.visit === 'function' ? opts.visit : (o) => o;
        opts.visit = (obj, joined, filename) => ***REMOVED***
            const visited = parentVisit(obj, joined, filename);
            if (visited) ***REMOVED***
                if (this.requireCache.has(joined))
                    return visited;
                else
                    this.requireCache.add(joined);
                this.addHandler(visited);
        ***REMOVED***
            return visited;
    ***REMOVED***;
        this.shim.requireDirectory(***REMOVED*** require: req, filename: callerFile ***REMOVED***, dir, opts);
***REMOVED***
    addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) ***REMOVED***
        let aliases = [];
        const middlewares = commandMiddlewareFactory(commandMiddleware);
        handler = handler || (() => ***REMOVED*** ***REMOVED***);
        if (Array.isArray(cmd)) ***REMOVED***
            if (isCommandAndAliases(cmd)) ***REMOVED***
                [cmd, ...aliases] = cmd;
        ***REMOVED***
            else ***REMOVED***
                for (const command of cmd) ***REMOVED***
                    this.addHandler(command);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
        else if (isCommandHandlerDefinition(cmd)) ***REMOVED***
            let command = Array.isArray(cmd.command) || typeof cmd.command === 'string'
                ? cmd.command
                : this.moduleName(cmd);
            if (cmd.aliases)
                command = [].concat(command).concat(cmd.aliases);
            this.addHandler(command, this.extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);
            return;
    ***REMOVED***
        else if (isCommandBuilderDefinition(builder)) ***REMOVED***
            this.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);
            return;
    ***REMOVED***
        if (typeof cmd === 'string') ***REMOVED***
            const parsedCommand = parseCommand(cmd);
            aliases = aliases.map(alias => parseCommand(alias).cmd);
            let isDefault = false;
            const parsedAliases = [parsedCommand.cmd].concat(aliases).filter(c => ***REMOVED***
                if (DEFAULT_MARKER.test(c)) ***REMOVED***
                    isDefault = true;
                    return false;
            ***REMOVED***
                return true;
        ***REMOVED***);
            if (parsedAliases.length === 0 && isDefault)
                parsedAliases.push('$0');
            if (isDefault) ***REMOVED***
                parsedCommand.cmd = parsedAliases[0];
                aliases = parsedAliases.slice(1);
                cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);
        ***REMOVED***
            aliases.forEach(alias => ***REMOVED***
                this.aliasMap[alias] = parsedCommand.cmd;
        ***REMOVED***);
            if (description !== false) ***REMOVED***
                this.usage.command(cmd, description, isDefault, aliases, deprecated);
        ***REMOVED***
            this.handlers[parsedCommand.cmd] = ***REMOVED***
                original: cmd,
                description,
                handler,
                builder: builder || ***REMOVED******REMOVED***,
                middlewares,
                deprecated,
                demanded: parsedCommand.demanded,
                optional: parsedCommand.optional,
        ***REMOVED***;
            if (isDefault)
                this.defaultCommand = this.handlers[parsedCommand.cmd];
    ***REMOVED***
***REMOVED***
    getCommandHandlers() ***REMOVED***
        return this.handlers;
***REMOVED***
    getCommands() ***REMOVED***
        return Object.keys(this.handlers).concat(Object.keys(this.aliasMap));
***REMOVED***
    hasDefaultCommand() ***REMOVED***
        return !!this.defaultCommand;
***REMOVED***
    runCommand(command, yargs, parsed, commandIndex, helpOnly, helpOrVersionSet) ***REMOVED***
        const commandHandler = this.handlers[command] ||
            this.handlers[this.aliasMap[command]] ||
            this.defaultCommand;
        const currentContext = yargs.getInternalMethods().getContext();
        const parentCommands = currentContext.commands.slice();
        const isDefaultCommand = !command;
        if (command) ***REMOVED***
            currentContext.commands.push(command);
            currentContext.fullCommands.push(commandHandler.original);
    ***REMOVED***
        const builderResult = this.applyBuilderUpdateUsageAndParse(isDefaultCommand, commandHandler, yargs, parsed.aliases, parentCommands, commandIndex, helpOnly, helpOrVersionSet);
        return isPromise(builderResult)
            ? builderResult.then(result => this.applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, result.innerArgv, currentContext, helpOnly, result.aliases, yargs))
            : this.applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, builderResult.innerArgv, currentContext, helpOnly, builderResult.aliases, yargs);
***REMOVED***
    applyBuilderUpdateUsageAndParse(isDefaultCommand, commandHandler, yargs, aliases, parentCommands, commandIndex, helpOnly, helpOrVersionSet) ***REMOVED***
        const builder = commandHandler.builder;
        let innerYargs = yargs;
        if (isCommandBuilderCallback(builder)) ***REMOVED***
            const builderOutput = builder(yargs.getInternalMethods().reset(aliases), helpOrVersionSet);
            if (isPromise(builderOutput)) ***REMOVED***
                return builderOutput.then(output => ***REMOVED***
                    innerYargs = isYargsInstance(output) ? output : yargs;
                    return this.parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly);
            ***REMOVED***);
        ***REMOVED***
    ***REMOVED***
        else if (isCommandBuilderOptionDefinitions(builder)) ***REMOVED***
            innerYargs = yargs.getInternalMethods().reset(aliases);
            Object.keys(commandHandler.builder).forEach(key => ***REMOVED***
                innerYargs.option(key, builder[key]);
        ***REMOVED***);
    ***REMOVED***
        return this.parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly);
***REMOVED***
    parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly) ***REMOVED***
        if (isDefaultCommand)
            innerYargs.getInternalMethods().getUsageInstance().unfreeze(true);
        if (this.shouldUpdateUsage(innerYargs)) ***REMOVED***
            innerYargs
                .getInternalMethods()
                .getUsageInstance()
                .usage(this.usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
    ***REMOVED***
        const innerArgv = innerYargs
            .getInternalMethods()
            .runYargsParserAndExecuteCommands(null, undefined, true, commandIndex, helpOnly);
        return isPromise(innerArgv)
            ? innerArgv.then(argv => (***REMOVED***
                aliases: innerYargs.parsed.aliases,
                innerArgv: argv,
        ***REMOVED***))
            : ***REMOVED***
                aliases: innerYargs.parsed.aliases,
                innerArgv: innerArgv,
        ***REMOVED***;
***REMOVED***
    shouldUpdateUsage(yargs) ***REMOVED***
        return (!yargs.getInternalMethods().getUsageInstance().getUsageDisabled() &&
            yargs.getInternalMethods().getUsageInstance().getUsage().length === 0);
***REMOVED***
    usageFromParentCommandsCommandHandler(parentCommands, commandHandler) ***REMOVED***
        const c = DEFAULT_MARKER.test(commandHandler.original)
            ? commandHandler.original.replace(DEFAULT_MARKER, '').trim()
            : commandHandler.original;
        const pc = parentCommands.filter(c => ***REMOVED***
            return !DEFAULT_MARKER.test(c);
    ***REMOVED***);
        pc.push(c);
        return `$0 $***REMOVED***pc.join(' ')***REMOVED***`;
***REMOVED***
    handleValidationAndGetResult(isDefaultCommand, commandHandler, innerArgv, currentContext, aliases, yargs, middlewares, positionalMap) ***REMOVED***
        if (!yargs.getInternalMethods().getHasOutput()) ***REMOVED***
            const validation = yargs
                .getInternalMethods()
                .runValidation(aliases, positionalMap, yargs.parsed.error, isDefaultCommand);
            innerArgv = maybeAsyncResult(innerArgv, result => ***REMOVED***
                validation(result);
                return result;
        ***REMOVED***);
    ***REMOVED***
        if (commandHandler.handler && !yargs.getInternalMethods().getHasOutput()) ***REMOVED***
            yargs.getInternalMethods().setHasOutput();
            const populateDoubleDash = !!yargs.getOptions().configuration['populate--'];
            yargs
                .getInternalMethods()
                .postProcess(innerArgv, populateDoubleDash, false, false);
            innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false);
            innerArgv = maybeAsyncResult(innerArgv, result => ***REMOVED***
                const handlerResult = commandHandler.handler(result);
                return isPromise(handlerResult)
                    ? handlerResult.then(() => result)
                    : result;
        ***REMOVED***);
            if (!isDefaultCommand) ***REMOVED***
                yargs.getInternalMethods().getUsageInstance().cacheHelpMessage();
        ***REMOVED***
            if (isPromise(innerArgv) &&
                !yargs.getInternalMethods().hasParseCallback()) ***REMOVED***
                innerArgv.catch(error => ***REMOVED***
                    try ***REMOVED***
                        yargs.getInternalMethods().getUsageInstance().fail(null, error);
                ***REMOVED***
                    catch (_err) ***REMOVED***
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***
    ***REMOVED***
        if (!isDefaultCommand) ***REMOVED***
            currentContext.commands.pop();
            currentContext.fullCommands.pop();
    ***REMOVED***
        return innerArgv;
***REMOVED***
    applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, innerArgv, currentContext, helpOnly, aliases, yargs) ***REMOVED***
        let positionalMap = ***REMOVED******REMOVED***;
        if (helpOnly)
            return innerArgv;
        if (!yargs.getInternalMethods().getHasOutput()) ***REMOVED***
            positionalMap = this.populatePositionals(commandHandler, innerArgv, currentContext, yargs);
    ***REMOVED***
        const middlewares = this.globalMiddleware
            .getMiddleware()
            .slice(0)
            .concat(commandHandler.middlewares);
        const maybePromiseArgv = applyMiddleware(innerArgv, yargs, middlewares, true);
        return isPromise(maybePromiseArgv)
            ? maybePromiseArgv.then(resolvedInnerArgv => this.handleValidationAndGetResult(isDefaultCommand, commandHandler, resolvedInnerArgv, currentContext, aliases, yargs, middlewares, positionalMap))
            : this.handleValidationAndGetResult(isDefaultCommand, commandHandler, maybePromiseArgv, currentContext, aliases, yargs, middlewares, positionalMap);
***REMOVED***
    populatePositionals(commandHandler, argv, context, yargs) ***REMOVED***
        argv._ = argv._.slice(context.commands.length);
        const demanded = commandHandler.demanded.slice(0);
        const optional = commandHandler.optional.slice(0);
        const positionalMap = ***REMOVED******REMOVED***;
        this.validation.positionalCount(demanded.length, argv._.length);
        while (demanded.length) ***REMOVED***
            const demand = demanded.shift();
            this.populatePositional(demand, argv, positionalMap);
    ***REMOVED***
        while (optional.length) ***REMOVED***
            const maybe = optional.shift();
            this.populatePositional(maybe, argv, positionalMap);
    ***REMOVED***
        argv._ = context.commands.concat(argv._.map(a => '' + a));
        this.postProcessPositionals(argv, positionalMap, this.cmdToParseOptions(commandHandler.original), yargs);
        return positionalMap;
***REMOVED***
    populatePositional(positional, argv, positionalMap) ***REMOVED***
        const cmd = positional.cmd[0];
        if (positional.variadic) ***REMOVED***
            positionalMap[cmd] = argv._.splice(0).map(String);
    ***REMOVED***
        else ***REMOVED***
            if (argv._.length)
                positionalMap[cmd] = [String(argv._.shift())];
    ***REMOVED***
***REMOVED***
    cmdToParseOptions(cmdString) ***REMOVED***
        const parseOptions = ***REMOVED***
            array: [],
            default: ***REMOVED******REMOVED***,
            alias: ***REMOVED******REMOVED***,
            demand: ***REMOVED******REMOVED***,
    ***REMOVED***;
        const parsed = parseCommand(cmdString);
        parsed.demanded.forEach(d => ***REMOVED***
            const [cmd, ...aliases] = d.cmd;
            if (d.variadic) ***REMOVED***
                parseOptions.array.push(cmd);
                parseOptions.default[cmd] = [];
        ***REMOVED***
            parseOptions.alias[cmd] = aliases;
            parseOptions.demand[cmd] = true;
    ***REMOVED***);
        parsed.optional.forEach(o => ***REMOVED***
            const [cmd, ...aliases] = o.cmd;
            if (o.variadic) ***REMOVED***
                parseOptions.array.push(cmd);
                parseOptions.default[cmd] = [];
        ***REMOVED***
            parseOptions.alias[cmd] = aliases;
    ***REMOVED***);
        return parseOptions;
***REMOVED***
    postProcessPositionals(argv, positionalMap, parseOptions, yargs) ***REMOVED***
        const options = Object.assign(***REMOVED******REMOVED***, yargs.getOptions());
        options.default = Object.assign(parseOptions.default, options.default);
        for (const key of Object.keys(parseOptions.alias)) ***REMOVED***
            options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);
    ***REMOVED***
        options.array = options.array.concat(parseOptions.array);
        options.config = ***REMOVED******REMOVED***;
        const unparsed = [];
        Object.keys(positionalMap).forEach(key => ***REMOVED***
            positionalMap[key].map(value => ***REMOVED***
                if (options.configuration['unknown-options-as-args'])
                    options.key[key] = true;
                unparsed.push(`--$***REMOVED***key***REMOVED***`);
                unparsed.push(value);
        ***REMOVED***);
    ***REMOVED***);
        if (!unparsed.length)
            return;
        const config = Object.assign(***REMOVED******REMOVED***, options.configuration, ***REMOVED***
            'populate--': false,
    ***REMOVED***);
        const parsed = this.shim.Parser.detailed(unparsed, Object.assign(***REMOVED******REMOVED***, options, ***REMOVED***
            configuration: config,
    ***REMOVED***));
        if (parsed.error) ***REMOVED***
            yargs
                .getInternalMethods()
                .getUsageInstance()
                .fail(parsed.error.message, parsed.error);
    ***REMOVED***
        else ***REMOVED***
            const positionalKeys = Object.keys(positionalMap);
            Object.keys(positionalMap).forEach(key => ***REMOVED***
                positionalKeys.push(...parsed.aliases[key]);
        ***REMOVED***);
            Object.keys(parsed.argv).forEach(key => ***REMOVED***
                if (positionalKeys.includes(key)) ***REMOVED***
                    if (!positionalMap[key])
                        positionalMap[key] = parsed.argv[key];
                    if (!this.isInConfigs(yargs, key) &&
                        !this.isDefaulted(yargs, key) &&
                        Object.prototype.hasOwnProperty.call(argv, key) &&
                        Object.prototype.hasOwnProperty.call(parsed.argv, key) &&
                        (Array.isArray(argv[key]) || Array.isArray(parsed.argv[key]))) ***REMOVED***
                        argv[key] = [].concat(argv[key], parsed.argv[key]);
                ***REMOVED***
                    else ***REMOVED***
                        argv[key] = parsed.argv[key];
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***
***REMOVED***
    isDefaulted(yargs, key) ***REMOVED***
        const ***REMOVED*** default: defaults ***REMOVED*** = yargs.getOptions();
        return (Object.prototype.hasOwnProperty.call(defaults, key) ||
            Object.prototype.hasOwnProperty.call(defaults, this.shim.Parser.camelCase(key)));
***REMOVED***
    isInConfigs(yargs, key) ***REMOVED***
        const ***REMOVED*** configObjects ***REMOVED*** = yargs.getOptions();
        return (configObjects.some(c => Object.prototype.hasOwnProperty.call(c, key)) ||
            configObjects.some(c => Object.prototype.hasOwnProperty.call(c, this.shim.Parser.camelCase(key))));
***REMOVED***
    runDefaultBuilderOn(yargs) ***REMOVED***
        if (!this.defaultCommand)
            return;
        if (this.shouldUpdateUsage(yargs)) ***REMOVED***
            const commandString = DEFAULT_MARKER.test(this.defaultCommand.original)
                ? this.defaultCommand.original
                : this.defaultCommand.original.replace(/^[^[\]<>]*/, '$0 ');
            yargs
                .getInternalMethods()
                .getUsageInstance()
                .usage(commandString, this.defaultCommand.description);
    ***REMOVED***
        const builder = this.defaultCommand.builder;
        if (isCommandBuilderCallback(builder)) ***REMOVED***
            return builder(yargs, true);
    ***REMOVED***
        else if (!isCommandBuilderDefinition(builder)) ***REMOVED***
            Object.keys(builder).forEach(key => ***REMOVED***
                yargs.option(key, builder[key]);
        ***REMOVED***);
    ***REMOVED***
        return undefined;
***REMOVED***
    moduleName(obj) ***REMOVED***
        const mod = whichModule(obj);
        if (!mod)
            throw new Error(`No command name given for module: $***REMOVED***this.shim.inspect(obj)***REMOVED***`);
        return this.commandFromFilename(mod.filename);
***REMOVED***
    commandFromFilename(filename) ***REMOVED***
        return this.shim.path.basename(filename, this.shim.path.extname(filename));
***REMOVED***
    extractDesc(***REMOVED*** describe, description, desc ***REMOVED***) ***REMOVED***
        for (const test of [describe, description, desc]) ***REMOVED***
            if (typeof test === 'string' || test === false)
                return test;
            assertNotStrictEqual(test, true, this.shim);
    ***REMOVED***
        return false;
***REMOVED***
    freeze() ***REMOVED***
        this.frozens.push(***REMOVED***
            handlers: this.handlers,
            aliasMap: this.aliasMap,
            defaultCommand: this.defaultCommand,
    ***REMOVED***);
***REMOVED***
    unfreeze() ***REMOVED***
        const frozen = this.frozens.pop();
        assertNotStrictEqual(frozen, undefined, this.shim);
        (***REMOVED***
            handlers: this.handlers,
            aliasMap: this.aliasMap,
            defaultCommand: this.defaultCommand,
    ***REMOVED*** = frozen);
***REMOVED***
    reset() ***REMOVED***
        this.handlers = ***REMOVED******REMOVED***;
        this.aliasMap = ***REMOVED******REMOVED***;
        this.defaultCommand = undefined;
        this.requireCache = new Set();
        return this;
***REMOVED***
***REMOVED***
export function command(usage, validation, globalMiddleware, shim) ***REMOVED***
    return new CommandInstance(usage, validation, globalMiddleware, shim);
***REMOVED***
export function isCommandBuilderDefinition(builder) ***REMOVED***
    return (typeof builder === 'object' &&
        !!builder.builder &&
        typeof builder.handler === 'function');
***REMOVED***
function isCommandAndAliases(cmd) ***REMOVED***
    return cmd.every(c => typeof c === 'string');
***REMOVED***
export function isCommandBuilderCallback(builder) ***REMOVED***
    return typeof builder === 'function';
***REMOVED***
function isCommandBuilderOptionDefinitions(builder) ***REMOVED***
    return typeof builder === 'object';
***REMOVED***
export function isCommandHandlerDefinition(cmd) ***REMOVED***
    return typeof cmd === 'object' && !Array.isArray(cmd);
***REMOVED***
