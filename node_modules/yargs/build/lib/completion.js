import ***REMOVED*** isCommandBuilderCallback ***REMOVED*** from './command.js';
import ***REMOVED*** assertNotStrictEqual ***REMOVED*** from './typings/common-types.js';
import * as templates from './completion-templates.js';
import ***REMOVED*** isPromise ***REMOVED*** from './utils/is-promise.js';
import ***REMOVED*** parseCommand ***REMOVED*** from './parse-command.js';
export class Completion ***REMOVED***
    constructor(yargs, usage, command, shim) ***REMOVED***
        var _a, _b, _c;
        this.yargs = yargs;
        this.usage = usage;
        this.command = command;
        this.shim = shim;
        this.completionKey = 'get-yargs-completions';
        this.aliases = null;
        this.customCompletionFunction = null;
        this.indexAfterLastReset = 0;
        this.zshShell =
            (_c = (((_a = this.shim.getEnv('SHELL')) === null || _a === void 0 ? void 0 : _a.includes('zsh')) ||
                ((_b = this.shim.getEnv('ZSH_NAME')) === null || _b === void 0 ? void 0 : _b.includes('zsh')))) !== null && _c !== void 0 ? _c : false;
***REMOVED***
    defaultCompletion(args, argv, current, done) ***REMOVED***
        const handlers = this.command.getCommandHandlers();
        for (let i = 0, ii = args.length; i < ii; ++i) ***REMOVED***
            if (handlers[args[i]] && handlers[args[i]].builder) ***REMOVED***
                const builder = handlers[args[i]].builder;
                if (isCommandBuilderCallback(builder)) ***REMOVED***
                    this.indexAfterLastReset = i + 1;
                    const y = this.yargs.getInternalMethods().reset();
                    builder(y, true);
                    return y.argv;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
        const completions = [];
        this.commandCompletions(completions, args, current);
        this.optionCompletions(completions, args, argv, current);
        this.choicesFromOptionsCompletions(completions, args, argv, current);
        this.choicesFromPositionalsCompletions(completions, args, argv, current);
        done(null, completions);
***REMOVED***
    commandCompletions(completions, args, current) ***REMOVED***
        const parentCommands = this.yargs
            .getInternalMethods()
            .getContext().commands;
        if (!current.match(/^-/) &&
            parentCommands[parentCommands.length - 1] !== current &&
            !this.previousArgHasChoices(args)) ***REMOVED***
            this.usage.getCommands().forEach(usageCommand => ***REMOVED***
                const commandName = parseCommand(usageCommand[0]).cmd;
                if (args.indexOf(commandName) === -1) ***REMOVED***
                    if (!this.zshShell) ***REMOVED***
                        completions.push(commandName);
                ***REMOVED***
                    else ***REMOVED***
                        const desc = usageCommand[1] || '';
                        completions.push(commandName.replace(/:/g, '\\:') + ':' + desc);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***
***REMOVED***
    optionCompletions(completions, args, argv, current) ***REMOVED***
        if ((current.match(/^-/) || (current === '' && completions.length === 0)) &&
            !this.previousArgHasChoices(args)) ***REMOVED***
            const options = this.yargs.getOptions();
            const positionalKeys = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
            Object.keys(options.key).forEach(key => ***REMOVED***
                const negable = !!options.configuration['boolean-negation'] &&
                    options.boolean.includes(key);
                const isPositionalKey = positionalKeys.includes(key);
                if (!isPositionalKey &&
                    !options.hiddenOptions.includes(key) &&
                    !this.argsContainKey(args, key, negable)) ***REMOVED***
                    this.completeOptionKey(key, completions, current);
                    if (negable && !!options.default[key])
                        this.completeOptionKey(`no-$***REMOVED***key***REMOVED***`, completions, current);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***
***REMOVED***
    choicesFromOptionsCompletions(completions, args, argv, current) ***REMOVED***
        if (this.previousArgHasChoices(args)) ***REMOVED***
            const choices = this.getPreviousArgChoices(args);
            if (choices && choices.length > 0) ***REMOVED***
                completions.push(...choices.map(c => c.replace(/:/g, '\\:')));
        ***REMOVED***
    ***REMOVED***
***REMOVED***
    choicesFromPositionalsCompletions(completions, args, argv, current) ***REMOVED***
        if (current === '' &&
            completions.length > 0 &&
            this.previousArgHasChoices(args)) ***REMOVED***
            return;
    ***REMOVED***
        const positionalKeys = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
        const offset = Math.max(this.indexAfterLastReset, this.yargs.getInternalMethods().getContext().commands.length +
            1);
        const positionalKey = positionalKeys[argv._.length - offset - 1];
        if (!positionalKey) ***REMOVED***
            return;
    ***REMOVED***
        const choices = this.yargs.getOptions().choices[positionalKey] || [];
        for (const choice of choices) ***REMOVED***
            if (choice.startsWith(current)) ***REMOVED***
                completions.push(choice.replace(/:/g, '\\:'));
        ***REMOVED***
    ***REMOVED***
***REMOVED***
    getPreviousArgChoices(args) ***REMOVED***
        if (args.length < 1)
            return;
        let previousArg = args[args.length - 1];
        let filter = '';
        if (!previousArg.startsWith('-') && args.length > 1) ***REMOVED***
            filter = previousArg;
            previousArg = args[args.length - 2];
    ***REMOVED***
        if (!previousArg.startsWith('-'))
            return;
        const previousArgKey = previousArg.replace(/^-+/, '');
        const options = this.yargs.getOptions();
        const possibleAliases = [
            previousArgKey,
            ...(this.yargs.getAliases()[previousArgKey] || []),
        ];
        let choices;
        for (const possibleAlias of possibleAliases) ***REMOVED***
            if (Object.prototype.hasOwnProperty.call(options.key, possibleAlias) &&
                Array.isArray(options.choices[possibleAlias])) ***REMOVED***
                choices = options.choices[possibleAlias];
                break;
        ***REMOVED***
    ***REMOVED***
        if (choices) ***REMOVED***
            return choices.filter(choice => !filter || choice.startsWith(filter));
    ***REMOVED***
***REMOVED***
    previousArgHasChoices(args) ***REMOVED***
        const choices = this.getPreviousArgChoices(args);
        return choices !== undefined && choices.length > 0;
***REMOVED***
    argsContainKey(args, key, negable) ***REMOVED***
        const argsContains = (s) => args.indexOf((/^[^0-9]$/.test(s) ? '-' : '--') + s) !== -1;
        if (argsContains(key))
            return true;
        if (negable && argsContains(`no-$***REMOVED***key***REMOVED***`))
            return true;
        if (this.aliases) ***REMOVED***
            for (const alias of this.aliases[key]) ***REMOVED***
                if (argsContains(alias))
                    return true;
        ***REMOVED***
    ***REMOVED***
        return false;
***REMOVED***
    completeOptionKey(key, completions, current) ***REMOVED***
        const descs = this.usage.getDescriptions();
        const startsByTwoDashes = (s) => /^--/.test(s);
        const isShortOption = (s) => /^[^0-9]$/.test(s);
        const dashes = !startsByTwoDashes(current) && isShortOption(key) ? '-' : '--';
        if (!this.zshShell) ***REMOVED***
            completions.push(dashes + key);
    ***REMOVED***
        else ***REMOVED***
            const desc = descs[key] || '';
            completions.push(dashes +
                `$***REMOVED***key.replace(/:/g, '\\:')***REMOVED***:$***REMOVED***desc.replace('__yargsString__:', '')***REMOVED***`);
    ***REMOVED***
***REMOVED***
    customCompletion(args, argv, current, done) ***REMOVED***
        assertNotStrictEqual(this.customCompletionFunction, null, this.shim);
        if (isSyncCompletionFunction(this.customCompletionFunction)) ***REMOVED***
            const result = this.customCompletionFunction(current, argv);
            if (isPromise(result)) ***REMOVED***
                return result
                    .then(list => ***REMOVED***
                    this.shim.process.nextTick(() => ***REMOVED***
                        done(null, list);
                ***REMOVED***);
            ***REMOVED***)
                    .catch(err => ***REMOVED***
                    this.shim.process.nextTick(() => ***REMOVED***
                        done(err, undefined);
                ***REMOVED***);
            ***REMOVED***);
        ***REMOVED***
            return done(null, result);
    ***REMOVED***
        else if (isFallbackCompletionFunction(this.customCompletionFunction)) ***REMOVED***
            return this.customCompletionFunction(current, argv, (onCompleted = done) => this.defaultCompletion(args, argv, current, onCompleted), completions => ***REMOVED***
                done(null, completions);
        ***REMOVED***);
    ***REMOVED***
        else ***REMOVED***
            return this.customCompletionFunction(current, argv, completions => ***REMOVED***
                done(null, completions);
        ***REMOVED***);
    ***REMOVED***
***REMOVED***
    getCompletion(args, done) ***REMOVED***
        const current = args.length ? args[args.length - 1] : '';
        const argv = this.yargs.parse(args, true);
        const completionFunction = this.customCompletionFunction
            ? (argv) => this.customCompletion(args, argv, current, done)
            : (argv) => this.defaultCompletion(args, argv, current, done);
        return isPromise(argv)
            ? argv.then(completionFunction)
            : completionFunction(argv);
***REMOVED***
    generateCompletionScript($0, cmd) ***REMOVED***
        let script = this.zshShell
            ? templates.completionZshTemplate
            : templates.completionShTemplate;
        const name = this.shim.path.basename($0);
        if ($0.match(/\.js$/))
            $0 = `./$***REMOVED***$0***REMOVED***`;
        script = script.replace(/***REMOVED******REMOVED***app_name***REMOVED******REMOVED***/g, name);
        script = script.replace(/***REMOVED******REMOVED***completion_command***REMOVED******REMOVED***/g, cmd);
        return script.replace(/***REMOVED******REMOVED***app_path***REMOVED******REMOVED***/g, $0);
***REMOVED***
    registerFunction(fn) ***REMOVED***
        this.customCompletionFunction = fn;
***REMOVED***
    setParsed(parsed) ***REMOVED***
        this.aliases = parsed.aliases;
***REMOVED***
***REMOVED***
export function completion(yargs, usage, command, shim) ***REMOVED***
    return new Completion(yargs, usage, command, shim);
***REMOVED***
function isSyncCompletionFunction(completionFunction) ***REMOVED***
    return completionFunction.length < 3;
***REMOVED***
function isFallbackCompletionFunction(completionFunction) ***REMOVED***
    return completionFunction.length > 3;
***REMOVED***
