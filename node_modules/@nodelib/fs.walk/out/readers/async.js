"use strict";
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
const events_1 = require("events");
const fsScandir = require("@nodelib/fs.scandir");
const fastq = require("fastq");
const common = require("./common");
const reader_1 = require("./reader");
class AsyncReader extends reader_1.default ***REMOVED***
    constructor(_root, _settings) ***REMOVED***
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => ***REMOVED***
            if (!this._isFatalError) ***REMOVED***
                this._emitter.emit('end');
        ***REMOVED***
    ***REMOVED***;
***REMOVED***
    read() ***REMOVED***
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => ***REMOVED***
            this._pushToQueue(this._root, this._settings.basePath);
    ***REMOVED***);
        return this._emitter;
***REMOVED***
    get isDestroyed() ***REMOVED***
        return this._isDestroyed;
***REMOVED***
    destroy() ***REMOVED***
        if (this._isDestroyed) ***REMOVED***
            throw new Error('The reader is already destroyed');
    ***REMOVED***
        this._isDestroyed = true;
        this._queue.killAndDrain();
***REMOVED***
    onEntry(callback) ***REMOVED***
        this._emitter.on('entry', callback);
***REMOVED***
    onError(callback) ***REMOVED***
        this._emitter.once('error', callback);
***REMOVED***
    onEnd(callback) ***REMOVED***
        this._emitter.once('end', callback);
***REMOVED***
    _pushToQueue(directory, base) ***REMOVED***
        const queueItem = ***REMOVED*** directory, base ***REMOVED***;
        this._queue.push(queueItem, (error) => ***REMOVED***
            if (error !== null) ***REMOVED***
                this._handleError(error);
        ***REMOVED***
    ***REMOVED***);
***REMOVED***
    _worker(item, done) ***REMOVED***
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => ***REMOVED***
            if (error !== null) ***REMOVED***
                done(error, undefined);
                return;
        ***REMOVED***
            for (const entry of entries) ***REMOVED***
                this._handleEntry(entry, item.base);
        ***REMOVED***
            done(null, undefined);
    ***REMOVED***);
***REMOVED***
    _handleError(error) ***REMOVED***
        if (this._isDestroyed || !common.isFatalError(this._settings, error)) ***REMOVED***
            return;
    ***REMOVED***
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit('error', error);
***REMOVED***
    _handleEntry(entry, base) ***REMOVED***
        if (this._isDestroyed || this._isFatalError) ***REMOVED***
            return;
    ***REMOVED***
        const fullpath = entry.path;
        if (base !== undefined) ***REMOVED***
            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
    ***REMOVED***
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) ***REMOVED***
            this._emitEntry(entry);
    ***REMOVED***
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) ***REMOVED***
            this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);
    ***REMOVED***
***REMOVED***
    _emitEntry(entry) ***REMOVED***
        this._emitter.emit('entry', entry);
***REMOVED***
***REMOVED***
exports.default = AsyncReader;
