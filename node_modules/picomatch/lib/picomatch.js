'use strict';

const path = require('path');
const scan = require('./scan');
const parse = require('./parse');
const utils = require('./utils');
const constants = require('./constants');
const isObject = val => val && typeof val === 'object' && !Array.isArray(val);

/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param ***REMOVED***String|Array***REMOVED*** `globs` One or more glob patterns.
 * @param ***REMOVED***Object=***REMOVED*** `options`
 * @return ***REMOVED***Function=***REMOVED*** Returns a matcher function.
 * @api public
 */

const picomatch = (glob, options, returnState = false) => ***REMOVED***
  if (Array.isArray(glob)) ***REMOVED***
    const fns = glob.map(input => picomatch(input, options, returnState));
    const arrayMatcher = str => ***REMOVED***
      for (const isMatch of fns) ***REMOVED***
        const state = isMatch(str);
        if (state) return state;
  ***REMOVED***
      return false;
***REMOVED***;
    return arrayMatcher;
***REMOVED***

  const isState = isObject(glob) && glob.tokens && glob.input;

  if (glob === '' || (typeof glob !== 'string' && !isState)) ***REMOVED***
    throw new TypeError('Expected pattern to be a non-empty string');
***REMOVED***

  const opts = options || ***REMOVED******REMOVED***;
  const posix = utils.isWindows(options);
  const regex = isState
    ? picomatch.compileRe(glob, options)
    : picomatch.makeRe(glob, options, false, true);

  const state = regex.state;
  delete regex.state;

  let isIgnored = () => false;
  if (opts.ignore) ***REMOVED***
    const ignoreOpts = ***REMOVED*** ...options, ignore: null, onMatch: null, onResult: null ***REMOVED***;
    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
***REMOVED***

  const matcher = (input, returnObject = false) => ***REMOVED***
    const ***REMOVED*** isMatch, match, output ***REMOVED*** = picomatch.test(input, regex, options, ***REMOVED*** glob, posix ***REMOVED***);
    const result = ***REMOVED*** glob, state, regex, posix, input, output, match, isMatch ***REMOVED***;

    if (typeof opts.onResult === 'function') ***REMOVED***
      opts.onResult(result);
***REMOVED***

    if (isMatch === false) ***REMOVED***
      result.isMatch = false;
      return returnObject ? result : false;
***REMOVED***

    if (isIgnored(input)) ***REMOVED***
      if (typeof opts.onIgnore === 'function') ***REMOVED***
        opts.onIgnore(result);
  ***REMOVED***
      result.isMatch = false;
      return returnObject ? result : false;
***REMOVED***

    if (typeof opts.onMatch === 'function') ***REMOVED***
      opts.onMatch(result);
***REMOVED***
    return returnObject ? result : true;
***REMOVED***;

  if (returnState) ***REMOVED***
    matcher.state = state;
***REMOVED***

  return matcher;
***REMOVED***;

/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // ***REMOVED*** isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' ***REMOVED***
 * ```
 * @param ***REMOVED***String***REMOVED*** `input` String to test.
 * @param ***REMOVED***RegExp***REMOVED*** `regex`
 * @return ***REMOVED***Object***REMOVED*** Returns an object with matching info.
 * @api public
 */

picomatch.test = (input, regex, options, ***REMOVED*** glob, posix ***REMOVED*** = ***REMOVED******REMOVED***) => ***REMOVED***
  if (typeof input !== 'string') ***REMOVED***
    throw new TypeError('Expected input to be a string');
***REMOVED***

  if (input === '') ***REMOVED***
    return ***REMOVED*** isMatch: false, output: '' ***REMOVED***;
***REMOVED***

  const opts = options || ***REMOVED******REMOVED***;
  const format = opts.format || (posix ? utils.toPosixSlashes : null);
  let match = input === glob;
  let output = (match && format) ? format(input) : input;

  if (match === false) ***REMOVED***
    output = format ? format(input) : input;
    match = output === glob;
***REMOVED***

  if (match === false || opts.capture === true) ***REMOVED***
    if (opts.matchBase === true || opts.basename === true) ***REMOVED***
      match = picomatch.matchBase(input, regex, options, posix);
***REMOVED*** else ***REMOVED***
      match = regex.exec(output);
***REMOVED***
***REMOVED***

  return ***REMOVED*** isMatch: Boolean(match), match, output ***REMOVED***;
***REMOVED***;

/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param ***REMOVED***String***REMOVED*** `input` String to test.
 * @param ***REMOVED***RegExp|String***REMOVED*** `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => ***REMOVED***
  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
  return regex.test(path.basename(input));
***REMOVED***;

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param ***REMOVED***String|Array***REMOVED*** str The string to test.
 * @param ***REMOVED***String|Array***REMOVED*** patterns One or more glob patterns to use for matching.
 * @param ***REMOVED***Object***REMOVED*** [options] See available [options](#options).
 * @return ***REMOVED***Boolean***REMOVED*** Returns true if any patterns match `str`
 * @api public
 */

picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(pattern[, options]);
 * ```
 * @param ***REMOVED***String***REMOVED*** `pattern`
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***Object***REMOVED*** Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */

picomatch.parse = (pattern, options) => ***REMOVED***
  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));
  return parse(pattern, ***REMOVED*** ...options, fastpaths: false ***REMOVED***);
***REMOVED***;

/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * ***REMOVED*** prefix: '!./',
 *   input: '!./foo/*.js',
 *   start: 3,
 *   base: 'foo',
 *   glob: '*.js',
 *   isBrace: false,
 *   isBracket: false,
 *   isGlob: true,
 *   isExtglob: false,
 *   isGlobstar: false,
 *   negated: true ***REMOVED***
 * ```
 * @param ***REMOVED***String***REMOVED*** `input` Glob pattern to scan.
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***Object***REMOVED*** Returns an object with
 * @api public
 */

picomatch.scan = (input, options) => scan(input, options);

/**
 * Compile a regular expression from the `state` object returned by the
 * [parse()](#parse) method.
 *
 * @param ***REMOVED***Object***REMOVED*** `state`
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @param ***REMOVED***Boolean***REMOVED*** `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
 * @param ***REMOVED***Boolean***REMOVED*** `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
 * @return ***REMOVED***RegExp***REMOVED***
 * @api public
 */

picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => ***REMOVED***
  if (returnOutput === true) ***REMOVED***
    return state.output;
***REMOVED***

  const opts = options || ***REMOVED******REMOVED***;
  const prepend = opts.contains ? '' : '^';
  const append = opts.contains ? '' : '$';

  let source = `$***REMOVED***prepend***REMOVED***(?:$***REMOVED***state.output***REMOVED***)$***REMOVED***append***REMOVED***`;
  if (state && state.negated === true) ***REMOVED***
    source = `^(?!$***REMOVED***source***REMOVED***).*$`;
***REMOVED***

  const regex = picomatch.toRegex(source, options);
  if (returnState === true) ***REMOVED***
    regex.state = state;
***REMOVED***

  return regex;
***REMOVED***;

/**
 * Create a regular expression from a parsed glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const state = picomatch.parse('*.js');
 * // picomatch.compileRe(state[, options]);
 *
 * console.log(picomatch.compileRe(state));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param ***REMOVED***String***REMOVED*** `state` The object returned from the `.parse` method.
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @param ***REMOVED***Boolean***REMOVED*** `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
 * @param ***REMOVED***Boolean***REMOVED*** `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
 * @return ***REMOVED***RegExp***REMOVED*** Returns a regex created from the given pattern.
 * @api public
 */

picomatch.makeRe = (input, options = ***REMOVED******REMOVED***, returnOutput = false, returnState = false) => ***REMOVED***
  if (!input || typeof input !== 'string') ***REMOVED***
    throw new TypeError('Expected a non-empty string');
***REMOVED***

  let parsed = ***REMOVED*** negated: false, fastpaths: true ***REMOVED***;

  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) ***REMOVED***
    parsed.output = parse.fastpaths(input, options);
***REMOVED***

  if (!parsed.output) ***REMOVED***
    parsed = parse(input, options);
***REMOVED***

  return picomatch.compileRe(parsed, options, returnOutput, returnState);
***REMOVED***;

/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const ***REMOVED*** output ***REMOVED*** = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param ***REMOVED***String***REMOVED*** `source` Regular expression source string.
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***RegExp***REMOVED***
 * @api public
 */

picomatch.toRegex = (source, options) => ***REMOVED***
  try ***REMOVED***
    const opts = options || ***REMOVED******REMOVED***;
    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
***REMOVED*** catch (err) ***REMOVED***
    if (options && options.debug === true) throw err;
    return /$^/;
***REMOVED***
***REMOVED***;

/**
 * Picomatch constants.
 * @return ***REMOVED***Object***REMOVED***
 */

picomatch.constants = constants;

/**
 * Expose "picomatch"
 */

module.exports = picomatch;
