'use strict';

const utils = require('./utils');
const ***REMOVED***
  CHAR_ASTERISK,             /* * */
  CHAR_AT,                   /* @ */
  CHAR_BACKWARD_SLASH,       /* \ */
  CHAR_COMMA,                /* , */
  CHAR_DOT,                  /* . */
  CHAR_EXCLAMATION_MARK,     /* ! */
  CHAR_FORWARD_SLASH,        /* / */
  CHAR_LEFT_CURLY_BRACE,     /* ***REMOVED*** */
  CHAR_LEFT_PARENTHESES,     /* ( */
  CHAR_LEFT_SQUARE_BRACKET,  /* [ */
  CHAR_PLUS,                 /* + */
  CHAR_QUESTION_MARK,        /* ? */
  CHAR_RIGHT_CURLY_BRACE,    /* ***REMOVED*** */
  CHAR_RIGHT_PARENTHESES,    /* ) */
  CHAR_RIGHT_SQUARE_BRACKET  /* ] */
***REMOVED*** = require('./constants');

const isPathSeparator = code => ***REMOVED***
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
***REMOVED***;

const depth = token => ***REMOVED***
  if (token.isPrefix !== true) ***REMOVED***
    token.depth = token.isGlobstar ? Infinity : 1;
***REMOVED***
***REMOVED***;

/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
 * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * ***REMOVED*** isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' ***REMOVED***
 * ```
 * @param ***REMOVED***String***REMOVED*** `str`
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***Object***REMOVED*** Returns an object with tokens and regex source string.
 * @api public
 */

const scan = (input, options) => ***REMOVED***
  const opts = options || ***REMOVED******REMOVED***;

  const length = input.length - 1;
  const scanToEnd = opts.parts === true || opts.scanToEnd === true;
  const slashes = [];
  const tokens = [];
  const parts = [];

  let str = input;
  let index = -1;
  let start = 0;
  let lastIndex = 0;
  let isBrace = false;
  let isBracket = false;
  let isGlob = false;
  let isExtglob = false;
  let isGlobstar = false;
  let braceEscaped = false;
  let backslashes = false;
  let negated = false;
  let negatedExtglob = false;
  let finished = false;
  let braces = 0;
  let prev;
  let code;
  let token = ***REMOVED*** value: '', depth: 0, isGlob: false ***REMOVED***;

  const eos = () => index >= length;
  const peek = () => str.charCodeAt(index + 1);
  const advance = () => ***REMOVED***
    prev = code;
    return str.charCodeAt(++index);
***REMOVED***;

  while (index < length) ***REMOVED***
    code = advance();
    let next;

    if (code === CHAR_BACKWARD_SLASH) ***REMOVED***
      backslashes = token.backslashes = true;
      code = advance();

      if (code === CHAR_LEFT_CURLY_BRACE) ***REMOVED***
        braceEscaped = true;
  ***REMOVED***
      continue;
***REMOVED***

    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) ***REMOVED***
      braces++;

      while (eos() !== true && (code = advance())) ***REMOVED***
        if (code === CHAR_BACKWARD_SLASH) ***REMOVED***
          backslashes = token.backslashes = true;
          advance();
          continue;
    ***REMOVED***

        if (code === CHAR_LEFT_CURLY_BRACE) ***REMOVED***
          braces++;
          continue;
    ***REMOVED***

        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) ***REMOVED***
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) ***REMOVED***
            continue;
      ***REMOVED***

          break;
    ***REMOVED***

        if (braceEscaped !== true && code === CHAR_COMMA) ***REMOVED***
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) ***REMOVED***
            continue;
      ***REMOVED***

          break;
    ***REMOVED***

        if (code === CHAR_RIGHT_CURLY_BRACE) ***REMOVED***
          braces--;

          if (braces === 0) ***REMOVED***
            braceEscaped = false;
            isBrace = token.isBrace = true;
            finished = true;
            break;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

      if (scanToEnd === true) ***REMOVED***
        continue;
  ***REMOVED***

      break;
***REMOVED***

    if (code === CHAR_FORWARD_SLASH) ***REMOVED***
      slashes.push(index);
      tokens.push(token);
      token = ***REMOVED*** value: '', depth: 0, isGlob: false ***REMOVED***;

      if (finished === true) continue;
      if (prev === CHAR_DOT && index === (start + 1)) ***REMOVED***
        start += 2;
        continue;
  ***REMOVED***

      lastIndex = index + 1;
      continue;
***REMOVED***

    if (opts.noext !== true) ***REMOVED***
      const isExtglobChar = code === CHAR_PLUS
        || code === CHAR_AT
        || code === CHAR_ASTERISK
        || code === CHAR_QUESTION_MARK
        || code === CHAR_EXCLAMATION_MARK;

      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) ***REMOVED***
        isGlob = token.isGlob = true;
        isExtglob = token.isExtglob = true;
        finished = true;
        if (code === CHAR_EXCLAMATION_MARK && index === start) ***REMOVED***
          negatedExtglob = true;
    ***REMOVED***

        if (scanToEnd === true) ***REMOVED***
          while (eos() !== true && (code = advance())) ***REMOVED***
            if (code === CHAR_BACKWARD_SLASH) ***REMOVED***
              backslashes = token.backslashes = true;
              code = advance();
              continue;
        ***REMOVED***

            if (code === CHAR_RIGHT_PARENTHESES) ***REMOVED***
              isGlob = token.isGlob = true;
              finished = true;
              break;
        ***REMOVED***
      ***REMOVED***
          continue;
    ***REMOVED***
        break;
  ***REMOVED***
***REMOVED***

    if (code === CHAR_ASTERISK) ***REMOVED***
      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) ***REMOVED***
        continue;
  ***REMOVED***
      break;
***REMOVED***

    if (code === CHAR_QUESTION_MARK) ***REMOVED***
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) ***REMOVED***
        continue;
  ***REMOVED***
      break;
***REMOVED***

    if (code === CHAR_LEFT_SQUARE_BRACKET) ***REMOVED***
      while (eos() !== true && (next = advance())) ***REMOVED***
        if (next === CHAR_BACKWARD_SLASH) ***REMOVED***
          backslashes = token.backslashes = true;
          advance();
          continue;
    ***REMOVED***

        if (next === CHAR_RIGHT_SQUARE_BRACKET) ***REMOVED***
          isBracket = token.isBracket = true;
          isGlob = token.isGlob = true;
          finished = true;
          break;
    ***REMOVED***
  ***REMOVED***

      if (scanToEnd === true) ***REMOVED***
        continue;
  ***REMOVED***

      break;
***REMOVED***

    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) ***REMOVED***
      negated = token.negated = true;
      start++;
      continue;
***REMOVED***

    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) ***REMOVED***
      isGlob = token.isGlob = true;

      if (scanToEnd === true) ***REMOVED***
        while (eos() !== true && (code = advance())) ***REMOVED***
          if (code === CHAR_LEFT_PARENTHESES) ***REMOVED***
            backslashes = token.backslashes = true;
            code = advance();
            continue;
      ***REMOVED***

          if (code === CHAR_RIGHT_PARENTHESES) ***REMOVED***
            finished = true;
            break;
      ***REMOVED***
    ***REMOVED***
        continue;
  ***REMOVED***
      break;
***REMOVED***

    if (isGlob === true) ***REMOVED***
      finished = true;

      if (scanToEnd === true) ***REMOVED***
        continue;
  ***REMOVED***

      break;
***REMOVED***
***REMOVED***

  if (opts.noext === true) ***REMOVED***
    isExtglob = false;
    isGlob = false;
***REMOVED***

  let base = str;
  let prefix = '';
  let glob = '';

  if (start > 0) ***REMOVED***
    prefix = str.slice(0, start);
    str = str.slice(start);
    lastIndex -= start;
***REMOVED***

  if (base && isGlob === true && lastIndex > 0) ***REMOVED***
    base = str.slice(0, lastIndex);
    glob = str.slice(lastIndex);
***REMOVED*** else if (isGlob === true) ***REMOVED***
    base = '';
    glob = str;
***REMOVED*** else ***REMOVED***
    base = str;
***REMOVED***

  if (base && base !== '' && base !== '/' && base !== str) ***REMOVED***
    if (isPathSeparator(base.charCodeAt(base.length - 1))) ***REMOVED***
      base = base.slice(0, -1);
***REMOVED***
***REMOVED***

  if (opts.unescape === true) ***REMOVED***
    if (glob) glob = utils.removeBackslashes(glob);

    if (base && backslashes === true) ***REMOVED***
      base = utils.removeBackslashes(base);
***REMOVED***
***REMOVED***

  const state = ***REMOVED***
    prefix,
    input,
    start,
    base,
    glob,
    isBrace,
    isBracket,
    isGlob,
    isExtglob,
    isGlobstar,
    negated,
    negatedExtglob
***REMOVED***;

  if (opts.tokens === true) ***REMOVED***
    state.maxDepth = 0;
    if (!isPathSeparator(code)) ***REMOVED***
      tokens.push(token);
***REMOVED***
    state.tokens = tokens;
***REMOVED***

  if (opts.parts === true || opts.tokens === true) ***REMOVED***
    let prevIndex;

    for (let idx = 0; idx < slashes.length; idx++) ***REMOVED***
      const n = prevIndex ? prevIndex + 1 : start;
      const i = slashes[idx];
      const value = input.slice(n, i);
      if (opts.tokens) ***REMOVED***
        if (idx === 0 && start !== 0) ***REMOVED***
          tokens[idx].isPrefix = true;
          tokens[idx].value = prefix;
    ***REMOVED*** else ***REMOVED***
          tokens[idx].value = value;
    ***REMOVED***
        depth(tokens[idx]);
        state.maxDepth += tokens[idx].depth;
  ***REMOVED***
      if (idx !== 0 || value !== '') ***REMOVED***
        parts.push(value);
  ***REMOVED***
      prevIndex = i;
***REMOVED***

    if (prevIndex && prevIndex + 1 < input.length) ***REMOVED***
      const value = input.slice(prevIndex + 1);
      parts.push(value);

      if (opts.tokens) ***REMOVED***
        tokens[tokens.length - 1].value = value;
        depth(tokens[tokens.length - 1]);
        state.maxDepth += tokens[tokens.length - 1].depth;
  ***REMOVED***
***REMOVED***

    state.slashes = slashes;
    state.parts = parts;
***REMOVED***

  return state;
***REMOVED***;

module.exports = scan;
