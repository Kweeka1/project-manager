'use strict';

const constants = require('./constants');
const utils = require('./utils');

/**
 * Constants
 */

const ***REMOVED***
  MAX_LENGTH,
  POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
***REMOVED*** = constants;

/**
 * Helpers
 */

const expandRange = (args, options) => ***REMOVED***
  if (typeof options.expandRange === 'function') ***REMOVED***
    return options.expandRange(...args, options);
***REMOVED***

  args.sort();
  const value = `[$***REMOVED***args.join('-')***REMOVED***]`;

  try ***REMOVED***
    /* eslint-disable-next-line no-new */
    new RegExp(value);
***REMOVED*** catch (ex) ***REMOVED***
    return args.map(v => utils.escapeRegex(v)).join('..');
***REMOVED***

  return value;
***REMOVED***;

/**
 * Create the message for a syntax error
 */

const syntaxError = (type, char) => ***REMOVED***
  return `Missing $***REMOVED***type***REMOVED***: "$***REMOVED***char***REMOVED***" - use "\\\\$***REMOVED***char***REMOVED***" to match literal characters`;
***REMOVED***;

/**
 * Parse the given input string.
 * @param ***REMOVED***String***REMOVED*** input
 * @param ***REMOVED***Object***REMOVED*** options
 * @return ***REMOVED***Object***REMOVED***
 */

const parse = (input, options) => ***REMOVED***
  if (typeof input !== 'string') ***REMOVED***
    throw new TypeError('Expected a string');
***REMOVED***

  input = REPLACEMENTS[input] || input;

  const opts = ***REMOVED*** ...options ***REMOVED***;
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;

  let len = input.length;
  if (len > max) ***REMOVED***
    throw new SyntaxError(`Input length: $***REMOVED***len***REMOVED***, exceeds maximum allowed length: $***REMOVED***max***REMOVED***`);
***REMOVED***

  const bos = ***REMOVED*** type: 'bos', value: '', output: opts.prepend || '' ***REMOVED***;
  const tokens = [bos];

  const capture = opts.capture ? '' : '?:';
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const PLATFORM_CHARS = constants.globChars(win32);
  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);

  const ***REMOVED***
    DOT_LITERAL,
    PLUS_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
***REMOVED*** = PLATFORM_CHARS;

  const globstar = opts => ***REMOVED***
    return `($***REMOVED***capture***REMOVED***(?:(?!$***REMOVED***START_ANCHOR***REMOVED***$***REMOVED***opts.dot ? DOTS_SLASH : DOT_LITERAL***REMOVED***).)*?)`;
***REMOVED***;

  const nodot = opts.dot ? '' : NO_DOT;
  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
  let star = opts.bash === true ? globstar(opts) : STAR;

  if (opts.capture) ***REMOVED***
    star = `($***REMOVED***star***REMOVED***)`;
***REMOVED***

  // minimatch options support
  if (typeof opts.noext === 'boolean') ***REMOVED***
    opts.noextglob = opts.noext;
***REMOVED***

  const state = ***REMOVED***
    input,
    index: -1,
    start: 0,
    dot: opts.dot === true,
    consumed: '',
    output: '',
    prefix: '',
    backtrack: false,
    negated: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: false,
    tokens
***REMOVED***;

  input = utils.removePrefix(input, state);
  len = input.length;

  const extglobs = [];
  const braces = [];
  const stack = [];
  let prev = bos;
  let value;

  /**
   * Tokenizing helpers
   */

  const eos = () => state.index === len - 1;
  const peek = state.peek = (n = 1) => input[state.index + n];
  const advance = state.advance = () => input[++state.index] || '';
  const remaining = () => input.slice(state.index + 1);
  const consume = (value = '', num = 0) => ***REMOVED***
    state.consumed += value;
    state.index += num;
***REMOVED***;

  const append = token => ***REMOVED***
    state.output += token.output != null ? token.output : token.value;
    consume(token.value);
***REMOVED***;

  const negate = () => ***REMOVED***
    let count = 1;

    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) ***REMOVED***
      advance();
      state.start++;
      count++;
***REMOVED***

    if (count % 2 === 0) ***REMOVED***
      return false;
***REMOVED***

    state.negated = true;
    state.start++;
    return true;
***REMOVED***;

  const increment = type => ***REMOVED***
    state[type]++;
    stack.push(type);
***REMOVED***;

  const decrement = type => ***REMOVED***
    state[type]--;
    stack.pop();
***REMOVED***;

  /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */

  const push = tok => ***REMOVED***
    if (prev.type === 'globstar') ***REMOVED***
      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));

      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) ***REMOVED***
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = 'star';
        prev.value = '*';
        prev.output = star;
        state.output += prev.output;
  ***REMOVED***
***REMOVED***

    if (extglobs.length && tok.type !== 'paren') ***REMOVED***
      extglobs[extglobs.length - 1].inner += tok.value;
***REMOVED***

    if (tok.value || tok.output) append(tok);
    if (prev && prev.type === 'text' && tok.type === 'text') ***REMOVED***
      prev.value += tok.value;
      prev.output = (prev.output || '') + tok.value;
      return;
***REMOVED***

    tok.prev = prev;
    tokens.push(tok);
    prev = tok;
***REMOVED***;

  const extglobOpen = (type, value) => ***REMOVED***
    const token = ***REMOVED*** ...EXTGLOB_CHARS[value], conditions: 1, inner: '' ***REMOVED***;

    token.prev = prev;
    token.parens = state.parens;
    token.output = state.output;
    const output = (opts.capture ? '(' : '') + token.open;

    increment('parens');
    push(***REMOVED*** type, value, output: state.output ? '' : ONE_CHAR ***REMOVED***);
    push(***REMOVED*** type: 'paren', extglob: true, value: advance(), output ***REMOVED***);
    extglobs.push(token);
***REMOVED***;

  const extglobClose = token => ***REMOVED***
    let output = token.close + (opts.capture ? ')' : '');
    let rest;

    if (token.type === 'negate') ***REMOVED***
      let extglobStar = star;

      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) ***REMOVED***
        extglobStar = globstar(opts);
  ***REMOVED***

      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) ***REMOVED***
        output = token.close = `)$))$***REMOVED***extglobStar***REMOVED***`;
  ***REMOVED***

      if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) ***REMOVED***
        // Any non-magical string (`.ts`) or even nested expression (`.***REMOVED***ts,tsx***REMOVED***`) can follow after the closing parenthesis.
        // In this case, we need to parse the string and use it in the output of the original pattern.
        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).***REMOVED***ts,tsx***REMOVED***`, `**/!(*-dbg).@(js)`.
        //
        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
        const expression = parse(rest, ***REMOVED*** ...options, fastpaths: false ***REMOVED***).output;

        output = token.close = `)$***REMOVED***expression***REMOVED***)$***REMOVED***extglobStar***REMOVED***)`;
  ***REMOVED***

      if (token.prev.type === 'bos') ***REMOVED***
        state.negatedExtglob = true;
  ***REMOVED***
***REMOVED***

    push(***REMOVED*** type: 'paren', extglob: true, value, output ***REMOVED***);
    decrement('parens');
***REMOVED***;

  /**
   * Fast paths
   */

  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]***REMOVED******REMOVED***"])/.test(input)) ***REMOVED***
    let backslashes = false;

    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => ***REMOVED***
      if (first === '\\') ***REMOVED***
        backslashes = true;
        return m;
  ***REMOVED***

      if (first === '?') ***REMOVED***
        if (esc) ***REMOVED***
          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
    ***REMOVED***
        if (index === 0) ***REMOVED***
          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
    ***REMOVED***
        return QMARK.repeat(chars.length);
  ***REMOVED***

      if (first === '.') ***REMOVED***
        return DOT_LITERAL.repeat(chars.length);
  ***REMOVED***

      if (first === '*') ***REMOVED***
        if (esc) ***REMOVED***
          return esc + first + (rest ? star : '');
    ***REMOVED***
        return star;
  ***REMOVED***
      return esc ? m : `\\$***REMOVED***m***REMOVED***`;
***REMOVED***);

    if (backslashes === true) ***REMOVED***
      if (opts.unescape === true) ***REMOVED***
        output = output.replace(/\\/g, '');
  ***REMOVED*** else ***REMOVED***
        output = output.replace(/\\+/g, m => ***REMOVED***
          return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

    if (output === input && opts.contains === true) ***REMOVED***
      state.output = input;
      return state;
***REMOVED***

    state.output = utils.wrapOutput(output, state, options);
    return state;
***REMOVED***

  /**
   * Tokenize input until we reach end-of-string
   */

  while (!eos()) ***REMOVED***
    value = advance();

    if (value === '\u0000') ***REMOVED***
      continue;
***REMOVED***

    /**
     * Escaped characters
     */

    if (value === '\\') ***REMOVED***
      const next = peek();

      if (next === '/' && opts.bash !== true) ***REMOVED***
        continue;
  ***REMOVED***

      if (next === '.' || next === ';') ***REMOVED***
        continue;
  ***REMOVED***

      if (!next) ***REMOVED***
        value += '\\';
        push(***REMOVED*** type: 'text', value ***REMOVED***);
        continue;
  ***REMOVED***

      // collapse slashes to reduce potential for exploits
      const match = /^\\+/.exec(remaining());
      let slashes = 0;

      if (match && match[0].length > 2) ***REMOVED***
        slashes = match[0].length;
        state.index += slashes;
        if (slashes % 2 !== 0) ***REMOVED***
          value += '\\';
    ***REMOVED***
  ***REMOVED***

      if (opts.unescape === true) ***REMOVED***
        value = advance();
  ***REMOVED*** else ***REMOVED***
        value += advance();
  ***REMOVED***

      if (state.brackets === 0) ***REMOVED***
        push(***REMOVED*** type: 'text', value ***REMOVED***);
        continue;
  ***REMOVED***
***REMOVED***

    /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */

    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) ***REMOVED***
      if (opts.posix !== false && value === ':') ***REMOVED***
        const inner = prev.value.slice(1);
        if (inner.includes('[')) ***REMOVED***
          prev.posix = true;

          if (inner.includes(':')) ***REMOVED***
            const idx = prev.value.lastIndexOf('[');
            const pre = prev.value.slice(0, idx);
            const rest = prev.value.slice(idx + 2);
            const posix = POSIX_REGEX_SOURCE[rest];
            if (posix) ***REMOVED***
              prev.value = pre + posix;
              state.backtrack = true;
              advance();

              if (!bos.output && tokens.indexOf(prev) === 1) ***REMOVED***
                bos.output = ONE_CHAR;
          ***REMOVED***
              continue;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) ***REMOVED***
        value = `\\$***REMOVED***value***REMOVED***`;
  ***REMOVED***

      if (value === ']' && (prev.value === '[' || prev.value === '[^')) ***REMOVED***
        value = `\\$***REMOVED***value***REMOVED***`;
  ***REMOVED***

      if (opts.posix === true && value === '!' && prev.value === '[') ***REMOVED***
        value = '^';
  ***REMOVED***

      prev.value += value;
      append(***REMOVED*** value ***REMOVED***);
      continue;
***REMOVED***

    /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */

    if (state.quotes === 1 && value !== '"') ***REMOVED***
      value = utils.escapeRegex(value);
      prev.value += value;
      append(***REMOVED*** value ***REMOVED***);
      continue;
***REMOVED***

    /**
     * Double quotes
     */

    if (value === '"') ***REMOVED***
      state.quotes = state.quotes === 1 ? 0 : 1;
      if (opts.keepQuotes === true) ***REMOVED***
        push(***REMOVED*** type: 'text', value ***REMOVED***);
  ***REMOVED***
      continue;
***REMOVED***

    /**
     * Parentheses
     */

    if (value === '(') ***REMOVED***
      increment('parens');
      push(***REMOVED*** type: 'paren', value ***REMOVED***);
      continue;
***REMOVED***

    if (value === ')') ***REMOVED***
      if (state.parens === 0 && opts.strictBrackets === true) ***REMOVED***
        throw new SyntaxError(syntaxError('opening', '('));
  ***REMOVED***

      const extglob = extglobs[extglobs.length - 1];
      if (extglob && state.parens === extglob.parens + 1) ***REMOVED***
        extglobClose(extglobs.pop());
        continue;
  ***REMOVED***

      push(***REMOVED*** type: 'paren', value, output: state.parens ? ')' : '\\)' ***REMOVED***);
      decrement('parens');
      continue;
***REMOVED***

    /**
     * Square brackets
     */

    if (value === '[') ***REMOVED***
      if (opts.nobracket === true || !remaining().includes(']')) ***REMOVED***
        if (opts.nobracket !== true && opts.strictBrackets === true) ***REMOVED***
          throw new SyntaxError(syntaxError('closing', ']'));
    ***REMOVED***

        value = `\\$***REMOVED***value***REMOVED***`;
  ***REMOVED*** else ***REMOVED***
        increment('brackets');
  ***REMOVED***

      push(***REMOVED*** type: 'bracket', value ***REMOVED***);
      continue;
***REMOVED***

    if (value === ']') ***REMOVED***
      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) ***REMOVED***
        push(***REMOVED*** type: 'text', value, output: `\\$***REMOVED***value***REMOVED***` ***REMOVED***);
        continue;
  ***REMOVED***

      if (state.brackets === 0) ***REMOVED***
        if (opts.strictBrackets === true) ***REMOVED***
          throw new SyntaxError(syntaxError('opening', '['));
    ***REMOVED***

        push(***REMOVED*** type: 'text', value, output: `\\$***REMOVED***value***REMOVED***` ***REMOVED***);
        continue;
  ***REMOVED***

      decrement('brackets');

      const prevValue = prev.value.slice(1);
      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) ***REMOVED***
        value = `/$***REMOVED***value***REMOVED***`;
  ***REMOVED***

      prev.value += value;
      append(***REMOVED*** value ***REMOVED***);

      // when literal brackets are explicitly disabled
      // assume we should match with a regex character class
      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) ***REMOVED***
        continue;
  ***REMOVED***

      const escaped = utils.escapeRegex(prev.value);
      state.output = state.output.slice(0, -prev.value.length);

      // when literal brackets are explicitly enabled
      // assume we should escape the brackets to match literal characters
      if (opts.literalBrackets === true) ***REMOVED***
        state.output += escaped;
        prev.value = escaped;
        continue;
  ***REMOVED***

      // when the user specifies nothing, try to match both
      prev.value = `($***REMOVED***capture***REMOVED***$***REMOVED***escaped***REMOVED***|$***REMOVED***prev.value***REMOVED***)`;
      state.output += prev.value;
      continue;
***REMOVED***

    /**
     * Braces
     */

    if (value === '***REMOVED***' && opts.nobrace !== true) ***REMOVED***
      increment('braces');

      const open = ***REMOVED***
        type: 'brace',
        value,
        output: '(',
        outputIndex: state.output.length,
        tokensIndex: state.tokens.length
  ***REMOVED***;

      braces.push(open);
      push(open);
      continue;
***REMOVED***

    if (value === '***REMOVED***') ***REMOVED***
      const brace = braces[braces.length - 1];

      if (opts.nobrace === true || !brace) ***REMOVED***
        push(***REMOVED*** type: 'text', value, output: value ***REMOVED***);
        continue;
  ***REMOVED***

      let output = ')';

      if (brace.dots === true) ***REMOVED***
        const arr = tokens.slice();
        const range = [];

        for (let i = arr.length - 1; i >= 0; i--) ***REMOVED***
          tokens.pop();
          if (arr[i].type === 'brace') ***REMOVED***
            break;
      ***REMOVED***
          if (arr[i].type !== 'dots') ***REMOVED***
            range.unshift(arr[i].value);
      ***REMOVED***
    ***REMOVED***

        output = expandRange(range, opts);
        state.backtrack = true;
  ***REMOVED***

      if (brace.comma !== true && brace.dots !== true) ***REMOVED***
        const out = state.output.slice(0, brace.outputIndex);
        const toks = state.tokens.slice(brace.tokensIndex);
        brace.value = brace.output = '\\***REMOVED***';
        value = output = '\\***REMOVED***';
        state.output = out;
        for (const t of toks) ***REMOVED***
          state.output += (t.output || t.value);
    ***REMOVED***
  ***REMOVED***

      push(***REMOVED*** type: 'brace', value, output ***REMOVED***);
      decrement('braces');
      braces.pop();
      continue;
***REMOVED***

    /**
     * Pipes
     */

    if (value === '|') ***REMOVED***
      if (extglobs.length > 0) ***REMOVED***
        extglobs[extglobs.length - 1].conditions++;
  ***REMOVED***
      push(***REMOVED*** type: 'text', value ***REMOVED***);
      continue;
***REMOVED***

    /**
     * Commas
     */

    if (value === ',') ***REMOVED***
      let output = value;

      const brace = braces[braces.length - 1];
      if (brace && stack[stack.length - 1] === 'braces') ***REMOVED***
        brace.comma = true;
        output = '|';
  ***REMOVED***

      push(***REMOVED*** type: 'comma', value, output ***REMOVED***);
      continue;
***REMOVED***

    /**
     * Slashes
     */

    if (value === '/') ***REMOVED***
      // if the beginning of the glob is "./", advance the start
      // to the current index, and don't add the "./" characters
      // to the state. This greatly simplifies lookbehinds when
      // checking for BOS characters like "!" and "." (not "./")
      if (prev.type === 'dot' && state.index === state.start + 1) ***REMOVED***
        state.start = state.index + 1;
        state.consumed = '';
        state.output = '';
        tokens.pop();
        prev = bos; // reset "prev" to the first token
        continue;
  ***REMOVED***

      push(***REMOVED*** type: 'slash', value, output: SLASH_LITERAL ***REMOVED***);
      continue;
***REMOVED***

    /**
     * Dots
     */

    if (value === '.') ***REMOVED***
      if (state.braces > 0 && prev.type === 'dot') ***REMOVED***
        if (prev.value === '.') prev.output = DOT_LITERAL;
        const brace = braces[braces.length - 1];
        prev.type = 'dots';
        prev.output += value;
        prev.value += value;
        brace.dots = true;
        continue;
  ***REMOVED***

      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') ***REMOVED***
        push(***REMOVED*** type: 'text', value, output: DOT_LITERAL ***REMOVED***);
        continue;
  ***REMOVED***

      push(***REMOVED*** type: 'dot', value, output: DOT_LITERAL ***REMOVED***);
      continue;
***REMOVED***

    /**
     * Question marks
     */

    if (value === '?') ***REMOVED***
      const isGroup = prev && prev.value === '(';
      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') ***REMOVED***
        extglobOpen('qmark', value);
        continue;
  ***REMOVED***

      if (prev && prev.type === 'paren') ***REMOVED***
        const next = peek();
        let output = value;

        if (next === '<' && !utils.supportsLookbehinds()) ***REMOVED***
          throw new Error('Node.js v10 or higher is required for regex lookbehinds');
    ***REMOVED***

        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\w+>)/.test(remaining()))) ***REMOVED***
          output = `\\$***REMOVED***value***REMOVED***`;
    ***REMOVED***

        push(***REMOVED*** type: 'text', value, output ***REMOVED***);
        continue;
  ***REMOVED***

      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) ***REMOVED***
        push(***REMOVED*** type: 'qmark', value, output: QMARK_NO_DOT ***REMOVED***);
        continue;
  ***REMOVED***

      push(***REMOVED*** type: 'qmark', value, output: QMARK ***REMOVED***);
      continue;
***REMOVED***

    /**
     * Exclamation
     */

    if (value === '!') ***REMOVED***
      if (opts.noextglob !== true && peek() === '(') ***REMOVED***
        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) ***REMOVED***
          extglobOpen('negate', value);
          continue;
    ***REMOVED***
  ***REMOVED***

      if (opts.nonegate !== true && state.index === 0) ***REMOVED***
        negate();
        continue;
  ***REMOVED***
***REMOVED***

    /**
     * Plus
     */

    if (value === '+') ***REMOVED***
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') ***REMOVED***
        extglobOpen('plus', value);
        continue;
  ***REMOVED***

      if ((prev && prev.value === '(') || opts.regex === false) ***REMOVED***
        push(***REMOVED*** type: 'plus', value, output: PLUS_LITERAL ***REMOVED***);
        continue;
  ***REMOVED***

      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) ***REMOVED***
        push(***REMOVED*** type: 'plus', value ***REMOVED***);
        continue;
  ***REMOVED***

      push(***REMOVED*** type: 'plus', value: PLUS_LITERAL ***REMOVED***);
      continue;
***REMOVED***

    /**
     * Plain text
     */

    if (value === '@') ***REMOVED***
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') ***REMOVED***
        push(***REMOVED*** type: 'at', extglob: true, value, output: '' ***REMOVED***);
        continue;
  ***REMOVED***

      push(***REMOVED*** type: 'text', value ***REMOVED***);
      continue;
***REMOVED***

    /**
     * Plain text
     */

    if (value !== '*') ***REMOVED***
      if (value === '$' || value === '^') ***REMOVED***
        value = `\\$***REMOVED***value***REMOVED***`;
  ***REMOVED***

      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
      if (match) ***REMOVED***
        value += match[0];
        state.index += match[0].length;
  ***REMOVED***

      push(***REMOVED*** type: 'text', value ***REMOVED***);
      continue;
***REMOVED***

    /**
     * Stars
     */

    if (prev && (prev.type === 'globstar' || prev.star === true)) ***REMOVED***
      prev.type = 'star';
      prev.star = true;
      prev.value += value;
      prev.output = star;
      state.backtrack = true;
      state.globstar = true;
      consume(value);
      continue;
***REMOVED***

    let rest = remaining();
    if (opts.noextglob !== true && /^\([^?]/.test(rest)) ***REMOVED***
      extglobOpen('star', value);
      continue;
***REMOVED***

    if (prev.type === 'star') ***REMOVED***
      if (opts.noglobstar === true) ***REMOVED***
        consume(value);
        continue;
  ***REMOVED***

      const prior = prev.prev;
      const before = prior.prev;
      const isStart = prior.type === 'slash' || prior.type === 'bos';
      const afterStar = before && (before.type === 'star' || before.type === 'globstar');

      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) ***REMOVED***
        push(***REMOVED*** type: 'star', value, output: '' ***REMOVED***);
        continue;
  ***REMOVED***

      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) ***REMOVED***
        push(***REMOVED*** type: 'star', value, output: '' ***REMOVED***);
        continue;
  ***REMOVED***

      // strip consecutive `/**/`
      while (rest.slice(0, 3) === '/**') ***REMOVED***
        const after = input[state.index + 4];
        if (after && after !== '/') ***REMOVED***
          break;
    ***REMOVED***
        rest = rest.slice(3);
        consume('/**', 3);
  ***REMOVED***

      if (prior.type === 'bos' && eos()) ***REMOVED***
        prev.type = 'globstar';
        prev.value += value;
        prev.output = globstar(opts);
        state.output = prev.output;
        state.globstar = true;
        consume(value);
        continue;
  ***REMOVED***

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) ***REMOVED***
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:$***REMOVED***prior.output***REMOVED***`;

        prev.type = 'globstar';
        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
        prev.value += value;
        state.globstar = true;
        state.output += prior.output + prev.output;
        consume(value);
        continue;
  ***REMOVED***

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') ***REMOVED***
        const end = rest[1] !== void 0 ? '|$' : '';

        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:$***REMOVED***prior.output***REMOVED***`;

        prev.type = 'globstar';
        prev.output = `$***REMOVED***globstar(opts)***REMOVED***$***REMOVED***SLASH_LITERAL***REMOVED***|$***REMOVED***SLASH_LITERAL***REMOVED***$***REMOVED***end***REMOVED***)`;
        prev.value += value;

        state.output += prior.output + prev.output;
        state.globstar = true;

        consume(value + advance());

        push(***REMOVED*** type: 'slash', value: '/', output: '' ***REMOVED***);
        continue;
  ***REMOVED***

      if (prior.type === 'bos' && rest[0] === '/') ***REMOVED***
        prev.type = 'globstar';
        prev.value += value;
        prev.output = `(?:^|$***REMOVED***SLASH_LITERAL***REMOVED***|$***REMOVED***globstar(opts)***REMOVED***$***REMOVED***SLASH_LITERAL***REMOVED***)`;
        state.output = prev.output;
        state.globstar = true;
        consume(value + advance());
        push(***REMOVED*** type: 'slash', value: '/', output: '' ***REMOVED***);
        continue;
  ***REMOVED***

      // remove single star from output
      state.output = state.output.slice(0, -prev.output.length);

      // reset previous token to globstar
      prev.type = 'globstar';
      prev.output = globstar(opts);
      prev.value += value;

      // reset output with globstar
      state.output += prev.output;
      state.globstar = true;
      consume(value);
      continue;
***REMOVED***

    const token = ***REMOVED*** type: 'star', value, output: star ***REMOVED***;

    if (opts.bash === true) ***REMOVED***
      token.output = '.*?';
      if (prev.type === 'bos' || prev.type === 'slash') ***REMOVED***
        token.output = nodot + token.output;
  ***REMOVED***
      push(token);
      continue;
***REMOVED***

    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) ***REMOVED***
      token.output = value;
      push(token);
      continue;
***REMOVED***

    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') ***REMOVED***
      if (prev.type === 'dot') ***REMOVED***
        state.output += NO_DOT_SLASH;
        prev.output += NO_DOT_SLASH;

  ***REMOVED*** else if (opts.dot === true) ***REMOVED***
        state.output += NO_DOTS_SLASH;
        prev.output += NO_DOTS_SLASH;

  ***REMOVED*** else ***REMOVED***
        state.output += nodot;
        prev.output += nodot;
  ***REMOVED***

      if (peek() !== '*') ***REMOVED***
        state.output += ONE_CHAR;
        prev.output += ONE_CHAR;
  ***REMOVED***
***REMOVED***

    push(token);
***REMOVED***

  while (state.brackets > 0) ***REMOVED***
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
    state.output = utils.escapeLast(state.output, '[');
    decrement('brackets');
***REMOVED***

  while (state.parens > 0) ***REMOVED***
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
    state.output = utils.escapeLast(state.output, '(');
    decrement('parens');
***REMOVED***

  while (state.braces > 0) ***REMOVED***
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '***REMOVED***'));
    state.output = utils.escapeLast(state.output, '***REMOVED***');
    decrement('braces');
***REMOVED***

  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) ***REMOVED***
    push(***REMOVED*** type: 'maybe_slash', value: '', output: `$***REMOVED***SLASH_LITERAL***REMOVED***?` ***REMOVED***);
***REMOVED***

  // rebuild the output if we had to backtrack at any point
  if (state.backtrack === true) ***REMOVED***
    state.output = '';

    for (const token of state.tokens) ***REMOVED***
      state.output += token.output != null ? token.output : token.value;

      if (token.suffix) ***REMOVED***
        state.output += token.suffix;
  ***REMOVED***
***REMOVED***
***REMOVED***

  return state;
***REMOVED***;

/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */

parse.fastpaths = (input, options) => ***REMOVED***
  const opts = ***REMOVED*** ...options ***REMOVED***;
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  const len = input.length;
  if (len > max) ***REMOVED***
    throw new SyntaxError(`Input length: $***REMOVED***len***REMOVED***, exceeds maximum allowed length: $***REMOVED***max***REMOVED***`);
***REMOVED***

  input = REPLACEMENTS[input] || input;
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const ***REMOVED***
    DOT_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOTS_SLASH,
    STAR,
    START_ANCHOR
***REMOVED*** = constants.globChars(win32);

  const nodot = opts.dot ? NO_DOTS : NO_DOT;
  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
  const capture = opts.capture ? '' : '?:';
  const state = ***REMOVED*** negated: false, prefix: '' ***REMOVED***;
  let star = opts.bash === true ? '.*?' : STAR;

  if (opts.capture) ***REMOVED***
    star = `($***REMOVED***star***REMOVED***)`;
***REMOVED***

  const globstar = opts => ***REMOVED***
    if (opts.noglobstar === true) return star;
    return `($***REMOVED***capture***REMOVED***(?:(?!$***REMOVED***START_ANCHOR***REMOVED***$***REMOVED***opts.dot ? DOTS_SLASH : DOT_LITERAL***REMOVED***).)*?)`;
***REMOVED***;

  const create = str => ***REMOVED***
    switch (str) ***REMOVED***
      case '*':
        return `$***REMOVED***nodot***REMOVED***$***REMOVED***ONE_CHAR***REMOVED***$***REMOVED***star***REMOVED***`;

      case '.*':
        return `$***REMOVED***DOT_LITERAL***REMOVED***$***REMOVED***ONE_CHAR***REMOVED***$***REMOVED***star***REMOVED***`;

      case '*.*':
        return `$***REMOVED***nodot***REMOVED***$***REMOVED***star***REMOVED***$***REMOVED***DOT_LITERAL***REMOVED***$***REMOVED***ONE_CHAR***REMOVED***$***REMOVED***star***REMOVED***`;

      case '*/*':
        return `$***REMOVED***nodot***REMOVED***$***REMOVED***star***REMOVED***$***REMOVED***SLASH_LITERAL***REMOVED***$***REMOVED***ONE_CHAR***REMOVED***$***REMOVED***slashDot***REMOVED***$***REMOVED***star***REMOVED***`;

      case '**':
        return nodot + globstar(opts);

      case '**/*':
        return `(?:$***REMOVED***nodot***REMOVED***$***REMOVED***globstar(opts)***REMOVED***$***REMOVED***SLASH_LITERAL***REMOVED***)?$***REMOVED***slashDot***REMOVED***$***REMOVED***ONE_CHAR***REMOVED***$***REMOVED***star***REMOVED***`;

      case '**/*.*':
        return `(?:$***REMOVED***nodot***REMOVED***$***REMOVED***globstar(opts)***REMOVED***$***REMOVED***SLASH_LITERAL***REMOVED***)?$***REMOVED***slashDot***REMOVED***$***REMOVED***star***REMOVED***$***REMOVED***DOT_LITERAL***REMOVED***$***REMOVED***ONE_CHAR***REMOVED***$***REMOVED***star***REMOVED***`;

      case '**/.*':
        return `(?:$***REMOVED***nodot***REMOVED***$***REMOVED***globstar(opts)***REMOVED***$***REMOVED***SLASH_LITERAL***REMOVED***)?$***REMOVED***DOT_LITERAL***REMOVED***$***REMOVED***ONE_CHAR***REMOVED***$***REMOVED***star***REMOVED***`;

      default: ***REMOVED***
        const match = /^(.*?)\.(\w+)$/.exec(str);
        if (!match) return;

        const source = create(match[1]);
        if (!source) return;

        return source + DOT_LITERAL + match[2];
  ***REMOVED***
***REMOVED***
***REMOVED***;

  const output = utils.removePrefix(input, state);
  let source = create(output);

  if (source && opts.strictSlashes !== true) ***REMOVED***
    source += `$***REMOVED***SLASH_LITERAL***REMOVED***?`;
***REMOVED***

  return source;
***REMOVED***;

module.exports = parse;
