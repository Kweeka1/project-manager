#!/usr/bin/env node
"use strict";
var _indexJs = require("../peers/index.js");
var _chokidar = _interopRequireDefault(require("chokidar"));
var _path = _interopRequireDefault(require("path"));
var _arg = _interopRequireDefault(require("arg"));
var _fs = _interopRequireDefault(require("fs"));
var _postcssLoadConfig = _interopRequireDefault(require("postcss-load-config"));
var _lilconfig = require("lilconfig");
var _plugins // Little bit scary, looking at private/internal API
 = _interopRequireDefault(require("postcss-load-config/src/plugins"));
var _processTailwindFeatures = _interopRequireDefault(require("./processTailwindFeatures"));
var _resolveConfig = _interopRequireDefault(require("../resolveConfig"));
var _fastGlob = _interopRequireDefault(require("fast-glob"));
var _getModuleDependencies = _interopRequireDefault(require("./lib/getModuleDependencies"));
var _log = _interopRequireDefault(require("./util/log"));
var _packageJson = _interopRequireDefault(require("../package.json"));
var _normalizePath = _interopRequireDefault(require("normalize-path"));
function _interopRequireDefault(obj) ***REMOVED***
    return obj && obj.__esModule ? obj : ***REMOVED***
        default: obj
***REMOVED***;
***REMOVED***
let env = ***REMOVED***
    DEBUG: process.env.DEBUG !== undefined && process.env.DEBUG !== "0"
***REMOVED***;
// ---
function indentRecursive(node, indent = 0) ***REMOVED***
    node.each && node.each((child, i)=>***REMOVED***
        if (!child.raws.before || !child.raws.before.trim() || child.raws.before.includes("\n")) ***REMOVED***
            child.raws.before = `\n$***REMOVED***node.type !== "rule" && i > 0 ? "\n" : ""***REMOVED***$***REMOVED***"  ".repeat(indent)***REMOVED***`;
    ***REMOVED***
        child.raws.after = `\n$***REMOVED***"  ".repeat(indent)***REMOVED***`;
        indentRecursive(child, indent + 1);
***REMOVED***);
***REMOVED***
function formatNodes(root) ***REMOVED***
    indentRecursive(root);
    if (root.first) ***REMOVED***
        root.first.raws.before = "";
***REMOVED***
***REMOVED***
async function outputFile(file, contents) ***REMOVED***
    if (_fs.default.existsSync(file) && await _fs.default.promises.readFile(file, "utf8") === contents) ***REMOVED***
        return; // Skip writing the file
***REMOVED***
    // Write the file
    await _fs.default.promises.writeFile(file, contents, "utf8");
***REMOVED***
function drainStdin() ***REMOVED***
    return new Promise((resolve, reject)=>***REMOVED***
        let result = "";
        process.stdin.on("data", (chunk)=>***REMOVED***
            result += chunk;
    ***REMOVED***);
        process.stdin.on("end", ()=>resolve(result)
        );
        process.stdin.on("error", (err)=>reject(err)
        );
***REMOVED***);
***REMOVED***
function help(***REMOVED*** message , usage , commands: commands1 , options***REMOVED***) ***REMOVED***
    let indent = 2;
    // Render header
    console.log();
    console.log(`$***REMOVED***_packageJson.default.name***REMOVED*** v$***REMOVED***_packageJson.default.version***REMOVED***`);
    // Render message
    if (message) ***REMOVED***
        console.log();
        for (let msg of message.split("\n"))***REMOVED***
            console.log(msg);
    ***REMOVED***
***REMOVED***
    // Render usage
    if (usage && usage.length > 0) ***REMOVED***
        console.log();
        console.log("Usage:");
        for (let example of usage)***REMOVED***
            console.log(" ".repeat(indent), example);
    ***REMOVED***
***REMOVED***
    // Render commands
    if (commands1 && commands1.length > 0) ***REMOVED***
        console.log();
        console.log("Commands:");
        for (let command1 of commands1)***REMOVED***
            console.log(" ".repeat(indent), command1);
    ***REMOVED***
***REMOVED***
    // Render options
    if (options) ***REMOVED***
        let groupedOptions = ***REMOVED******REMOVED***;
        for (let [key, value] of Object.entries(options))***REMOVED***
            if (typeof value === "object") ***REMOVED***
                groupedOptions[key] = ***REMOVED***
                    ...value,
                    flags: [
                        key
                    ]
            ***REMOVED***;
        ***REMOVED*** else ***REMOVED***
                groupedOptions[value].flags.push(key);
        ***REMOVED***
    ***REMOVED***
        console.log();
        console.log("Options:");
        for (let ***REMOVED*** flags: flags1 , description , deprecated***REMOVED*** of Object.values(groupedOptions))***REMOVED***
            if (deprecated) continue;
            if (flags1.length === 1) ***REMOVED***
                console.log(" ".repeat(indent + 4 /* 4 = "-i, ".length */ ), flags1.slice().reverse().join(", ").padEnd(20, " "), description);
        ***REMOVED*** else ***REMOVED***
                console.log(" ".repeat(indent), flags1.slice().reverse().join(", ").padEnd(24, " "), description);
        ***REMOVED***
    ***REMOVED***
***REMOVED***
    console.log();
***REMOVED***
function oneOf(...options) ***REMOVED***
    return Object.assign((value = true)=>***REMOVED***
        for (let option of options)***REMOVED***
            let parsed = option(value);
            if (parsed === value) ***REMOVED***
                return parsed;
        ***REMOVED***
    ***REMOVED***
        throw new Error("...");
***REMOVED***, ***REMOVED***
        manualParsing: true
***REMOVED***);
***REMOVED***
let commands = ***REMOVED***
    init: ***REMOVED***
        run: init,
        args: ***REMOVED***
            "--full": ***REMOVED***
                type: Boolean,
                description: "Initialize a full `tailwind.config.js` file"
        ***REMOVED***,
            "--postcss": ***REMOVED***
                type: Boolean,
                description: "Initialize a `postcss.config.js` file"
        ***REMOVED***,
            "--types": ***REMOVED***
                type: Boolean,
                description: "Add TypeScript types for the `tailwind.config.js` file"
        ***REMOVED***,
            "-f": "--full",
            "-p": "--postcss"
    ***REMOVED***
***REMOVED***,
    build: ***REMOVED***
        run: build,
        args: ***REMOVED***
            "--input": ***REMOVED***
                type: String,
                description: "Input file"
        ***REMOVED***,
            "--output": ***REMOVED***
                type: String,
                description: "Output file"
        ***REMOVED***,
            "--watch": ***REMOVED***
                type: Boolean,
                description: "Watch for changes and rebuild as needed"
        ***REMOVED***,
            /*
      '--poll': ***REMOVED***
        type: Boolean,
        description: 'Use polling instead of filesystem events when watching',
  ***REMOVED***,
      */ "--content": ***REMOVED***
                type: String,
                description: "Content paths to use for removing unused classes"
        ***REMOVED***,
            "--purge": ***REMOVED***
                type: String,
                deprecated: true
        ***REMOVED***,
            "--postcss": ***REMOVED***
                type: oneOf(String, Boolean),
                description: "Load custom PostCSS configuration"
        ***REMOVED***,
            "--minify": ***REMOVED***
                type: Boolean,
                description: "Minify the output"
        ***REMOVED***,
            "--config": ***REMOVED***
                type: String,
                description: "Path to a custom config file"
        ***REMOVED***,
            "--no-autoprefixer": ***REMOVED***
                type: Boolean,
                description: "Disable autoprefixer"
        ***REMOVED***,
            "-c": "--config",
            "-i": "--input",
            "-o": "--output",
            "-m": "--minify",
            "-w": "--watch"
    ***REMOVED***
***REMOVED***
***REMOVED***;
let sharedFlags = ***REMOVED***
    "--help": ***REMOVED***
        type: Boolean,
        description: "Display usage information"
***REMOVED***,
    "-h": "--help"
***REMOVED***;
if (process.stdout.isTTY /* Detect redirecting output to a file */  && (process.argv[2] === undefined || process.argv.slice(2).every((flag)=>sharedFlags[flag] !== undefined
))) ***REMOVED***
    help(***REMOVED***
        usage: [
            "tailwindcss [--input input.css] [--output output.css] [--watch] [options...]",
            "tailwindcss init [--full] [--postcss] [--types] [options...]", 
        ],
        commands: Object.keys(commands).filter((command2)=>command2 !== "build"
        ).map((command3)=>`$***REMOVED***command3***REMOVED*** [options]`
        ),
        options: ***REMOVED***
            ...commands.build.args,
            ...sharedFlags
    ***REMOVED***
***REMOVED***);
    process.exit(0);
***REMOVED***
let command = ((arg = "")=>arg.startsWith("-") ? undefined : arg
)(process.argv[2]) || "build";
if (commands[command] === undefined) ***REMOVED***
    if (_fs.default.existsSync(_path.default.resolve(command))) ***REMOVED***
        // TODO: Deprecate this in future versions
        // Check if non-existing command, might be a file.
        command = "build";
***REMOVED*** else ***REMOVED***
        help(***REMOVED***
            message: `Invalid command: $***REMOVED***command***REMOVED***`,
            usage: [
                "tailwindcss <command> [options]"
            ],
            commands: Object.keys(commands).filter((command4)=>command4 !== "build"
            ).map((command5)=>`$***REMOVED***command5***REMOVED*** [options]`
            ),
            options: sharedFlags
    ***REMOVED***);
        process.exit(1);
***REMOVED***
***REMOVED***
// Execute command
let ***REMOVED*** args: flags , run***REMOVED*** = commands[command];
let args = (()=>***REMOVED***
    try ***REMOVED***
        let result = (0, _arg).default(Object.fromEntries(Object.entries(***REMOVED***
            ...flags,
            ...sharedFlags
    ***REMOVED***).filter(([_key, value])=>***REMOVED***
            var ref;
            return !(value === null || value === void 0 ? void 0 : (ref = value.type) === null || ref === void 0 ? void 0 : ref.manualParsing);
    ***REMOVED***).map(([key, value])=>[
                key,
                typeof value === "object" ? value.type : value
            ]
        )), ***REMOVED***
            permissive: true
    ***REMOVED***);
        // Manual parsing of flags to allow for special flags like oneOf(Boolean, String)
        for(let i = result["_"].length - 1; i >= 0; --i)***REMOVED***
            let flag = result["_"][i];
            if (!flag.startsWith("-")) continue;
            let flagName = flag;
            let handler = flags[flag];
            // Resolve flagName & handler
            while(typeof handler === "string")***REMOVED***
                flagName = handler;
                handler = flags[handler];
        ***REMOVED***
            if (!handler) continue;
            let args1 = [];
            let offset = i + 1;
            // Parse args for current flag
            while(result["_"][offset] && !result["_"][offset].startsWith("-"))***REMOVED***
                args1.push(result["_"][offset++]);
        ***REMOVED***
            // Cleanup manually parsed flags + args
            result["_"].splice(i, 1 + args1.length);
            // Set the resolved value in the `result` object
            result[flagName] = handler.type(args1.length === 0 ? undefined : args1.length === 1 ? args1[0] : args1, flagName);
    ***REMOVED***
        // Ensure that the `command` is always the first argument in the `args`.
        // This is important so that we don't have to check if a default command
        // (build) was used or not from within each plugin.
        //
        // E.g.: tailwindcss input.css -> _: ['build', 'input.css']
        // E.g.: tailwindcss build input.css -> _: ['build', 'input.css']
        if (result["_"][0] !== command) ***REMOVED***
            result["_"].unshift(command);
    ***REMOVED***
        return result;
***REMOVED*** catch (err) ***REMOVED***
        if (err.code === "ARG_UNKNOWN_OPTION") ***REMOVED***
            help(***REMOVED***
                message: err.message,
                usage: [
                    "tailwindcss <command> [options]"
                ],
                options: sharedFlags
        ***REMOVED***);
            process.exit(1);
    ***REMOVED***
        throw err;
***REMOVED***
***REMOVED***)();
if (args["--help"]) ***REMOVED***
    help(***REMOVED***
        options: ***REMOVED***
            ...flags,
            ...sharedFlags
    ***REMOVED***,
        usage: [
            `tailwindcss $***REMOVED***command***REMOVED*** [options]`
        ]
***REMOVED***);
    process.exit(0);
***REMOVED***
run();
// ---
function init() ***REMOVED***
    let messages = [];
    var ref;
    let tailwindConfigLocation = _path.default.resolve((ref = args["_"][1]) !== null && ref !== void 0 ? ref : "./tailwind.config.js");
    if (_fs.default.existsSync(tailwindConfigLocation)) ***REMOVED***
        messages.push(`$***REMOVED***_path.default.basename(tailwindConfigLocation)***REMOVED*** already exists.`);
***REMOVED*** else ***REMOVED***
        let stubFile = _fs.default.readFileSync(args["--full"] ? _path.default.resolve(__dirname, "../stubs/defaultConfig.stub.js") : _path.default.resolve(__dirname, "../stubs/simpleConfig.stub.js"), "utf8");
        if (args["--types"]) ***REMOVED***
            let typesHeading = "/** @type ***REMOVED***import('tailwindcss/types').Config***REMOVED*** */";
            stubFile = stubFile.replace(`module.exports = `, `$***REMOVED***typesHeading***REMOVED***\nconst config = `) + "\nmodule.exports = config";
    ***REMOVED***
        // Change colors import
        stubFile = stubFile.replace("../colors", "tailwindcss/colors");
        _fs.default.writeFileSync(tailwindConfigLocation, stubFile, "utf8");
        messages.push(`Created Tailwind CSS config file: $***REMOVED***_path.default.basename(tailwindConfigLocation)***REMOVED***`);
***REMOVED***
    if (args["--postcss"]) ***REMOVED***
        let postcssConfigLocation = _path.default.resolve("./postcss.config.js");
        if (_fs.default.existsSync(postcssConfigLocation)) ***REMOVED***
            messages.push(`$***REMOVED***_path.default.basename(postcssConfigLocation)***REMOVED*** already exists.`);
    ***REMOVED*** else ***REMOVED***
            let stubFile = _fs.default.readFileSync(_path.default.resolve(__dirname, "../stubs/defaultPostCssConfig.stub.js"), "utf8");
            _fs.default.writeFileSync(postcssConfigLocation, stubFile, "utf8");
            messages.push(`Created PostCSS config file: $***REMOVED***_path.default.basename(postcssConfigLocation)***REMOVED***`);
    ***REMOVED***
***REMOVED***
    if (messages.length > 0) ***REMOVED***
        console.log();
        for (let message of messages)***REMOVED***
            console.log(message);
    ***REMOVED***
***REMOVED***
***REMOVED***
async function build() ***REMOVED***
    let input = args["--input"];
    let output = args["--output"];
    let shouldWatch = args["--watch"];
    let shouldPoll = false;
    /*
  let shouldPoll = args['--poll']
  */ let shouldCoalesceWriteEvents = shouldPoll || process.platform === "win32";
    let includePostCss = args["--postcss"];
    // Polling interval in milliseconds
    // Used only when polling or coalescing add/change events on Windows
    let pollInterval = 10;
    // TODO: Deprecate this in future versions
    if (!input && args["_"][1]) ***REMOVED***
        console.error("[deprecation] Running tailwindcss without -i, please provide an input file.");
        input = args["--input"] = args["_"][1];
***REMOVED***
    if (input && input !== "-" && !_fs.default.existsSync(input = _path.default.resolve(input))) ***REMOVED***
        console.error(`Specified input file $***REMOVED***args["--input"]***REMOVED*** does not exist.`);
        process.exit(9);
***REMOVED***
    if (args["--config"] && !_fs.default.existsSync(args["--config"] = _path.default.resolve(args["--config"]))) ***REMOVED***
        console.error(`Specified config file $***REMOVED***args["--config"]***REMOVED*** does not exist.`);
        process.exit(9);
***REMOVED***
    let configPath = args["--config"] ? args["--config"] : ((defaultPath)=>_fs.default.existsSync(defaultPath) ? defaultPath : null
    )(_path.default.resolve("./tailwind.config.js"));
    async function loadPostCssPlugins() ***REMOVED***
        let customPostCssPath = typeof args["--postcss"] === "string" ? args["--postcss"] : undefined;
        let ***REMOVED*** plugins: configPlugins***REMOVED*** = customPostCssPath ? await (async ()=>***REMOVED***
            let file = _path.default.resolve(customPostCssPath);
            // Implementation, see: https://unpkg.com/browse/postcss-load-config@3.1.0/src/index.js
            let ***REMOVED*** config =***REMOVED******REMOVED******REMOVED*** = await (0, _lilconfig).lilconfig("postcss").load(file);
            if (typeof config === "function") ***REMOVED***
                config = config();
        ***REMOVED*** else ***REMOVED***
                config = Object.assign(***REMOVED******REMOVED***, config);
        ***REMOVED***
            if (!config.plugins) ***REMOVED***
                config.plugins = [];
        ***REMOVED***
            return ***REMOVED***
                plugins: (0, _plugins).default(config, file)
        ***REMOVED***;
    ***REMOVED***)() : await (0, _postcssLoadConfig).default();
        let configPluginTailwindIdx = configPlugins.findIndex((plugin)=>***REMOVED***
            if (typeof plugin === "function" && plugin.name === "tailwindcss") ***REMOVED***
                return true;
        ***REMOVED***
            if (typeof plugin === "object" && plugin !== null && plugin.postcssPlugin === "tailwindcss") ***REMOVED***
                return true;
        ***REMOVED***
            return false;
    ***REMOVED***);
        let beforePlugins = configPluginTailwindIdx === -1 ? [] : configPlugins.slice(0, configPluginTailwindIdx);
        let afterPlugins = configPluginTailwindIdx === -1 ? configPlugins : configPlugins.slice(configPluginTailwindIdx + 1);
        return [
            beforePlugins,
            afterPlugins
        ];
***REMOVED***
    function resolveConfig() ***REMOVED***
        let config = configPath ? require(configPath) : ***REMOVED******REMOVED***;
        if (args["--purge"]) ***REMOVED***
            _log.default.warn("purge-flag-deprecated", [
                "The `--purge` flag has been deprecated.",
                "Please use `--content` instead.", 
            ]);
            if (!args["--content"]) ***REMOVED***
                args["--content"] = args["--purge"];
        ***REMOVED***
    ***REMOVED***
        if (args["--content"]) ***REMOVED***
            let files = args["--content"].split(/(?<!***REMOVED***[^***REMOVED***]+),/);
            let resolvedConfig = (0, _resolveConfig).default(config, ***REMOVED***
                content: ***REMOVED***
                    files
            ***REMOVED***
        ***REMOVED***);
            resolvedConfig.content.files = files;
            return resolvedConfig;
    ***REMOVED***
        return (0, _resolveConfig).default(config);
***REMOVED***
    function extractFileGlobs(config) ***REMOVED***
        return config.content.files.filter((file)=>***REMOVED***
            // Strings in this case are files / globs. If it is something else,
            // like an object it's probably a raw content object. But this object
            // is not watchable, so let's remove it.
            return typeof file === "string";
    ***REMOVED***).map((glob)=>(0, _normalizePath).default(glob)
        );
***REMOVED***
    function extractRawContent(config) ***REMOVED***
        return config.content.files.filter((file)=>***REMOVED***
            return typeof file === "object" && file !== null;
    ***REMOVED***);
***REMOVED***
    function getChangedContent(config) ***REMOVED***
        let changedContent = [];
        // Resolve globs from the content config
        let globs = extractFileGlobs(config);
        let files = _fastGlob.default.sync(globs);
        for (let file of files)***REMOVED***
            changedContent.push(***REMOVED***
                content: _fs.default.readFileSync(_path.default.resolve(file), "utf8"),
                extension: _path.default.extname(file).slice(1)
        ***REMOVED***);
    ***REMOVED***
        // Resolve raw content in the tailwind config
        for (let ***REMOVED*** raw: content , extension ="html"***REMOVED*** of extractRawContent(config))***REMOVED***
            changedContent.push(***REMOVED***
                content,
                extension
        ***REMOVED***);
    ***REMOVED***
        return changedContent;
***REMOVED***
    async function buildOnce() ***REMOVED***
        let config = resolveConfig();
        let changedContent = getChangedContent(config);
        let tailwindPlugin = ()=>***REMOVED***
            return ***REMOVED***
                postcssPlugin: "tailwindcss",
                Once (root, ***REMOVED*** result***REMOVED***) ***REMOVED***
                    (0, _processTailwindFeatures).default((***REMOVED*** createContext***REMOVED***)=>***REMOVED***
                        return ()=>***REMOVED***
                            return createContext(config, changedContent);
                    ***REMOVED***;
                ***REMOVED***)(root, result);
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***;
        tailwindPlugin.postcss = true;
        let [beforePlugins, afterPlugins] = includePostCss ? await loadPostCssPlugins() : [
            [],
            []
        ];
        let plugins = [
            ...beforePlugins,
            tailwindPlugin,
            !args["--minify"] && formatNodes,
            ...afterPlugins,
            !args["--no-autoprefixer"] && (()=>***REMOVED***
                // Try to load a local `autoprefixer` version first
                try ***REMOVED***
                    return require("autoprefixer");
            ***REMOVED*** catch  ***REMOVED******REMOVED***
                return (0, _indexJs).lazyAutoprefixer();
        ***REMOVED***)(),
            args["--minify"] && (()=>***REMOVED***
                let options = ***REMOVED***
                    preset: [
                        "default",
                        ***REMOVED***
                            cssDeclarationSorter: false
                    ***REMOVED***
                    ]
            ***REMOVED***;
                // Try to load a local `cssnano` version first
                try ***REMOVED***
                    return require("cssnano");
            ***REMOVED*** catch  ***REMOVED******REMOVED***
                return (0, _indexJs).lazyCssnano()(options);
        ***REMOVED***)(), 
        ].filter(Boolean);
        let processor = (0, _indexJs).postcss(plugins);
        function processCSS(css) ***REMOVED***
            let start = process.hrtime.bigint();
            return Promise.resolve().then(()=>output ? _fs.default.promises.mkdir(_path.default.dirname(output), ***REMOVED***
                    recursive: true
            ***REMOVED***) : null
            ).then(()=>processor.process(css, ***REMOVED***
                    from: input,
                    to: output
            ***REMOVED***)
            ).then((result)=>***REMOVED***
                if (!output) ***REMOVED***
                    return process.stdout.write(result.css);
            ***REMOVED***
                return Promise.all([
                    outputFile(output, result.css),
                    result.map && outputFile(output + ".map", result.map.toString()), 
                ].filter(Boolean));
        ***REMOVED***).then(()=>***REMOVED***
                let end = process.hrtime.bigint();
                console.error();
                console.error("Done in", (end - start) / BigInt(1000000) + "ms.");
        ***REMOVED***);
    ***REMOVED***
        let css1 = await (()=>***REMOVED***
            // Piping in data, let's drain the stdin
            if (input === "-") ***REMOVED***
                return drainStdin();
        ***REMOVED***
            // Input file has been provided
            if (input) ***REMOVED***
                return _fs.default.readFileSync(_path.default.resolve(input), "utf8");
        ***REMOVED***
            // No input file provided, fallback to default atrules
            return "@tailwind base; @tailwind components; @tailwind utilities";
    ***REMOVED***)();
        return processCSS(css1);
***REMOVED***
    let context = null;
    async function startWatcher() ***REMOVED***
        let changedContent = [];
        let configDependencies = [];
        let contextDependencies = new Set();
        let watcher = null;
        function refreshConfig() ***REMOVED***
            env.DEBUG && console.time("Module dependencies");
            for (let file1 of configDependencies)***REMOVED***
                delete require.cache[require.resolve(file1)];
        ***REMOVED***
            if (configPath) ***REMOVED***
                configDependencies = (0, _getModuleDependencies).default(configPath).map((***REMOVED*** file***REMOVED***)=>file
                );
                for (let dependency of configDependencies)***REMOVED***
                    contextDependencies.add(dependency);
            ***REMOVED***
        ***REMOVED***
            env.DEBUG && console.timeEnd("Module dependencies");
            return resolveConfig();
    ***REMOVED***
        let [beforePlugins, afterPlugins] = includePostCss ? await loadPostCssPlugins() : [
            [],
            []
        ];
        let plugins = [
            ...beforePlugins,
            "__TAILWIND_PLUGIN_POSITION__",
            !args["--minify"] && formatNodes,
            ...afterPlugins,
            !args["--no-autoprefixer"] && (()=>***REMOVED***
                // Try to load a local `autoprefixer` version first
                try ***REMOVED***
                    return require("autoprefixer");
            ***REMOVED*** catch  ***REMOVED******REMOVED***
                return (0, _indexJs).lazyAutoprefixer();
        ***REMOVED***)(),
            args["--minify"] && (()=>***REMOVED***
                let options = ***REMOVED***
                    preset: [
                        "default",
                        ***REMOVED***
                            cssDeclarationSorter: false
                    ***REMOVED***
                    ]
            ***REMOVED***;
                // Try to load a local `cssnano` version first
                try ***REMOVED***
                    return require("cssnano");
            ***REMOVED*** catch  ***REMOVED******REMOVED***
                return (0, _indexJs).lazyCssnano()(options);
        ***REMOVED***)(), 
        ].filter(Boolean);
        async function rebuild(config) ***REMOVED***
            env.DEBUG && console.time("Finished in");
            let tailwindPlugin = ()=>***REMOVED***
                return ***REMOVED***
                    postcssPlugin: "tailwindcss",
                    Once (root, ***REMOVED*** result***REMOVED***) ***REMOVED***
                        env.DEBUG && console.time("Compiling CSS");
                        (0, _processTailwindFeatures).default((***REMOVED*** createContext***REMOVED***)=>***REMOVED***
                            console.error();
                            console.error("Rebuilding...");
                            return ()=>***REMOVED***
                                if (context !== null) ***REMOVED***
                                    context.changedContent = changedContent.splice(0);
                                    return context;
                            ***REMOVED***
                                env.DEBUG && console.time("Creating context");
                                context = createContext(config, changedContent.splice(0));
                                env.DEBUG && console.timeEnd("Creating context");
                                return context;
                        ***REMOVED***;
                    ***REMOVED***)(root, result);
                        env.DEBUG && console.timeEnd("Compiling CSS");
                ***REMOVED***
            ***REMOVED***;
        ***REMOVED***;
            tailwindPlugin.postcss = true;
            let tailwindPluginIdx = plugins.indexOf("__TAILWIND_PLUGIN_POSITION__");
            let copy = plugins.slice();
            copy.splice(tailwindPluginIdx, 1, tailwindPlugin);
            let processor = (0, _indexJs).postcss(copy);
            function processCSS(css) ***REMOVED***
                let start = process.hrtime.bigint();
                return Promise.resolve().then(()=>output ? _fs.default.promises.mkdir(_path.default.dirname(output), ***REMOVED***
                        recursive: true
                ***REMOVED***) : null
                ).then(()=>processor.process(css, ***REMOVED***
                        from: input,
                        to: output
                ***REMOVED***)
                ).then(async (result)=>***REMOVED***
                    for (let message of result.messages)***REMOVED***
                        if (message.type === "dependency") ***REMOVED***
                            contextDependencies.add(message.file);
                    ***REMOVED***
                ***REMOVED***
                    watcher.add([
                        ...contextDependencies
                    ]);
                    if (!output) ***REMOVED***
                        return process.stdout.write(result.css);
                ***REMOVED***
                    return Promise.all([
                        outputFile(output, result.css),
                        result.map && outputFile(output + ".map", result.map.toString()), 
                    ].filter(Boolean));
            ***REMOVED***).then(()=>***REMOVED***
                    let end = process.hrtime.bigint();
                    console.error("Done in", (end - start) / BigInt(1000000) + "ms.");
            ***REMOVED***).catch((err)=>***REMOVED***
                    if (err.name === "CssSyntaxError") ***REMOVED***
                        console.error(err.toString());
                ***REMOVED*** else ***REMOVED***
                        console.error(err);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***
            let css2 = await (()=>***REMOVED***
                // Piping in data, let's drain the stdin
                if (input === "-") ***REMOVED***
                    return drainStdin();
            ***REMOVED***
                // Input file has been provided
                if (input) ***REMOVED***
                    return _fs.default.readFileSync(_path.default.resolve(input), "utf8");
            ***REMOVED***
                // No input file provided, fallback to default atrules
                return "@tailwind base; @tailwind components; @tailwind utilities";
        ***REMOVED***)();
            let result1 = await processCSS(css2);
            env.DEBUG && console.timeEnd("Finished in");
            return result1;
    ***REMOVED***
        let config1 = refreshConfig(configPath);
        if (input) ***REMOVED***
            contextDependencies.add(_path.default.resolve(input));
    ***REMOVED***
        watcher = _chokidar.default.watch([
            ...contextDependencies,
            ...extractFileGlobs(config1)
        ], ***REMOVED***
            usePolling: shouldPoll,
            interval: shouldPoll ? pollInterval : undefined,
            ignoreInitial: true,
            awaitWriteFinish: shouldCoalesceWriteEvents ? ***REMOVED***
                stabilityThreshold: 50,
                pollInterval: pollInterval
        ***REMOVED*** : false
    ***REMOVED***);
        let chain = Promise.resolve();
        watcher.on("change", async (file)=>***REMOVED***
            if (contextDependencies.has(file)) ***REMOVED***
                env.DEBUG && console.time("Resolve config");
                context = null;
                config1 = refreshConfig(configPath);
                env.DEBUG && console.timeEnd("Resolve config");
                env.DEBUG && console.time("Watch new files");
                let globs = extractFileGlobs(config1);
                watcher.add(configDependencies);
                watcher.add(globs);
                env.DEBUG && console.timeEnd("Watch new files");
                chain = chain.then(async ()=>***REMOVED***
                    changedContent.push(...getChangedContent(config1));
                    await rebuild(config1);
            ***REMOVED***);
        ***REMOVED*** else ***REMOVED***
                chain = chain.then(async ()=>***REMOVED***
                    changedContent.push(***REMOVED***
                        content: _fs.default.readFileSync(_path.default.resolve(file), "utf8"),
                        extension: _path.default.extname(file).slice(1)
                ***REMOVED***);
                    await rebuild(config1);
            ***REMOVED***);
        ***REMOVED***
    ***REMOVED***);
        watcher.on("add", async (file)=>***REMOVED***
            chain = chain.then(async ()=>***REMOVED***
                changedContent.push(***REMOVED***
                    content: _fs.default.readFileSync(_path.default.resolve(file), "utf8"),
                    extension: _path.default.extname(file).slice(1)
            ***REMOVED***);
                await rebuild(config1);
        ***REMOVED***);
    ***REMOVED***);
        chain = chain.then(()=>***REMOVED***
            changedContent.push(...getChangedContent(config1));
            return rebuild(config1);
    ***REMOVED***);
***REMOVED***
    if (shouldWatch) ***REMOVED***
        /* Abort the watcher if stdin is closed to avoid zombie processes */ process.stdin.on("end", ()=>process.exit(0)
        );
        process.stdin.resume();
        startWatcher();
***REMOVED*** else ***REMOVED***
        buildOnce();
***REMOVED***
***REMOVED***
