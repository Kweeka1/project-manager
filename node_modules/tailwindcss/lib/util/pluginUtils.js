"use strict";
Object.defineProperty(exports, "__esModule", ***REMOVED***
    value: true
***REMOVED***);
exports.updateAllClasses = updateAllClasses;
exports.asValue = asValue;
exports.asColor = asColor;
exports.asLookupValue = asLookupValue;
exports.coerceValue = coerceValue;
var _postcssSelectorParser = _interopRequireDefault(require("postcss-selector-parser"));
var _escapeCommas = _interopRequireDefault(require("./escapeCommas"));
var _withAlphaVariable = require("./withAlphaVariable");
var _dataTypes = require("./dataTypes");
var _negateValue = _interopRequireDefault(require("./negateValue"));
function _interopRequireDefault(obj) ***REMOVED***
    return obj && obj.__esModule ? obj : ***REMOVED***
        default: obj
***REMOVED***;
***REMOVED***
function updateAllClasses(selectors1, updateClass) ***REMOVED***
    let parser = (0, _postcssSelectorParser).default((selectors)=>***REMOVED***
        selectors.walkClasses((sel)=>***REMOVED***
            let updatedClass = updateClass(sel.value);
            sel.value = updatedClass;
            if (sel.raws && sel.raws.value) ***REMOVED***
                sel.raws.value = (0, _escapeCommas).default(sel.raws.value);
        ***REMOVED***
    ***REMOVED***);
***REMOVED***);
    let result = parser.processSync(selectors1);
    return result;
***REMOVED***
function resolveArbitraryValue(modifier, validate) ***REMOVED***
    if (!isArbitraryValue(modifier)) ***REMOVED***
        return undefined;
***REMOVED***
    let value = modifier.slice(1, -1);
    if (!validate(value)) ***REMOVED***
        return undefined;
***REMOVED***
    return (0, _dataTypes).normalize(value);
***REMOVED***
function asNegativeValue(modifier, lookup = ***REMOVED******REMOVED***, validate) ***REMOVED***
    let positiveValue = lookup[modifier];
    if (positiveValue !== undefined) ***REMOVED***
        return (0, _negateValue).default(positiveValue);
***REMOVED***
    if (isArbitraryValue(modifier)) ***REMOVED***
        let resolved = resolveArbitraryValue(modifier, validate);
        if (resolved === undefined) ***REMOVED***
            return undefined;
    ***REMOVED***
        return (0, _negateValue).default(resolved);
***REMOVED***
***REMOVED***
function asValue(modifier, options = ***REMOVED******REMOVED***, ***REMOVED*** validate =()=>true
***REMOVED*** = ***REMOVED******REMOVED***) ***REMOVED***
    var ref;
    let value = (ref = options.values) === null || ref === void 0 ? void 0 : ref[modifier];
    if (value !== undefined) ***REMOVED***
        return value;
***REMOVED***
    if (options.supportsNegativeValues && modifier.startsWith("-")) ***REMOVED***
        return asNegativeValue(modifier.slice(1), options.values, validate);
***REMOVED***
    return resolveArbitraryValue(modifier, validate);
***REMOVED***
function isArbitraryValue(input) ***REMOVED***
    return input.startsWith("[") && input.endsWith("]");
***REMOVED***
function splitAlpha(modifier) ***REMOVED***
    let slashIdx = modifier.lastIndexOf("/");
    if (slashIdx === -1 || slashIdx === modifier.length - 1) ***REMOVED***
        return [
            modifier
        ];
***REMOVED***
    return [
        modifier.slice(0, slashIdx),
        modifier.slice(slashIdx + 1)
    ];
***REMOVED***
function asColor(modifier, options = ***REMOVED******REMOVED***, ***REMOVED*** tailwindConfig =***REMOVED******REMOVED******REMOVED*** = ***REMOVED******REMOVED***) ***REMOVED***
    var ref;
    if (((ref = options.values) === null || ref === void 0 ? void 0 : ref[modifier]) !== undefined) ***REMOVED***
        var ref1;
        return (ref1 = options.values) === null || ref1 === void 0 ? void 0 : ref1[modifier];
***REMOVED***
    let [color, alpha] = splitAlpha(modifier);
    if (alpha !== undefined) ***REMOVED***
        var ref2, ref3, ref4;
        var ref5;
        let normalizedColor = (ref5 = (ref2 = options.values) === null || ref2 === void 0 ? void 0 : ref2[color]) !== null && ref5 !== void 0 ? ref5 : isArbitraryValue(color) ? color.slice(1, -1) : undefined;
        if (normalizedColor === undefined) ***REMOVED***
            return undefined;
    ***REMOVED***
        if (isArbitraryValue(alpha)) ***REMOVED***
            return (0, _withAlphaVariable).withAlphaValue(normalizedColor, alpha.slice(1, -1));
    ***REMOVED***
        if (((ref3 = tailwindConfig.theme) === null || ref3 === void 0 ? void 0 : (ref4 = ref3.opacity) === null || ref4 === void 0 ? void 0 : ref4[alpha]) === undefined) ***REMOVED***
            return undefined;
    ***REMOVED***
        return (0, _withAlphaVariable).withAlphaValue(normalizedColor, tailwindConfig.theme.opacity[alpha]);
***REMOVED***
    return asValue(modifier, options, ***REMOVED***
        validate: _dataTypes.color
***REMOVED***);
***REMOVED***
function asLookupValue(modifier, options = ***REMOVED******REMOVED***) ***REMOVED***
    var ref;
    return (ref = options.values) === null || ref === void 0 ? void 0 : ref[modifier];
***REMOVED***
function guess(validate) ***REMOVED***
    return (modifier, options)=>***REMOVED***
        return asValue(modifier, options, ***REMOVED***
            validate
    ***REMOVED***);
***REMOVED***;
***REMOVED***
let typeMap = ***REMOVED***
    any: asValue,
    color: asColor,
    url: guess(_dataTypes.url),
    image: guess(_dataTypes.image),
    length: guess(_dataTypes.length),
    percentage: guess(_dataTypes.percentage),
    position: guess(_dataTypes.position),
    lookup: asLookupValue,
    "generic-name": guess(_dataTypes.genericName),
    "family-name": guess(_dataTypes.familyName),
    number: guess(_dataTypes.number),
    "line-width": guess(_dataTypes.lineWidth),
    "absolute-size": guess(_dataTypes.absoluteSize),
    "relative-size": guess(_dataTypes.relativeSize),
    shadow: guess(_dataTypes.shadow)
***REMOVED***;
let supportedTypes = Object.keys(typeMap);
function splitAtFirst(input, delim) ***REMOVED***
    let idx = input.indexOf(delim);
    if (idx === -1) return [
        undefined,
        input
    ];
    return [
        input.slice(0, idx),
        input.slice(idx + 1)
    ];
***REMOVED***
function coerceValue(types, modifier, options, tailwindConfig) ***REMOVED***
    if (isArbitraryValue(modifier)) ***REMOVED***
        let arbitraryValue = modifier.slice(1, -1);
        let [explicitType, value] = splitAtFirst(arbitraryValue, ":");
        // It could be that this resolves to `url(https` which is not a valid
        // identifier. We currently only support "simple" words with dashes or
        // underscores. E.g.: family-name
        if (!/^[\w-_]+$/g.test(explicitType)) ***REMOVED***
            value = arbitraryValue;
    ***REMOVED*** else if (explicitType !== undefined && !supportedTypes.includes(explicitType)) ***REMOVED***
            return [];
    ***REMOVED***
        if (value.length > 0 && supportedTypes.includes(explicitType)) ***REMOVED***
            return [
                asValue(`[$***REMOVED***value***REMOVED***]`, options),
                explicitType
            ];
    ***REMOVED***
***REMOVED***
    // Find first matching type
    for (let type of [].concat(types))***REMOVED***
        let result = typeMap[type](modifier, options, ***REMOVED***
            tailwindConfig
    ***REMOVED***);
        if (result !== undefined) return [
            result,
            type
        ];
***REMOVED***
    return [];
***REMOVED***
