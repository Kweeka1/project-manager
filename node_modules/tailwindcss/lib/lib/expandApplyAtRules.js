"use strict";
Object.defineProperty(exports, "__esModule", ***REMOVED***
    value: true
***REMOVED***);
exports.default = expandApplyAtRules;
var _postcss = _interopRequireDefault(require("postcss"));
var _postcssSelectorParser = _interopRequireDefault(require("postcss-selector-parser"));
var _generateRules = require("./generateRules");
var _bigSign = _interopRequireDefault(require("../util/bigSign"));
var _escapeClassName = _interopRequireDefault(require("../util/escapeClassName"));
function expandApplyAtRules(context) ***REMOVED***
    return (root)=>***REMOVED***
        // Build a cache of the user's CSS so we can use it to resolve classes used by @apply
        let localCache = lazyCache(()=>buildLocalApplyCache(root, context)
        );
        processApply(root, context, localCache);
***REMOVED***;
***REMOVED***
function _interopRequireDefault(obj) ***REMOVED***
    return obj && obj.__esModule ? obj : ***REMOVED***
        default: obj
***REMOVED***;
***REMOVED***
/** @typedef ***REMOVED***Map<string, [any, import('postcss').Rule[]]>***REMOVED*** ApplyCache */ function extractClasses(node) ***REMOVED***
    let classes = new Set();
    let container = _postcss.default.root(***REMOVED***
        nodes: [
            node.clone()
        ]
***REMOVED***);
    container.walkRules((rule)=>***REMOVED***
        (0, _postcssSelectorParser).default((selectors)=>***REMOVED***
            selectors.walkClasses((classSelector)=>***REMOVED***
                classes.add(classSelector.value);
        ***REMOVED***);
    ***REMOVED***).processSync(rule.selector);
***REMOVED***);
    return Array.from(classes);
***REMOVED***
function extractBaseCandidates(candidates, separator) ***REMOVED***
    let baseClasses = new Set();
    for (let candidate of candidates)***REMOVED***
        baseClasses.add(candidate.split(separator).pop());
***REMOVED***
    return Array.from(baseClasses);
***REMOVED***
function prefix(context, selector) ***REMOVED***
    let prefix1 = context.tailwindConfig.prefix;
    return typeof prefix1 === "function" ? prefix1(selector) : prefix1 + selector;
***REMOVED***
function* pathToRoot(node) ***REMOVED***
    yield node;
    while(node.parent)***REMOVED***
        yield node.parent;
        node = node.parent;
***REMOVED***
***REMOVED***
/**
 * Only clone the node itself and not its children
 *
 * @param ***REMOVED*******REMOVED*** node
 * @param ***REMOVED*******REMOVED*** overrides
 * @returns
 */ function shallowClone(node, overrides = ***REMOVED******REMOVED***) ***REMOVED***
    let children = node.nodes;
    node.nodes = [];
    let tmp = node.clone(overrides);
    node.nodes = children;
    return tmp;
***REMOVED***
/**
 * Clone just the nodes all the way to the top that are required to represent
 * this singular rule in the tree.
 *
 * For example, if we have CSS like this:
 * ```css
 * @media (min-width: 768px) ***REMOVED***
 *   @supports (display: grid) ***REMOVED***
 *     .foo ***REMOVED***
 *       display: grid;
 *       grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
 * ***REMOVED***
 * ***REMOVED***
 *
 *   @supports (backdrop-filter: blur(1px)) ***REMOVED***
 *     .bar ***REMOVED***
 *       backdrop-filter: blur(1px);
 * ***REMOVED***
 * ***REMOVED***
 *
 *   .baz ***REMOVED***
 *     color: orange;
 * ***REMOVED***
 * ***REMOVED***
 * ```
 *
 * And we're cloning `.bar` it'll return a cloned version of what's required for just that single node:
 *
 * ```css
 * @media (min-width: 768px) ***REMOVED***
 *   @supports (backdrop-filter: blur(1px)) ***REMOVED***
 *     .bar ***REMOVED***
 *       backdrop-filter: blur(1px);
 * ***REMOVED***
 * ***REMOVED***
 * ***REMOVED***
 * ```
 *
 * @param ***REMOVED***import('postcss').Node***REMOVED*** node
 */ function nestedClone(node) ***REMOVED***
    for (let parent of pathToRoot(node))***REMOVED***
        if (node === parent) ***REMOVED***
            continue;
    ***REMOVED***
        if (parent.type === "root") ***REMOVED***
            break;
    ***REMOVED***
        node = shallowClone(parent, ***REMOVED***
            nodes: [
                node
            ]
    ***REMOVED***);
***REMOVED***
    return node;
***REMOVED***
/**
 * @param ***REMOVED***import('postcss').Root***REMOVED*** root
 */ function buildLocalApplyCache(root, context) ***REMOVED***
    /** @type ***REMOVED***ApplyCache***REMOVED*** */ let cache = new Map();
    let highestOffset = context.layerOrder.user >> 4n;
    root.walkRules((rule, idx)=>***REMOVED***
        // Ignore rules generated by Tailwind
        for (let node of pathToRoot(rule))***REMOVED***
            var ref;
            if (((ref = node.raws.tailwind) === null || ref === void 0 ? void 0 : ref.layer) !== undefined) ***REMOVED***
                return;
        ***REMOVED***
    ***REMOVED***
        // Clone what's required to represent this singular rule in the tree
        let container = nestedClone(rule);
        for (let className of extractClasses(rule))***REMOVED***
            let list = cache.get(className) || [];
            cache.set(className, list);
            list.push([
                ***REMOVED***
                    layer: "user",
                    sort: BigInt(idx) + highestOffset,
                    important: false
            ***REMOVED***,
                container, 
            ]);
    ***REMOVED***
***REMOVED***);
    return cache;
***REMOVED***
/**
 * @returns ***REMOVED***ApplyCache***REMOVED***
 */ function buildApplyCache(applyCandidates, context) ***REMOVED***
    for (let candidate of applyCandidates)***REMOVED***
        if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) ***REMOVED***
            continue;
    ***REMOVED***
        if (context.classCache.has(candidate)) ***REMOVED***
            context.applyClassCache.set(candidate, context.classCache.get(candidate).map(([meta, rule])=>[
                    meta,
                    rule.clone()
                ]
            ));
            continue;
    ***REMOVED***
        let matches = Array.from((0, _generateRules).resolveMatches(candidate, context));
        if (matches.length === 0) ***REMOVED***
            context.notClassCache.add(candidate);
            continue;
    ***REMOVED***
        context.applyClassCache.set(candidate, matches);
***REMOVED***
    return context.applyClassCache;
***REMOVED***
/**
 * Build a cache only when it's first used
 *
 * @param ***REMOVED***() => ApplyCache***REMOVED*** buildCacheFn
 * @returns ***REMOVED***ApplyCache***REMOVED***
 */ function lazyCache(buildCacheFn) ***REMOVED***
    let cache = null;
    return ***REMOVED***
        get: (name)=>***REMOVED***
            cache = cache || buildCacheFn();
            return cache.get(name);
    ***REMOVED***,
        has: (name)=>***REMOVED***
            cache = cache || buildCacheFn();
            return cache.has(name);
    ***REMOVED***
***REMOVED***;
***REMOVED***
/**
 * Take a series of multiple caches and merge
 * them so they act like one large cache
 *
 * @param ***REMOVED***ApplyCache[]***REMOVED*** caches
 * @returns ***REMOVED***ApplyCache***REMOVED***
 */ function combineCaches(caches) ***REMOVED***
    return ***REMOVED***
        get: (name)=>caches.flatMap((cache)=>cache.get(name) || []
            )
        ,
        has: (name)=>caches.some((cache)=>cache.has(name)
            )
***REMOVED***;
***REMOVED***
function extractApplyCandidates(params) ***REMOVED***
    let candidates = params.split(/[\s\t\n]+/g);
    if (candidates[candidates.length - 1] === "!important") ***REMOVED***
        return [
            candidates.slice(0, -1),
            true
        ];
***REMOVED***
    return [
        candidates,
        false
    ];
***REMOVED***
function processApply(root, context, localCache) ***REMOVED***
    let applyCandidates = new Set();
    // Collect all @apply rules and candidates
    let applies = [];
    root.walkAtRules("apply", (rule)=>***REMOVED***
        let [candidates] = extractApplyCandidates(rule.params);
        for (let util of candidates)***REMOVED***
            applyCandidates.add(util);
    ***REMOVED***
        applies.push(rule);
***REMOVED***);
    // Start the @apply process if we have rules with @apply in them
    if (applies.length > 0) ***REMOVED***
        // Fill up some caches!
        let applyClassCache = combineCaches([
            localCache,
            buildApplyCache(applyCandidates, context)
        ]);
        /**
     * When we have an apply like this:
     *
     * .abc ***REMOVED***
     *    @apply hover:font-bold;
     * ***REMOVED***
     *
     * What we essentially will do is resolve to this:
     *
     * .abc ***REMOVED***
     *    @apply .hover\:font-bold:hover ***REMOVED***
     *      font-weight: 500;
     ****REMOVED***
     * ***REMOVED***
     *
     * Notice that the to-be-applied class is `.hover\:font-bold:hover` and that the utility candidate was `hover:font-bold`.
     * What happens in this function is that we prepend a `.` and escape the candidate.
     * This will result in `.hover\:font-bold`
     * Which means that we can replace `.hover\:font-bold` with `.abc` in `.hover\:font-bold:hover` resulting in `.abc:hover`
     */ // TODO: Should we use postcss-selector-parser for this instead?
        function replaceSelector(selector, utilitySelectors, candidate) ***REMOVED***
            let needle = `.$***REMOVED***(0, _escapeClassName).default(candidate)***REMOVED***`;
            let utilitySelectorsList = utilitySelectors.split(/\s*\,(?![^(]*\))\s*/g);
            return selector.split(/\s*\,(?![^(]*\))\s*/g).map((s)=>***REMOVED***
                let replaced = [];
                for (let utilitySelector of utilitySelectorsList)***REMOVED***
                    let replacedSelector = utilitySelector.replace(needle, s);
                    if (replacedSelector === utilitySelector) ***REMOVED***
                        continue;
                ***REMOVED***
                    replaced.push(replacedSelector);
            ***REMOVED***
                return replaced.join(", ");
        ***REMOVED***).join(", ");
    ***REMOVED***
        let perParentApplies = new Map();
        // Collect all apply candidates and their rules
        for (let apply of applies)***REMOVED***
            let candidates = perParentApplies.get(apply.parent) || [];
            perParentApplies.set(apply.parent, [
                candidates,
                apply.source
            ]);
            let [applyCandidates, important] = extractApplyCandidates(apply.params);
            if (apply.parent.type === "atrule") ***REMOVED***
                if (apply.parent.name === "screen") ***REMOVED***
                    const screenType = apply.parent.params;
                    throw apply.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply $***REMOVED***applyCandidates.map((c)=>`$***REMOVED***screenType***REMOVED***:$***REMOVED***c***REMOVED***`
                    ).join(" ")***REMOVED*** instead.`);
            ***REMOVED***
                throw apply.error(`@apply is not supported within nested at-rules like @$***REMOVED***apply.parent.name***REMOVED***. You can fix this by un-nesting @$***REMOVED***apply.parent.name***REMOVED***.`);
        ***REMOVED***
            for (let applyCandidate of applyCandidates)***REMOVED***
                if ([
                    prefix(context, "group"),
                    prefix(context, "peer")
                ].includes(applyCandidate)) ***REMOVED***
                    // TODO: Link to specific documentation page with error code.
                    throw apply.error(`@apply should not be used with the '$***REMOVED***applyCandidate***REMOVED***' utility`);
            ***REMOVED***
                if (!applyClassCache.has(applyCandidate)) ***REMOVED***
                    throw apply.error(`The \`$***REMOVED***applyCandidate***REMOVED***\` class does not exist. If \`$***REMOVED***applyCandidate***REMOVED***\` is a custom class, make sure it is defined within a \`@layer\` directive.`);
            ***REMOVED***
                let rules = applyClassCache.get(applyCandidate);
                candidates.push([
                    applyCandidate,
                    important,
                    rules
                ]);
        ***REMOVED***
    ***REMOVED***
        for (const [parent, [candidates, atApplySource]] of perParentApplies)***REMOVED***
            let siblings = [];
            for (let [applyCandidate, important, rules] of candidates)***REMOVED***
                for (let [meta, node1] of rules)***REMOVED***
                    let parentClasses = extractClasses(parent);
                    let nodeClasses = extractClasses(node1);
                    // Add base utility classes from the @apply node to the list of
                    // classes to check whether it intersects and therefore results in a
                    // circular dependency or not.
                    //
                    // E.g.:
                    // .foo ***REMOVED***
                    //   @apply hover:a; // This applies "a" but with a modifier
                    // ***REMOVED***
                    //
                    // We only have to do that with base classes of the `node`, not of the `parent`
                    // E.g.:
                    // .hover\:foo ***REMOVED***
                    //   @apply bar;
                    // ***REMOVED***
                    // .bar ***REMOVED***
                    //   @apply foo;
                    // ***REMOVED***
                    //
                    // This should not result in a circular dependency because we are
                    // just applying `.foo` and the rule above is `.hover\:foo` which is
                    // unrelated. However, if we were to apply `hover:foo` then we _did_
                    // have to include this one.
                    nodeClasses = nodeClasses.concat(extractBaseCandidates(nodeClasses, context.tailwindConfig.separator));
                    let intersects = parentClasses.some((selector)=>nodeClasses.includes(selector)
                    );
                    if (intersects) ***REMOVED***
                        throw node1.error(`You cannot \`@apply\` the \`$***REMOVED***applyCandidate***REMOVED***\` utility here because it creates a circular dependency.`);
                ***REMOVED***
                    let root = _postcss.default.root(***REMOVED***
                        nodes: [
                            node1.clone()
                        ]
                ***REMOVED***);
                    // Make sure every node in the entire tree points back at the @apply rule that generated it
                    root.walk((node)=>***REMOVED***
                        node.source = atApplySource;
                ***REMOVED***);
                    let canRewriteSelector = node1.type !== "atrule" || node1.type === "atrule" && node1.name !== "keyframes";
                    if (canRewriteSelector) ***REMOVED***
                        root.walkRules((rule)=>***REMOVED***
                            // Let's imagine you have the following structure:
                            //
                            // .foo ***REMOVED***
                            //   @apply bar;
                            // ***REMOVED***
                            //
                            // @supports (a: b) ***REMOVED***
                            //   .bar ***REMOVED***
                            //     color: blue
                            // ***REMOVED***
                            //
                            //   .something-unrelated ***REMOVED******REMOVED***
                            // ***REMOVED***
                            //
                            // In this case we want to apply `.bar` but it happens to be in
                            // an atrule node. We clone that node instead of the nested one
                            // because we still want that @supports rule to be there once we
                            // applied everything.
                            //
                            // However it happens to be that the `.something-unrelated` is
                            // also in that same shared @supports atrule. This is not good,
                            // and this should not be there. The good part is that this is
                            // a clone already and it can be safely removed. The question is
                            // how do we know we can remove it. Basically what we can do is
                            // match it against the applyCandidate that you want to apply. If
                            // it doesn't match the we can safely delete it.
                            //
                            // If we didn't do this, then the `replaceSelector` function
                            // would have replaced this with something that didn't exist and
                            // therefore it removed the selector altogether. In this specific
                            // case it would result in `***REMOVED******REMOVED***` instead of `.something-unrelated ***REMOVED******REMOVED***`
                            if (!extractClasses(rule).some((candidate)=>candidate === applyCandidate
                            )) ***REMOVED***
                                rule.remove();
                                return;
                        ***REMOVED***
                            rule.selector = replaceSelector(parent.selector, rule.selector, applyCandidate);
                            rule.walkDecls((d)=>***REMOVED***
                                d.important = meta.important || important;
                        ***REMOVED***);
                    ***REMOVED***);
                ***REMOVED***
                    // Insert it
                    siblings.push([
                        // Ensure that when we are sorting, that we take the layer order into account
                        ***REMOVED***
                            ...meta,
                            sort: meta.sort | context.layerOrder[meta.layer]
                    ***REMOVED***,
                        root.nodes[0], 
                    ]);
            ***REMOVED***
        ***REMOVED***
            // Inject the rules, sorted, correctly
            let nodes = siblings.sort(([a], [z])=>(0, _bigSign).default(a.sort - z.sort)
            ).map((s)=>s[1]
            );
            // `parent` refers to the node at `.abc` in: .abc ***REMOVED*** @apply mt-2 ***REMOVED***
            parent.after(nodes);
    ***REMOVED***
        for (let apply1 of applies)***REMOVED***
            // If there are left-over declarations, just remove the @apply
            if (apply1.parent.nodes.length > 1) ***REMOVED***
                apply1.remove();
        ***REMOVED*** else ***REMOVED***
                // The node is empty, drop the full node
                apply1.parent.remove();
        ***REMOVED***
    ***REMOVED***
        // Do it again, in case we have other `@apply` rules
        processApply(root, context, localCache);
***REMOVED***
***REMOVED***
