"use strict";
Object.defineProperty(exports, "__esModule", ***REMOVED***
    value: true
***REMOVED***);
exports.default = setupTrackingContext;
var _fs = _interopRequireDefault(require("fs"));
var _path = _interopRequireDefault(require("path"));
var _fastGlob = _interopRequireDefault(require("fast-glob"));
var _quickLru = _interopRequireDefault(require("quick-lru"));
var _normalizePath = _interopRequireDefault(require("normalize-path"));
var _hashConfig = _interopRequireDefault(require("../util/hashConfig"));
var _getModuleDependencies = _interopRequireDefault(require("../lib/getModuleDependencies"));
var _resolveConfig = _interopRequireDefault(require("../public/resolve-config"));
var _resolveConfigPath = _interopRequireDefault(require("../util/resolveConfigPath"));
var _sharedState = require("./sharedState");
var _setupContextUtils = require("./setupContextUtils");
var _parseDependency = _interopRequireDefault(require("../util/parseDependency"));
function setupTrackingContext(configOrPath) ***REMOVED***
    return (***REMOVED*** tailwindDirectives , registerDependency***REMOVED***)=>***REMOVED***
        return (root, result)=>***REMOVED***
            let [tailwindConfig, userConfigPath, tailwindConfigHash, configDependencies] = getTailwindConfig(configOrPath);
            let contextDependencies = new Set(configDependencies);
            // If there are no @tailwind or @apply rules, we don't consider this CSS
            // file or its dependencies to be dependencies of the context. Can reuse
            // the context even if they change. We may want to think about `@layer`
            // being part of this trigger too, but it's tough because it's impossible
            // for a layer in one file to end up in the actual @tailwind rule in
            // another file since independent sources are effectively isolated.
            if (tailwindDirectives.size > 0) ***REMOVED***
                // Add current css file as a context dependencies.
                contextDependencies.add(result.opts.from);
                // Add all css @import dependencies as context dependencies.
                for (let message of result.messages)***REMOVED***
                    if (message.type === "dependency") ***REMOVED***
                        contextDependencies.add(message.file);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
            let [context] = (0, _setupContextUtils).getContext(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies);
            let candidateFiles = getCandidateFiles(context, tailwindConfig);
            // If there are no @tailwind or @apply rules, we don't consider this CSS file or it's
            // dependencies to be dependencies of the context. Can reuse the context even if they change.
            // We may want to think about `@layer` being part of this trigger too, but it's tough
            // because it's impossible for a layer in one file to end up in the actual @tailwind rule
            // in another file since independent sources are effectively isolated.
            if (tailwindDirectives.size > 0) ***REMOVED***
                let fileModifiedMap = (0, _setupContextUtils).getFileModifiedMap(context);
                // Add template paths as postcss dependencies.
                for (let fileOrGlob of candidateFiles)***REMOVED***
                    let dependency = (0, _parseDependency).default(fileOrGlob);
                    if (dependency) ***REMOVED***
                        registerDependency(dependency);
                ***REMOVED***
            ***REMOVED***
                for (let changedContent of resolvedChangedContent(context, candidateFiles, fileModifiedMap))***REMOVED***
                    context.changedContent.push(changedContent);
            ***REMOVED***
        ***REMOVED***
            for (let file of configDependencies)***REMOVED***
                registerDependency(***REMOVED***
                    type: "dependency",
                    file
            ***REMOVED***);
        ***REMOVED***
            return context;
    ***REMOVED***;
***REMOVED***;
***REMOVED***
function _interopRequireDefault(obj) ***REMOVED***
    return obj && obj.__esModule ? obj : ***REMOVED***
        default: obj
***REMOVED***;
***REMOVED***
let configPathCache = new _quickLru.default(***REMOVED***
    maxSize: 100
***REMOVED***);
let candidateFilesCache = new WeakMap();
function getCandidateFiles(context, tailwindConfig) ***REMOVED***
    if (candidateFilesCache.has(context)) ***REMOVED***
        return candidateFilesCache.get(context);
***REMOVED***
    let candidateFiles = tailwindConfig.content.files.filter((item)=>typeof item === "string"
    ).map((contentPath)=>(0, _normalizePath).default(contentPath)
    );
    return candidateFilesCache.set(context, candidateFiles).get(context);
***REMOVED***
// Get the config object based on a path
function getTailwindConfig(configOrPath) ***REMOVED***
    let userConfigPath = (0, _resolveConfigPath).default(configOrPath);
    if (userConfigPath !== null) ***REMOVED***
        let [prevConfig, prevConfigHash, prevDeps, prevModified] = configPathCache.get(userConfigPath) || [];
        let newDeps = (0, _getModuleDependencies).default(userConfigPath).map((dep)=>dep.file
        );
        let modified = false;
        let newModified = new Map();
        for (let file of newDeps)***REMOVED***
            let time = _fs.default.statSync(file).mtimeMs;
            newModified.set(file, time);
            if (!prevModified || !prevModified.has(file) || time > prevModified.get(file)) ***REMOVED***
                modified = true;
        ***REMOVED***
    ***REMOVED***
        // It hasn't changed (based on timestamps)
        if (!modified) ***REMOVED***
            return [
                prevConfig,
                userConfigPath,
                prevConfigHash,
                prevDeps
            ];
    ***REMOVED***
        // It has changed (based on timestamps), or first run
        for (let file1 of newDeps)***REMOVED***
            delete require.cache[file1];
    ***REMOVED***
        let newConfig = (0, _resolveConfig).default(require(userConfigPath));
        let newHash = (0, _hashConfig).default(newConfig);
        configPathCache.set(userConfigPath, [
            newConfig,
            newHash,
            newDeps,
            newModified
        ]);
        return [
            newConfig,
            userConfigPath,
            newHash,
            newDeps
        ];
***REMOVED***
    // It's a plain object, not a path
    let newConfig = (0, _resolveConfig).default(configOrPath.config === undefined ? configOrPath : configOrPath.config);
    return [
        newConfig,
        null,
        (0, _hashConfig).default(newConfig),
        []
    ];
***REMOVED***
function resolvedChangedContent(context, candidateFiles, fileModifiedMap) ***REMOVED***
    let changedContent = context.tailwindConfig.content.files.filter((item)=>typeof item.raw === "string"
    ).map((***REMOVED*** raw , extension ="html"***REMOVED***)=>(***REMOVED***
            content: raw,
            extension
    ***REMOVED***)
    );
    for (let changedFile of resolveChangedFiles(candidateFiles, fileModifiedMap))***REMOVED***
        let content = _fs.default.readFileSync(changedFile, "utf8");
        let extension = _path.default.extname(changedFile).slice(1);
        changedContent.push(***REMOVED***
            content,
            extension
    ***REMOVED***);
***REMOVED***
    return changedContent;
***REMOVED***
function resolveChangedFiles(candidateFiles, fileModifiedMap) ***REMOVED***
    let changedFiles = new Set();
    _sharedState.env.DEBUG && console.time("Finding changed files");
    let files = _fastGlob.default.sync(candidateFiles);
    for (let file of files)***REMOVED***
        let prevModified = fileModifiedMap.has(file) ? fileModifiedMap.get(file) : -Infinity;
        let modified = _fs.default.statSync(file).mtimeMs;
        if (modified > prevModified) ***REMOVED***
            changedFiles.add(file);
            fileModifiedMap.set(file, modified);
    ***REMOVED***
***REMOVED***
    _sharedState.env.DEBUG && console.timeEnd("Finding changed files");
    return changedFiles;
***REMOVED***
