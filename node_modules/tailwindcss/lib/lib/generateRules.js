"use strict";
Object.defineProperty(exports, "__esModule", ***REMOVED***
    value: true
***REMOVED***);
exports.generateRules = exports.resolveMatches = void 0;
var _postcss = _interopRequireDefault(require("postcss"));
var _postcssSelectorParser = _interopRequireDefault(require("postcss-selector-parser"));
var _parseObjectStyles = _interopRequireDefault(require("../util/parseObjectStyles"));
var _isPlainObject = _interopRequireDefault(require("../util/isPlainObject"));
var _prefixSelector = _interopRequireDefault(require("../util/prefixSelector"));
var _pluginUtils = require("../util/pluginUtils");
var _log = _interopRequireDefault(require("../util/log"));
var sharedState = _interopRequireWildcard(require("./sharedState"));
var _formatVariantSelector = require("../util/formatVariantSelector");
var _nameClass = require("../util/nameClass");
var _dataTypes = require("../util/dataTypes");
var _isValidArbitraryValue = _interopRequireDefault(require("../util/isValidArbitraryValue"));
function _interopRequireDefault(obj) ***REMOVED***
    return obj && obj.__esModule ? obj : ***REMOVED***
        default: obj
***REMOVED***;
***REMOVED***
function _interopRequireWildcard(obj) ***REMOVED***
    if (obj && obj.__esModule) ***REMOVED***
        return obj;
***REMOVED*** else ***REMOVED***
        var newObj = ***REMOVED******REMOVED***;
        if (obj != null) ***REMOVED***
            for(var key in obj)***REMOVED***
                if (Object.prototype.hasOwnProperty.call(obj, key)) ***REMOVED***
                    var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : ***REMOVED******REMOVED***;
                    if (desc.get || desc.set) ***REMOVED***
                        Object.defineProperty(newObj, key, desc);
                ***REMOVED*** else ***REMOVED***
                        newObj[key] = obj[key];
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
        newObj.default = obj;
        return newObj;
***REMOVED***
***REMOVED***
let classNameParser = (0, _postcssSelectorParser).default((selectors)=>***REMOVED***
    return selectors.first.filter((***REMOVED*** type***REMOVED***)=>type === "class"
    ).pop().value;
***REMOVED***);
function getClassNameFromSelector(selector) ***REMOVED***
    return classNameParser.transformSync(selector);
***REMOVED***
// Generate match permutations for a class candidate, like:
// ['ring-offset-blue', '100']
// ['ring-offset', 'blue-100']
// ['ring', 'offset-blue-100']
// Example with dynamic classes:
// ['grid-cols', '[[linename],1fr,auto]']
// ['grid', 'cols-[[linename],1fr,auto]']
function* candidatePermutations(candidate) ***REMOVED***
    let lastIndex = Infinity;
    while(lastIndex >= 0)***REMOVED***
        let dashIdx;
        if (lastIndex === Infinity && candidate.endsWith("]")) ***REMOVED***
            let bracketIdx = candidate.indexOf("[");
            // If character before `[` isn't a dash or a slash, this isn't a dynamic class
            // eg. string[]
            dashIdx = [
                "-",
                "/"
            ].includes(candidate[bracketIdx - 1]) ? bracketIdx - 1 : -1;
    ***REMOVED*** else ***REMOVED***
            dashIdx = candidate.lastIndexOf("-", lastIndex);
    ***REMOVED***
        if (dashIdx < 0) ***REMOVED***
            break;
    ***REMOVED***
        let prefix = candidate.slice(0, dashIdx);
        let modifier = candidate.slice(dashIdx + 1);
        yield [
            prefix,
            modifier
        ];
        lastIndex = dashIdx - 1;
***REMOVED***
***REMOVED***
function applyPrefix(matches, context) ***REMOVED***
    if (matches.length === 0 || context.tailwindConfig.prefix === "") ***REMOVED***
        return matches;
***REMOVED***
    for (let match of matches)***REMOVED***
        let [meta] = match;
        if (meta.options.respectPrefix) ***REMOVED***
            let container = _postcss.default.root(***REMOVED***
                nodes: [
                    match[1].clone()
                ]
        ***REMOVED***);
            let classCandidate = match[1].raws.tailwind.classCandidate;
            container.walkRules((r)=>***REMOVED***
                // If this is a negative utility with a dash *before* the prefix we
                // have to ensure that the generated selector matches the candidate
                // Not doing this will cause `-tw-top-1` to generate the class `.tw--top-1`
                // The disconnect between candidate <-> class can cause @apply to hard crash.
                let shouldPrependNegative = classCandidate.startsWith("-");
                r.selector = (0, _prefixSelector).default(context.tailwindConfig.prefix, r.selector, shouldPrependNegative);
        ***REMOVED***);
            match[1] = container.nodes[0];
    ***REMOVED***
***REMOVED***
    return matches;
***REMOVED***
function applyImportant(matches, classCandidate) ***REMOVED***
    if (matches.length === 0) ***REMOVED***
        return matches;
***REMOVED***
    let result = [];
    for (let [meta, rule] of matches)***REMOVED***
        let container = _postcss.default.root(***REMOVED***
            nodes: [
                rule.clone()
            ]
    ***REMOVED***);
        container.walkRules((r)=>***REMOVED***
            r.selector = (0, _pluginUtils).updateAllClasses(r.selector, (className)=>***REMOVED***
                if (className === classCandidate) ***REMOVED***
                    return `!$***REMOVED***className***REMOVED***`;
            ***REMOVED***
                return className;
        ***REMOVED***);
            r.walkDecls((d)=>d.important = true
            );
    ***REMOVED***);
        result.push([
            ***REMOVED***
                ...meta,
                important: true
        ***REMOVED***,
            container.nodes[0]
        ]);
***REMOVED***
    return result;
***REMOVED***
// Takes a list of rule tuples and applies a variant like `hover`, sm`,
// whatever to it. We used to do some extra caching here to avoid generating
// a variant of the same rule more than once, but this was never hit because
// we cache at the entire selector level further up the tree.
//
// Technically you can get a cache hit if you have `hover:focus:text-center`
// and `focus:hover:text-center` in the same project, but it doesn't feel
// worth the complexity for that case.
function applyVariant(variant, matches, context) ***REMOVED***
    if (matches.length === 0) ***REMOVED***
        return matches;
***REMOVED***
    if (context.variantMap.has(variant)) ***REMOVED***
        let variantFunctionTuples = context.variantMap.get(variant);
        let result = [];
        for (let [meta, rule1] of matches)***REMOVED***
            // Don't generate variants for user css
            if (meta.layer === "user") ***REMOVED***
                continue;
        ***REMOVED***
            let container = _postcss.default.root(***REMOVED***
                nodes: [
                    rule1.clone()
                ]
        ***REMOVED***);
            for (let [variantSort, variantFunction] of variantFunctionTuples)***REMOVED***
                let clone = container.clone();
                let collectedFormats = [];
                let originals = new Map();
                function prepareBackup() ***REMOVED***
                    if (originals.size > 0) return; // Already prepared, chicken out
                    clone.walkRules((rule)=>originals.set(rule, rule.selector)
                    );
            ***REMOVED***
                function modifySelectors(modifierFunction) ***REMOVED***
                    prepareBackup();
                    clone.each((rule)=>***REMOVED***
                        if (rule.type !== "rule") ***REMOVED***
                            return;
                    ***REMOVED***
                        rule.selectors = rule.selectors.map((selector)=>***REMOVED***
                            return modifierFunction(***REMOVED***
                                get className () ***REMOVED***
                                    return getClassNameFromSelector(selector);
                            ***REMOVED***,
                                selector
                        ***REMOVED***);
                    ***REMOVED***);
                ***REMOVED***);
                    return clone;
            ***REMOVED***
                let ruleWithVariant = variantFunction(***REMOVED***
                    // Public API
                    get container () ***REMOVED***
                        prepareBackup();
                        return clone;
                ***REMOVED***,
                    separator: context.tailwindConfig.separator,
                    modifySelectors,
                    // Private API for now
                    wrap (wrapper) ***REMOVED***
                        let nodes = clone.nodes;
                        clone.removeAll();
                        wrapper.append(nodes);
                        clone.append(wrapper);
                ***REMOVED***,
                    format (selectorFormat) ***REMOVED***
                        collectedFormats.push(selectorFormat);
                ***REMOVED***
            ***REMOVED***);
                if (typeof ruleWithVariant === "string") ***REMOVED***
                    collectedFormats.push(ruleWithVariant);
            ***REMOVED***
                if (ruleWithVariant === null) ***REMOVED***
                    continue;
            ***REMOVED***
                // We filled the `originals`, therefore we assume that somebody touched
                // `container` or `modifySelectors`. Let's see if they did, so that we
                // can restore the selectors, and collect the format strings.
                if (originals.size > 0) ***REMOVED***
                    clone.walkRules((rule)=>***REMOVED***
                        if (!originals.has(rule)) return;
                        let before = originals.get(rule);
                        if (before === rule.selector) return; // No mutation happened
                        let modified = rule.selector;
                        // Rebuild the base selector, this is what plugin authors would do
                        // as well. E.g.: `$***REMOVED***variant***REMOVED***$***REMOVED***separator***REMOVED***$***REMOVED***className***REMOVED***`.
                        // However, plugin authors probably also prepend or append certain
                        // classes, pseudos, ids, ...
                        let rebuiltBase = (0, _postcssSelectorParser).default((selectors)=>***REMOVED***
                            selectors.walkClasses((classNode)=>***REMOVED***
                                classNode.value = `$***REMOVED***variant***REMOVED***$***REMOVED***context.tailwindConfig.separator***REMOVED***$***REMOVED***classNode.value***REMOVED***`;
                        ***REMOVED***);
                    ***REMOVED***).processSync(before);
                        // Now that we know the original selector, the new selector, and
                        // the rebuild part in between, we can replace the part that plugin
                        // authors need to rebuild with `&`, and eventually store it in the
                        // collectedFormats. Similar to what `format('...')` would do.
                        //
                        // E.g.:
                        //                   variant: foo
                        //                  selector: .markdown > p
                        //      modified (by plugin): .foo .foo\\:markdown > p
                        //    rebuiltBase (internal): .foo\\:markdown > p
                        //                    format: .foo &
                        collectedFormats.push(modified.replace(rebuiltBase, "&"));
                        rule.selector = before;
                ***REMOVED***);
            ***REMOVED***
                // This tracks the originating layer for the variant
                // For example:
                // .sm:underline ***REMOVED******REMOVED*** is a variant of something in the utilities layer
                // .sm:container ***REMOVED******REMOVED*** is a variant of the container component
                clone.nodes[0].raws.tailwind = ***REMOVED***
                    ...clone.nodes[0].raws.tailwind,
                    parentLayer: meta.layer
            ***REMOVED***;
                var _collectedFormats;
                let withOffset = [
                    ***REMOVED***
                        ...meta,
                        sort: variantSort | meta.sort,
                        collectedFormats: ((_collectedFormats = meta.collectedFormats) !== null && _collectedFormats !== void 0 ? _collectedFormats : []).concat(collectedFormats)
                ***REMOVED***,
                    clone.nodes[0], 
                ];
                result.push(withOffset);
        ***REMOVED***
    ***REMOVED***
        return result;
***REMOVED***
    return [];
***REMOVED***
function parseRules(rule, cache, options = ***REMOVED******REMOVED***) ***REMOVED***
    // PostCSS node
    if (!(0, _isPlainObject).default(rule) && !Array.isArray(rule)) ***REMOVED***
        return [
            [
                rule
            ],
            options
        ];
***REMOVED***
    // Tuple
    if (Array.isArray(rule)) ***REMOVED***
        return parseRules(rule[0], cache, rule[1]);
***REMOVED***
    // Simple object
    if (!cache.has(rule)) ***REMOVED***
        cache.set(rule, (0, _parseObjectStyles).default(rule));
***REMOVED***
    return [
        cache.get(rule),
        options
    ];
***REMOVED***
const IS_VALID_PROPERTY_NAME = /^[a-z_-]/;
function isValidPropName(name) ***REMOVED***
    return IS_VALID_PROPERTY_NAME.test(name);
***REMOVED***
/**
 * @param ***REMOVED***string***REMOVED*** declaration
 * @returns ***REMOVED***boolean***REMOVED***
 */ function looksLikeUri(declaration) ***REMOVED***
    // Quick bailout for obvious non-urls
    // This doesn't support schemes that don't use a leading // but that's unlikely to be a problem
    if (!declaration.includes("://")) ***REMOVED***
        return false;
***REMOVED***
    try ***REMOVED***
        const url = new URL(declaration);
        return url.scheme !== "" && url.host !== "";
***REMOVED*** catch (err) ***REMOVED***
        // Definitely not a valid url
        return false;
***REMOVED***
***REMOVED***
function isParsableNode(node) ***REMOVED***
    let isParsable = true;
    node.walkDecls((decl)=>***REMOVED***
        if (!isParsableCssValue(decl.name, decl.value)) ***REMOVED***
            isParsable = false;
            return false;
    ***REMOVED***
***REMOVED***);
    return isParsable;
***REMOVED***
function isParsableCssValue(property, value) ***REMOVED***
    // We don't want to to treat [https://example.com] as a custom property
    // Even though, according to the CSS grammar, it's a totally valid CSS declaration
    // So we short-circuit here by checking if the custom property looks like a url
    if (looksLikeUri(`$***REMOVED***property***REMOVED***:$***REMOVED***value***REMOVED***`)) ***REMOVED***
        return false;
***REMOVED***
    try ***REMOVED***
        _postcss.default.parse(`a***REMOVED***$***REMOVED***property***REMOVED***:$***REMOVED***value***REMOVED******REMOVED***`).toResult();
        return true;
***REMOVED*** catch (err) ***REMOVED***
        return false;
***REMOVED***
***REMOVED***
function extractArbitraryProperty(classCandidate, context) ***REMOVED***
    var ref;
    let [, property, value] = (ref = classCandidate.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/)) !== null && ref !== void 0 ? ref : [];
    if (value === undefined) ***REMOVED***
        return null;
***REMOVED***
    if (!isValidPropName(property)) ***REMOVED***
        return null;
***REMOVED***
    if (!(0, _isValidArbitraryValue).default(value)) ***REMOVED***
        return null;
***REMOVED***
    let normalized = (0, _dataTypes).normalize(value);
    if (!isParsableCssValue(property, normalized)) ***REMOVED***
        return null;
***REMOVED***
    return [
        [
            ***REMOVED***
                sort: context.arbitraryPropertiesSort,
                layer: "utilities"
        ***REMOVED***,
            ()=>(***REMOVED***
                    [(0, _nameClass).asClass(classCandidate)]: ***REMOVED***
                        [property]: normalized
                ***REMOVED***
            ***REMOVED***)
            , 
        ], 
    ];
***REMOVED***
function* resolveMatchedPlugins(classCandidate, context) ***REMOVED***
    if (context.candidateRuleMap.has(classCandidate)) ***REMOVED***
        yield [
            context.candidateRuleMap.get(classCandidate),
            "DEFAULT"
        ];
***REMOVED***
    yield* function*(arbitraryPropertyRule) ***REMOVED***
        if (arbitraryPropertyRule !== null) ***REMOVED***
            yield [
                arbitraryPropertyRule,
                "DEFAULT"
            ];
    ***REMOVED***
***REMOVED***(extractArbitraryProperty(classCandidate, context));
    let candidatePrefix = classCandidate;
    let negative = false;
    const twConfigPrefix = context.tailwindConfig.prefix;
    const twConfigPrefixLen = twConfigPrefix.length;
    if (candidatePrefix[twConfigPrefixLen] === "-") ***REMOVED***
        negative = true;
        candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);
***REMOVED***
    if (negative && context.candidateRuleMap.has(candidatePrefix)) ***REMOVED***
        yield [
            context.candidateRuleMap.get(candidatePrefix),
            "-DEFAULT"
        ];
***REMOVED***
    for (let [prefix, modifier] of candidatePermutations(candidatePrefix))***REMOVED***
        if (context.candidateRuleMap.has(prefix)) ***REMOVED***
            yield [
                context.candidateRuleMap.get(prefix),
                negative ? `-$***REMOVED***modifier***REMOVED***` : modifier
            ];
    ***REMOVED***
***REMOVED***
***REMOVED***
function splitWithSeparator(input, separator) ***REMOVED***
    if (input === sharedState.NOT_ON_DEMAND) ***REMOVED***
        return [
            sharedState.NOT_ON_DEMAND
        ];
***REMOVED***
    return input.split(new RegExp(`\\$***REMOVED***separator***REMOVED***(?![^[]*\\])`, "g"));
***REMOVED***
function* recordCandidates(matches, classCandidate) ***REMOVED***
    for (const match of matches)***REMOVED***
        match[1].raws.tailwind = ***REMOVED***
            ...match[1].raws.tailwind,
            classCandidate
    ***REMOVED***;
        yield match;
***REMOVED***
***REMOVED***
function* resolveMatches(candidate, context) ***REMOVED***
    let separator = context.tailwindConfig.separator;
    let [classCandidate, ...variants] = splitWithSeparator(candidate, separator).reverse();
    let important = false;
    if (classCandidate.startsWith("!")) ***REMOVED***
        important = true;
        classCandidate = classCandidate.slice(1);
***REMOVED***
    // TODO: Reintroduce this in ways that doesn't break on false positives
    // function sortAgainst(toSort, against) ***REMOVED***
    //   return toSort.slice().sort((a, z) => ***REMOVED***
    //     return bigSign(against.get(a)[0] - against.get(z)[0])
    // ***REMOVED***)
    // ***REMOVED***
    // let sorted = sortAgainst(variants, context.variantMap)
    // if (sorted.toString() !== variants.toString()) ***REMOVED***
    //   let corrected = sorted.reverse().concat(classCandidate).join(':')
    //   throw new Error(`Class $***REMOVED***candidate***REMOVED*** should be written as $***REMOVED***corrected***REMOVED***`)
    // ***REMOVED***
    for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context))***REMOVED***
        let matches = [];
        let typesByMatches = new Map();
        let [plugins, modifier] = matchedPlugins;
        let isOnlyPlugin = plugins.length === 1;
        for (let [sort, plugin] of plugins)***REMOVED***
            let matchesPerPlugin = [];
            if (typeof plugin === "function") ***REMOVED***
                for (let ruleSet of [].concat(plugin(modifier, ***REMOVED***
                    isOnlyPlugin
            ***REMOVED***)))***REMOVED***
                    let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);
                    for (let rule of rules)***REMOVED***
                        matchesPerPlugin.push([
                            ***REMOVED***
                                ...sort,
                                options: ***REMOVED***
                                    ...sort.options,
                                    ...options
                            ***REMOVED***
                        ***REMOVED***,
                            rule
                        ]);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED*** else if (modifier === "DEFAULT" || modifier === "-DEFAULT") ***REMOVED***
                let ruleSet = plugin;
                let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);
                for (let rule of rules)***REMOVED***
                    matchesPerPlugin.push([
                        ***REMOVED***
                            ...sort,
                            options: ***REMOVED***
                                ...sort.options,
                                ...options
                        ***REMOVED***
                    ***REMOVED***,
                        rule
                    ]);
            ***REMOVED***
        ***REMOVED***
            if (matchesPerPlugin.length > 0) ***REMOVED***
                var ref;
                typesByMatches.set(matchesPerPlugin, (ref = sort.options) === null || ref === void 0 ? void 0 : ref.type);
                matches.push(matchesPerPlugin);
        ***REMOVED***
    ***REMOVED***
        if (isArbitraryValue(modifier)) ***REMOVED***
            // When generated arbitrary values are ambiguous, we can't know
            // which to pick so don't generate any utilities for them
            if (matches.length > 1) ***REMOVED***
                var ref1;
                let typesPerPlugin = matches.map((match)=>new Set([
                        ...(ref1 = typesByMatches.get(match)) !== null && ref1 !== void 0 ? ref1 : []
                    ])
                );
                // Remove duplicates, so that we can detect proper unique types for each plugin.
                for (let pluginTypes of typesPerPlugin)***REMOVED***
                    for (let type of pluginTypes)***REMOVED***
                        let removeFromOwnGroup = false;
                        for (let otherGroup of typesPerPlugin)***REMOVED***
                            if (pluginTypes === otherGroup) continue;
                            if (otherGroup.has(type)) ***REMOVED***
                                otherGroup.delete(type);
                                removeFromOwnGroup = true;
                        ***REMOVED***
                    ***REMOVED***
                        if (removeFromOwnGroup) pluginTypes.delete(type);
                ***REMOVED***
            ***REMOVED***
                let messages = [];
                for (let [idx, group] of typesPerPlugin.entries())***REMOVED***
                    for (let type of group)***REMOVED***
                        let rules = matches[idx].map(([, rule])=>rule
                        ).flat().map((rule)=>rule.toString().split("\n").slice(1, -1) // Remove selector and closing '***REMOVED***'
                            .map((line)=>line.trim()
                            ).map((x)=>`      $***REMOVED***x***REMOVED***`
                            ) // Re-indent
                            .join("\n")
                        ).join("\n\n");
                        messages.push(`  Use \`$***REMOVED***candidate.replace("[", `[$***REMOVED***type***REMOVED***:`)***REMOVED***\` for \`$***REMOVED***rules.trim()***REMOVED***\``);
                        break;
                ***REMOVED***
            ***REMOVED***
                _log.default.warn([
                    `The class \`$***REMOVED***candidate***REMOVED***\` is ambiguous and matches multiple utilities.`,
                    ...messages,
                    `If this is content and not a class, replace it with \`$***REMOVED***candidate.replace("[", "&lsqb;").replace("]", "&rsqb;")***REMOVED***\` to silence this warning.`, 
                ]);
                continue;
        ***REMOVED***
            matches = matches.map((list)=>list.filter((match)=>isParsableNode(match[1])
                )
            );
    ***REMOVED***
        matches = matches.flat();
        matches = Array.from(recordCandidates(matches, classCandidate));
        matches = applyPrefix(matches, context);
        if (important) ***REMOVED***
            matches = applyImportant(matches, classCandidate);
    ***REMOVED***
        for (let variant of variants)***REMOVED***
            matches = applyVariant(variant, matches, context);
    ***REMOVED***
        for (let match1 of matches)***REMOVED***
            match1[1].raws.tailwind = ***REMOVED***
                ...match1[1].raws.tailwind,
                candidate
        ***REMOVED***;
            // Apply final format selector
            if (match1[0].collectedFormats) ***REMOVED***
                let finalFormat = (0, _formatVariantSelector).formatVariantSelector("&", ...match1[0].collectedFormats);
                let container = _postcss.default.root(***REMOVED***
                    nodes: [
                        match1[1].clone()
                    ]
            ***REMOVED***);
                container.walkRules((rule)=>***REMOVED***
                    if (inKeyframes(rule)) return;
                    rule.selector = (0, _formatVariantSelector).finalizeSelector(finalFormat, ***REMOVED***
                        selector: rule.selector,
                        candidate,
                        context
                ***REMOVED***);
            ***REMOVED***);
                match1[1] = container.nodes[0];
        ***REMOVED***
            yield match1;
    ***REMOVED***
***REMOVED***
***REMOVED***
exports.resolveMatches = resolveMatches;
function inKeyframes(rule) ***REMOVED***
    return rule.parent && rule.parent.type === "atrule" && rule.parent.name === "keyframes";
***REMOVED***
function generateRules(candidates, context) ***REMOVED***
    let allRules = [];
    for (let candidate of candidates)***REMOVED***
        if (context.notClassCache.has(candidate)) ***REMOVED***
            continue;
    ***REMOVED***
        if (context.classCache.has(candidate)) ***REMOVED***
            allRules.push(context.classCache.get(candidate));
            continue;
    ***REMOVED***
        let matches = Array.from(resolveMatches(candidate, context));
        if (matches.length === 0) ***REMOVED***
            context.notClassCache.add(candidate);
            continue;
    ***REMOVED***
        context.classCache.set(candidate, matches);
        allRules.push(matches);
***REMOVED***
    // Strategy based on `tailwindConfig.important`
    let strategy = ((important)=>***REMOVED***
        if (important === true) ***REMOVED***
            return (rule)=>***REMOVED***
                rule.walkDecls((d)=>***REMOVED***
                    if (d.parent.type === "rule" && !inKeyframes(d.parent)) ***REMOVED***
                        d.important = true;
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***;
    ***REMOVED***
        if (typeof important === "string") ***REMOVED***
            return (rule)=>***REMOVED***
                rule.selectors = rule.selectors.map((selector)=>***REMOVED***
                    return `$***REMOVED***important***REMOVED*** $***REMOVED***selector***REMOVED***`;
            ***REMOVED***);
        ***REMOVED***;
    ***REMOVED***
***REMOVED***)(context.tailwindConfig.important);
    return allRules.flat(1).map(([***REMOVED*** sort , layer , options***REMOVED*** rule])=>***REMOVED***
        if (options.respectImportant) ***REMOVED***
            if (strategy) ***REMOVED***
                let container = _postcss.default.root(***REMOVED***
                    nodes: [
                        rule.clone()
                    ]
            ***REMOVED***);
                container.walkRules((r)=>***REMOVED***
                    if (inKeyframes(r)) ***REMOVED***
                        return;
                ***REMOVED***
                    strategy(r);
            ***REMOVED***);
                rule = container.nodes[0];
        ***REMOVED***
    ***REMOVED***
        return [
            sort | context.layerOrder[layer],
            rule
        ];
***REMOVED***);
***REMOVED***
exports.generateRules = generateRules;
function isArbitraryValue(input) ***REMOVED***
    return input.startsWith("[") && input.endsWith("]");
***REMOVED***
