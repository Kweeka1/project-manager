"use strict";
Object.defineProperty(exports, "__esModule", ***REMOVED***
    value: true
***REMOVED***);
exports.default = collapseDuplicateDeclarations;
function collapseDuplicateDeclarations() ***REMOVED***
    return (root)=>***REMOVED***
        root.walkRules((node)=>***REMOVED***
            let seen = new Map();
            let droppable = new Set([]);
            let byProperty = new Map();
            node.walkDecls((decl)=>***REMOVED***
                // This could happen if we have nested selectors. In that case the
                // parent will loop over all its declarations but also the declarations
                // of nested rules. With this we ensure that we are shallowly checking
                // declarations.
                if (decl.parent !== node) ***REMOVED***
                    return;
            ***REMOVED***
                if (seen.has(decl.prop)) ***REMOVED***
                    // Exact same value as what we have seen so far
                    if (seen.get(decl.prop).value === decl.value) ***REMOVED***
                        // Keep the last one, drop the one we've seen so far
                        droppable.add(seen.get(decl.prop));
                        // Override the existing one with the new value. This is necessary
                        // so that if we happen to have more than one declaration with the
                        // same value, that we keep removing the previous one. Otherwise we
                        // will only remove the *first* one.
                        seen.set(decl.prop, decl);
                        return;
                ***REMOVED***
                    // Not the same value, so we need to check if we can merge it so
                    // let's collect it first.
                    if (!byProperty.has(decl.prop)) ***REMOVED***
                        byProperty.set(decl.prop, new Set());
                ***REMOVED***
                    byProperty.get(decl.prop).add(seen.get(decl.prop));
                    byProperty.get(decl.prop).add(decl);
            ***REMOVED***
                seen.set(decl.prop, decl);
        ***REMOVED***);
            // Drop all the duplicate declarations with the exact same value we've
            // already seen so far.
            for (let decl1 of droppable)***REMOVED***
                decl1.remove();
        ***REMOVED***
            // Analyze the declarations based on its unit, drop all the declarations
            // with the same unit but the last one in the list.
            for (let declarations of byProperty.values())***REMOVED***
                let byUnit = new Map();
                for (let decl of declarations)***REMOVED***
                    let unit = resolveUnit(decl.value);
                    if (unit === null) ***REMOVED***
                        continue;
                ***REMOVED***
                    if (!byUnit.has(unit)) ***REMOVED***
                        byUnit.set(unit, new Set());
                ***REMOVED***
                    byUnit.get(unit).add(decl);
            ***REMOVED***
                for (let declarations1 of byUnit.values())***REMOVED***
                    // Get all but the last one
                    let removableDeclarations = Array.from(declarations1).slice(0, -1);
                    for (let decl of removableDeclarations)***REMOVED***
                        decl.remove();
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***);
***REMOVED***;
***REMOVED***
let UNITLESS_NUMBER = Symbol("unitless-number");
function resolveUnit(input) ***REMOVED***
    let result = /^-?\d*.?\d+([\w%]+)?$/g.exec(input);
    if (result) ***REMOVED***
        var ref;
        return (ref = result[1]) !== null && ref !== void 0 ? ref : UNITLESS_NUMBER;
***REMOVED***
    return null;
***REMOVED***
