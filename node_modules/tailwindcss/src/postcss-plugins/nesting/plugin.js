import postcss from 'postcss'
import postcssNested from 'postcss-nested'

export function nesting(opts = postcssNested) ***REMOVED***
  return (root, result) => ***REMOVED***
    root.walkAtRules('screen', (rule) => ***REMOVED***
      rule.name = 'media'
      rule.params = `screen($***REMOVED***rule.params***REMOVED***)`
***REMOVED***)

    root.walkAtRules('apply', (rule) => ***REMOVED***
      rule.before(postcss.decl(***REMOVED*** prop: '__apply', value: rule.params, source: rule.source ***REMOVED***))
      rule.remove()
***REMOVED***)

    let plugin = (() => ***REMOVED***
      if (
        typeof opts === 'function' ||
        (typeof opts === 'object' && opts?.hasOwnProperty?.('postcssPlugin'))
      ) ***REMOVED***
        return opts
  ***REMOVED***

      if (typeof opts === 'string') ***REMOVED***
        return require(opts)
  ***REMOVED***

      if (Object.keys(opts).length <= 0) ***REMOVED***
        return postcssNested
  ***REMOVED***

      throw new Error('tailwindcss/nesting should be loaded with a nesting plugin.')
***REMOVED***)()

    postcss([plugin]).process(root, result.opts).sync()

    root.walkDecls('__apply', (decl) => ***REMOVED***
      decl.before(postcss.atRule(***REMOVED*** name: 'apply', params: decl.value, source: decl.source ***REMOVED***))
      decl.remove()
***REMOVED***)

    /**
     * Use a private PostCSS API to remove the "clean" flag from the entire AST.
     * This is done because running process() on the AST will set the "clean"
     * flag on all nodes, which we don't want.
     *
     * This causes downstream plugins using the visitor API to be skipped.
     *
     * This is guarded because the PostCSS API is not public
     * and may change in future versions of PostCSS.
     *
     * See https://github.com/postcss/postcss/issues/1712 for more details
     *
     * @param ***REMOVED***import('postcss').Node***REMOVED*** node
     */
    function markDirty(node) ***REMOVED***
      if (!('markDirty' in node)) ***REMOVED***
        return
  ***REMOVED***

      // Traverse the tree down to the leaf nodes
      if (node.nodes) ***REMOVED***
        node.nodes.forEach((n) => markDirty(n))
  ***REMOVED***

      // If it's a leaf node mark it as dirty
      // We do this here because marking a node as dirty
      // will walk up the tree and mark all parents as dirty
      // resulting in a lot of unnecessary work if we did this
      // for every single node
      if (!node.nodes) ***REMOVED***
        node.markDirty()
  ***REMOVED***
***REMOVED***

    markDirty(root)

    return root
***REMOVED***
***REMOVED***
