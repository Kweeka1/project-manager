import fs from 'fs'
import url from 'url'
import postcss from 'postcss'
import dlv from 'dlv'
import selectorParser from 'postcss-selector-parser'

import transformThemeValue from '../util/transformThemeValue'
import parseObjectStyles from '../util/parseObjectStyles'
import prefixSelector from '../util/prefixSelector'
import isPlainObject from '../util/isPlainObject'
import escapeClassName from '../util/escapeClassName'
import nameClass, ***REMOVED*** formatClass ***REMOVED*** from '../util/nameClass'
import ***REMOVED*** coerceValue ***REMOVED*** from '../util/pluginUtils'
import bigSign from '../util/bigSign'
import ***REMOVED*** variantPlugins, corePlugins ***REMOVED*** from '../corePlugins'
import * as sharedState from './sharedState'
import ***REMOVED*** env ***REMOVED*** from './sharedState'
import ***REMOVED*** toPath ***REMOVED*** from '../util/toPath'
import log from '../util/log'
import negateValue from '../util/negateValue'
import isValidArbitraryValue from '../util/isValidArbitraryValue'
import ***REMOVED*** generateRules ***REMOVED*** from './generateRules'
import ***REMOVED*** hasContentChanged ***REMOVED*** from './cacheInvalidation.js'

function prefix(context, selector) ***REMOVED***
  let prefix = context.tailwindConfig.prefix
  return typeof prefix === 'function' ? prefix(selector) : prefix + selector
***REMOVED***

function parseVariantFormatString(input) ***REMOVED***
  if (input.includes('***REMOVED***')) ***REMOVED***
    if (!isBalanced(input)) throw new Error(`Your ***REMOVED*** and ***REMOVED*** are unbalanced.`)

    return input
      .split(/***REMOVED***(.*)***REMOVED***/gim)
      .flatMap((line) => parseVariantFormatString(line))
      .filter(Boolean)
***REMOVED***

  return [input.trim()]
***REMOVED***

function isBalanced(input) ***REMOVED***
  let count = 0

  for (let char of input) ***REMOVED***
    if (char === '***REMOVED***') ***REMOVED***
      count++
***REMOVED*** else if (char === '***REMOVED***') ***REMOVED***
      if (--count < 0) ***REMOVED***
        return false // unbalanced
  ***REMOVED***
***REMOVED***
***REMOVED***

  return count === 0
***REMOVED***

function insertInto(list, value, ***REMOVED*** before = [] ***REMOVED*** = ***REMOVED******REMOVED***) ***REMOVED***
  before = [].concat(before)

  if (before.length <= 0) ***REMOVED***
    list.push(value)
    return
***REMOVED***

  let idx = list.length - 1
  for (let other of before) ***REMOVED***
    let iidx = list.indexOf(other)
    if (iidx === -1) continue
    idx = Math.min(idx, iidx)
***REMOVED***

  list.splice(idx, 0, value)
***REMOVED***

function parseStyles(styles) ***REMOVED***
  if (!Array.isArray(styles)) ***REMOVED***
    return parseStyles([styles])
***REMOVED***

  return styles.flatMap((style) => ***REMOVED***
    let isNode = !Array.isArray(style) && !isPlainObject(style)
    return isNode ? style : parseObjectStyles(style)
***REMOVED***)
***REMOVED***

function getClasses(selector, mutate) ***REMOVED***
  let parser = selectorParser((selectors) => ***REMOVED***
    let allClasses = []

    if (mutate) ***REMOVED***
      mutate(selectors)
***REMOVED***

    selectors.walkClasses((classNode) => ***REMOVED***
      allClasses.push(classNode.value)
***REMOVED***)

    return allClasses
***REMOVED***)
  return parser.transformSync(selector)
***REMOVED***

function extractCandidates(node, state = ***REMOVED*** containsNonOnDemandable: false ***REMOVED***, depth = 0) ***REMOVED***
  let classes = []

  // Handle normal rules
  if (node.type === 'rule') ***REMOVED***
    // Ignore everything inside a :not(...). This allows you to write code like
    // `div:not(.foo)`. If `.foo` is never found in your code, then we used to
    // not generated it. But now we will ignore everything inside a `:not`, so
    // that it still gets generated.
    function ignoreNot(selectors) ***REMOVED***
      selectors.walkPseudos((pseudo) => ***REMOVED***
        if (pseudo.value === ':not') ***REMOVED***
          pseudo.remove()
    ***REMOVED***
  ***REMOVED***)
***REMOVED***

    for (let selector of node.selectors) ***REMOVED***
      let classCandidates = getClasses(selector, ignoreNot)
      // At least one of the selectors contains non-"on-demandable" candidates.
      if (classCandidates.length === 0) ***REMOVED***
        state.containsNonOnDemandable = true
  ***REMOVED***

      for (let classCandidate of classCandidates) ***REMOVED***
        classes.push(classCandidate)
  ***REMOVED***
***REMOVED***
***REMOVED***

  // Handle at-rules (which contains nested rules)
  else if (node.type === 'atrule') ***REMOVED***
    node.walkRules((rule) => ***REMOVED***
      for (let classCandidate of rule.selectors.flatMap((selector) => getClasses(selector))) ***REMOVED***
        classes.push(classCandidate)
  ***REMOVED***
***REMOVED***)
***REMOVED***

  if (depth === 0) ***REMOVED***
    return [state.containsNonOnDemandable || classes.length === 0, classes]
***REMOVED***

  return classes
***REMOVED***

function withIdentifiers(styles) ***REMOVED***
  return parseStyles(styles).flatMap((node) => ***REMOVED***
    let nodeMap = new Map()
    let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node)

    // If this isn't "on-demandable", assign it a universal candidate to always include it.
    if (containsNonOnDemandableSelectors) ***REMOVED***
      candidates.unshift(sharedState.NOT_ON_DEMAND)
***REMOVED***

    // However, it could be that it also contains "on-demandable" candidates.
    // E.g.: `span, .foo ***REMOVED******REMOVED***`, in that case it should still be possible to use
    // `@apply foo` for example.
    return candidates.map((c) => ***REMOVED***
      if (!nodeMap.has(node)) ***REMOVED***
        nodeMap.set(node, node)
  ***REMOVED***
      return [c, nodeMap.get(node)]
***REMOVED***)
***REMOVED***)
***REMOVED***

function buildPluginApi(tailwindConfig, context, ***REMOVED*** variantList, variantMap, offsets, classList ***REMOVED***) ***REMOVED***
  function getConfigValue(path, defaultValue) ***REMOVED***
    return path ? dlv(tailwindConfig, path, defaultValue) : tailwindConfig
***REMOVED***

  function applyConfiguredPrefix(selector) ***REMOVED***
    return prefixSelector(tailwindConfig.prefix, selector)
***REMOVED***

  function prefixIdentifier(identifier, options) ***REMOVED***
    if (identifier === sharedState.NOT_ON_DEMAND) ***REMOVED***
      return sharedState.NOT_ON_DEMAND
***REMOVED***

    if (!options.respectPrefix) ***REMOVED***
      return identifier
***REMOVED***

    return context.tailwindConfig.prefix + identifier
***REMOVED***

  return ***REMOVED***
    addVariant(variantName, variantFunctions, options = ***REMOVED******REMOVED***) ***REMOVED***
      variantFunctions = [].concat(variantFunctions).map((variantFunction) => ***REMOVED***
        if (typeof variantFunction !== 'string') ***REMOVED***
          // Safelist public API functions
          return (***REMOVED*** modifySelectors, container, separator ***REMOVED***) => ***REMOVED***
            return variantFunction(***REMOVED*** modifySelectors, container, separator ***REMOVED***)
      ***REMOVED***
    ***REMOVED***

        variantFunction = variantFunction
          .replace(/\n+/g, '')
          .replace(/\s***REMOVED***1,***REMOVED***/g, ' ')
          .trim()

        let fns = parseVariantFormatString(variantFunction)
          .map((str) => ***REMOVED***
            if (!str.startsWith('@')) ***REMOVED***
              return (***REMOVED*** format ***REMOVED***) => format(str)
        ***REMOVED***

            let [, name, params] = /@(.*?) (.*)/g.exec(str)
            return (***REMOVED*** wrap ***REMOVED***) => wrap(postcss.atRule(***REMOVED*** name, params ***REMOVED***))
      ***REMOVED***)
          .reverse()

        return (api) => ***REMOVED***
          for (let fn of fns) ***REMOVED***
            fn(api)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***)

      insertInto(variantList, variantName, options)
      variantMap.set(variantName, variantFunctions)
***REMOVED***,
    postcss,
    prefix: applyConfiguredPrefix,
    e: escapeClassName,
    config: getConfigValue,
    theme(path, defaultValue) ***REMOVED***
      const [pathRoot, ...subPaths] = toPath(path)
      const value = getConfigValue(['theme', pathRoot, ...subPaths], defaultValue)
      return transformThemeValue(pathRoot)(value)
***REMOVED***,
    corePlugins: (path) => ***REMOVED***
      if (Array.isArray(tailwindConfig.corePlugins)) ***REMOVED***
        return tailwindConfig.corePlugins.includes(path)
  ***REMOVED***

      return getConfigValue(['corePlugins', path], true)
***REMOVED***,
    variants: () => ***REMOVED***
      // Preserved for backwards compatibility but not used in v3.0+
      return []
***REMOVED***,
    addBase(base) ***REMOVED***
      for (let [identifier, rule] of withIdentifiers(base)) ***REMOVED***
        let prefixedIdentifier = prefixIdentifier(identifier, ***REMOVED******REMOVED***)
        let offset = offsets.base++

        if (!context.candidateRuleMap.has(prefixedIdentifier)) ***REMOVED***
          context.candidateRuleMap.set(prefixedIdentifier, [])
    ***REMOVED***

        context.candidateRuleMap
          .get(prefixedIdentifier)
          .push([***REMOVED*** sort: offset, layer: 'base' ***REMOVED***, rule])
  ***REMOVED***
***REMOVED***,
    /**
     * @param ***REMOVED***string***REMOVED*** group
     * @param ***REMOVED***Record<string, string | string[]>***REMOVED*** declarations
     */
    addDefaults(group, declarations) ***REMOVED***
      const groups = ***REMOVED***
        [`@defaults $***REMOVED***group***REMOVED***`]: declarations,
  ***REMOVED***

      for (let [identifier, rule] of withIdentifiers(groups)) ***REMOVED***
        let prefixedIdentifier = prefixIdentifier(identifier, ***REMOVED******REMOVED***)

        if (!context.candidateRuleMap.has(prefixedIdentifier)) ***REMOVED***
          context.candidateRuleMap.set(prefixedIdentifier, [])
    ***REMOVED***

        context.candidateRuleMap
          .get(prefixedIdentifier)
          .push([***REMOVED*** sort: offsets.base++, layer: 'defaults' ***REMOVED***, rule])
  ***REMOVED***
***REMOVED***,
    addComponents(components, options) ***REMOVED***
      let defaultOptions = ***REMOVED***
        respectPrefix: true,
        respectImportant: false,
  ***REMOVED***

      options = Object.assign(***REMOVED******REMOVED***, defaultOptions, Array.isArray(options) ? ***REMOVED******REMOVED*** : options)

      for (let [identifier, rule] of withIdentifiers(components)) ***REMOVED***
        let prefixedIdentifier = prefixIdentifier(identifier, options)

        classList.add(prefixedIdentifier)

        if (!context.candidateRuleMap.has(prefixedIdentifier)) ***REMOVED***
          context.candidateRuleMap.set(prefixedIdentifier, [])
    ***REMOVED***

        context.candidateRuleMap
          .get(prefixedIdentifier)
          .push([***REMOVED*** sort: offsets.components++, layer: 'components', options ***REMOVED***, rule])
  ***REMOVED***
***REMOVED***,
    addUtilities(utilities, options) ***REMOVED***
      let defaultOptions = ***REMOVED***
        respectPrefix: true,
        respectImportant: true,
  ***REMOVED***

      options = Object.assign(***REMOVED******REMOVED***, defaultOptions, Array.isArray(options) ? ***REMOVED******REMOVED*** : options)

      for (let [identifier, rule] of withIdentifiers(utilities)) ***REMOVED***
        let prefixedIdentifier = prefixIdentifier(identifier, options)

        classList.add(prefixedIdentifier)

        if (!context.candidateRuleMap.has(prefixedIdentifier)) ***REMOVED***
          context.candidateRuleMap.set(prefixedIdentifier, [])
    ***REMOVED***

        context.candidateRuleMap
          .get(prefixedIdentifier)
          .push([***REMOVED*** sort: offsets.utilities++, layer: 'utilities', options ***REMOVED***, rule])
  ***REMOVED***
***REMOVED***,
    matchUtilities: function (utilities, options) ***REMOVED***
      let defaultOptions = ***REMOVED***
        respectPrefix: true,
        respectImportant: true,
  ***REMOVED***

      options = ***REMOVED*** ...defaultOptions, ...options ***REMOVED***

      let offset = offsets.utilities++

      for (let identifier in utilities) ***REMOVED***
        let prefixedIdentifier = prefixIdentifier(identifier, options)
        let rule = utilities[identifier]

        classList.add([prefixedIdentifier, options])

        function wrapped(modifier, ***REMOVED*** isOnlyPlugin ***REMOVED***) ***REMOVED***
          let ***REMOVED*** type = 'any' ***REMOVED*** = options
          type = [].concat(type)
          let [value, coercedType] = coerceValue(type, modifier, options, tailwindConfig)

          if (value === undefined) ***REMOVED***
            return []
      ***REMOVED***

          if (!type.includes(coercedType) && !isOnlyPlugin) ***REMOVED***
            return []
      ***REMOVED***

          if (!isValidArbitraryValue(value)) ***REMOVED***
            return []
      ***REMOVED***

          let ruleSets = []
            .concat(rule(value))
            .filter(Boolean)
            .map((declaration) => (***REMOVED***
              [nameClass(identifier, modifier)]: declaration,
        ***REMOVED***))

          return ruleSets
    ***REMOVED***

        let withOffsets = [***REMOVED*** sort: offset, layer: 'utilities', options ***REMOVED***, wrapped]

        if (!context.candidateRuleMap.has(prefixedIdentifier)) ***REMOVED***
          context.candidateRuleMap.set(prefixedIdentifier, [])
    ***REMOVED***

        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets)
  ***REMOVED***
***REMOVED***,
    matchComponents: function (components, options) ***REMOVED***
      let defaultOptions = ***REMOVED***
        respectPrefix: true,
        respectImportant: false,
  ***REMOVED***

      options = ***REMOVED*** ...defaultOptions, ...options ***REMOVED***

      let offset = offsets.components++

      for (let identifier in components) ***REMOVED***
        let prefixedIdentifier = prefixIdentifier(identifier, options)
        let rule = components[identifier]

        classList.add([prefixedIdentifier, options])

        function wrapped(modifier, ***REMOVED*** isOnlyPlugin ***REMOVED***) ***REMOVED***
          let ***REMOVED*** type = 'any' ***REMOVED*** = options
          type = [].concat(type)
          let [value, coercedType] = coerceValue(type, modifier, options, tailwindConfig)

          if (value === undefined) ***REMOVED***
            return []
      ***REMOVED***

          if (!type.includes(coercedType)) ***REMOVED***
            if (isOnlyPlugin) ***REMOVED***
              log.warn([
                `Unnecessary typehint \`$***REMOVED***coercedType***REMOVED***\` in \`$***REMOVED***identifier***REMOVED***-$***REMOVED***modifier***REMOVED***\`.`,
                `You can safely update it to \`$***REMOVED***identifier***REMOVED***-$***REMOVED***modifier.replace(
                  coercedType + ':',
                  ''
                )***REMOVED***\`.`,
              ])
        ***REMOVED*** else ***REMOVED***
              return []
        ***REMOVED***
      ***REMOVED***

          if (!isValidArbitraryValue(value)) ***REMOVED***
            return []
      ***REMOVED***

          let ruleSets = []
            .concat(rule(value))
            .filter(Boolean)
            .map((declaration) => (***REMOVED***
              [nameClass(identifier, modifier)]: declaration,
        ***REMOVED***))

          return ruleSets
    ***REMOVED***

        let withOffsets = [***REMOVED*** sort: offset, layer: 'components', options ***REMOVED***, wrapped]

        if (!context.candidateRuleMap.has(prefixedIdentifier)) ***REMOVED***
          context.candidateRuleMap.set(prefixedIdentifier, [])
    ***REMOVED***

        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets)
  ***REMOVED***
***REMOVED***,
***REMOVED***
***REMOVED***

let fileModifiedMapCache = new WeakMap()
export function getFileModifiedMap(context) ***REMOVED***
  if (!fileModifiedMapCache.has(context)) ***REMOVED***
    fileModifiedMapCache.set(context, new Map())
***REMOVED***
  return fileModifiedMapCache.get(context)
***REMOVED***

function trackModified(files, fileModifiedMap) ***REMOVED***
  let changed = false

  for (let file of files) ***REMOVED***
    if (!file) continue

    let parsed = url.parse(file)
    let pathname = parsed.hash ? parsed.href.replace(parsed.hash, '') : parsed.href
    pathname = parsed.search ? pathname.replace(parsed.search, '') : pathname
    let newModified = fs.statSync(decodeURIComponent(pathname), ***REMOVED*** throwIfNoEntry: false ***REMOVED***)?.mtimeMs
    if (!newModified) ***REMOVED***
      // It could happen that a file is passed in that doesn't exist. E.g.:
      // postcss-cli will provide you a fake path when reading from stdin. This
      // path then looks like /path-to-your-project/stdin In that case we just
      // want to ignore it and don't track changes at all.
      continue
***REMOVED***

    if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) ***REMOVED***
      changed = true
***REMOVED***

    fileModifiedMap.set(file, newModified)
***REMOVED***

  return changed
***REMOVED***

function extractVariantAtRules(node) ***REMOVED***
  node.walkAtRules((atRule) => ***REMOVED***
    if (['responsive', 'variants'].includes(atRule.name)) ***REMOVED***
      extractVariantAtRules(atRule)
      atRule.before(atRule.nodes)
      atRule.remove()
***REMOVED***
***REMOVED***)
***REMOVED***

function collectLayerPlugins(root) ***REMOVED***
  let layerPlugins = []

  root.each((node) => ***REMOVED***
    if (node.type === 'atrule' && ['responsive', 'variants'].includes(node.name)) ***REMOVED***
      node.name = 'layer'
      node.params = 'utilities'
***REMOVED***
***REMOVED***)

  // Walk @layer rules and treat them like plugins
  root.walkAtRules('layer', (layerRule) => ***REMOVED***
    extractVariantAtRules(layerRule)

    if (layerRule.params === 'base') ***REMOVED***
      for (let node of layerRule.nodes) ***REMOVED***
        layerPlugins.push(function (***REMOVED*** addBase ***REMOVED***) ***REMOVED***
          addBase(node, ***REMOVED*** respectPrefix: false ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***
      layerRule.remove()
***REMOVED*** else if (layerRule.params === 'components') ***REMOVED***
      for (let node of layerRule.nodes) ***REMOVED***
        layerPlugins.push(function (***REMOVED*** addComponents ***REMOVED***) ***REMOVED***
          addComponents(node, ***REMOVED*** respectPrefix: false ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***
      layerRule.remove()
***REMOVED*** else if (layerRule.params === 'utilities') ***REMOVED***
      for (let node of layerRule.nodes) ***REMOVED***
        layerPlugins.push(function (***REMOVED*** addUtilities ***REMOVED***) ***REMOVED***
          addUtilities(node, ***REMOVED*** respectPrefix: false ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***
      layerRule.remove()
***REMOVED***
***REMOVED***)

  return layerPlugins
***REMOVED***

function resolvePlugins(context, root) ***REMOVED***
  let corePluginList = Object.entries(***REMOVED*** ...variantPlugins, ...corePlugins ***REMOVED***)
    .map(([name, plugin]) => ***REMOVED***
      if (!context.tailwindConfig.corePlugins.includes(name)) ***REMOVED***
        return null
  ***REMOVED***

      return plugin
***REMOVED***)
    .filter(Boolean)

  let userPlugins = context.tailwindConfig.plugins.map((plugin) => ***REMOVED***
    if (plugin.__isOptionsFunction) ***REMOVED***
      plugin = plugin()
***REMOVED***

    return typeof plugin === 'function' ? plugin : plugin.handler
***REMOVED***)

  let layerPlugins = collectLayerPlugins(root)

  // TODO: This is a workaround for backwards compatibility, since custom variants
  // were historically sorted before screen/stackable variants.
  let beforeVariants = [
    variantPlugins['pseudoElementVariants'],
    variantPlugins['pseudoClassVariants'],
  ]
  let afterVariants = [
    variantPlugins['directionVariants'],
    variantPlugins['reducedMotionVariants'],
    variantPlugins['darkVariants'],
    variantPlugins['printVariant'],
    variantPlugins['screenVariants'],
    variantPlugins['orientationVariants'],
  ]

  return [...corePluginList, ...beforeVariants, ...userPlugins, ...afterVariants, ...layerPlugins]
***REMOVED***

function registerPlugins(plugins, context) ***REMOVED***
  let variantList = []
  let variantMap = new Map()
  let offsets = ***REMOVED***
    defaults: 0n,
    base: 0n,
    components: 0n,
    utilities: 0n,
    user: 0n,
***REMOVED***

  let classList = new Set()

  let pluginApi = buildPluginApi(context.tailwindConfig, context, ***REMOVED***
    variantList,
    variantMap,
    offsets,
    classList,
***REMOVED***)

  for (let plugin of plugins) ***REMOVED***
    if (Array.isArray(plugin)) ***REMOVED***
      for (let pluginItem of plugin) ***REMOVED***
        pluginItem(pluginApi)
  ***REMOVED***
***REMOVED*** else ***REMOVED***
      plugin?.(pluginApi)
***REMOVED***
***REMOVED***

  let highestOffset = ((args) => args.reduce((m, e) => (e > m ? e : m)))([
    offsets.base,
    offsets.defaults,
    offsets.components,
    offsets.utilities,
    offsets.user,
  ])
  let reservedBits = BigInt(highestOffset.toString(2).length)

  // A number one less than the top range of the highest offset area
  // so arbitrary properties are always sorted at the end.
  context.arbitraryPropertiesSort = ((1n << reservedBits) << 0n) - 1n

  context.layerOrder = ***REMOVED***
    defaults: (1n << reservedBits) << 0n,
    base: (1n << reservedBits) << 1n,
    components: (1n << reservedBits) << 2n,
    utilities: (1n << reservedBits) << 3n,
    user: (1n << reservedBits) << 4n,
***REMOVED***

  reservedBits += 5n

  let offset = 0
  context.variantOrder = new Map(
    variantList
      .map((variant, i) => ***REMOVED***
        let variantFunctions = variantMap.get(variant).length
        let bits = (1n << BigInt(i + offset)) << reservedBits
        offset += variantFunctions - 1
        return [variant, bits]
  ***REMOVED***)
      .sort(([, a], [, z]) => bigSign(a - z))
  )

  context.minimumScreen = [...context.variantOrder.values()].shift()

  // Build variantMap
  for (let [variantName, variantFunctions] of variantMap.entries()) ***REMOVED***
    let sort = context.variantOrder.get(variantName)
    context.variantMap.set(
      variantName,
      variantFunctions.map((variantFunction, idx) => [sort << BigInt(idx), variantFunction])
    )
***REMOVED***

  let safelist = (context.tailwindConfig.safelist ?? []).filter(Boolean)
  if (safelist.length > 0) ***REMOVED***
    let checks = []

    for (let value of safelist) ***REMOVED***
      if (typeof value === 'string') ***REMOVED***
        context.changedContent.push(***REMOVED*** content: value, extension: 'html' ***REMOVED***)
        continue
  ***REMOVED***

      if (value instanceof RegExp) ***REMOVED***
        log.warn('root-regex', [
          'Regular expressions in `safelist` work differently in Tailwind CSS v3.0.',
          'Update your `safelist` configuration to eliminate this warning.',
          'https://tailwindcss.com/docs/content-configuration#safelisting-classes',
        ])
        continue
  ***REMOVED***

      checks.push(value)
***REMOVED***

    if (checks.length > 0) ***REMOVED***
      let patternMatchingCount = new Map()
      let prefixLength = context.tailwindConfig.prefix.length

      for (let util of classList) ***REMOVED***
        let utils = Array.isArray(util)
          ? (() => ***REMOVED***
              let [utilName, options] = util
              let values = Object.keys(options?.values ?? ***REMOVED******REMOVED***)
              let classes = values.map((value) => formatClass(utilName, value))

              if (options?.supportsNegativeValues) ***REMOVED***
                // This is the normal negated version
                // e.g. `-inset-1` or `-tw-inset-1`
                classes = [...classes, ...classes.map((cls) => '-' + cls)]

                // This is the negated version *after* the prefix
                // e.g. `tw--inset-1`
                // The prefix is already attached to util name
                // So we add the negative after the prefix
                classes = [
                  ...classes,
                  ...classes.map(
                    (cls) => cls.slice(0, prefixLength) + '-' + cls.slice(prefixLength)
                  ),
                ]
          ***REMOVED***

              return classes
        ***REMOVED***)()
          : [util]

        for (let util of utils) ***REMOVED***
          for (let ***REMOVED*** pattern, variants = [] ***REMOVED*** of checks) ***REMOVED***
            // RegExp with the /g flag are stateful, so let's reset the last
            // index pointer to reset the state.
            pattern.lastIndex = 0

            if (!patternMatchingCount.has(pattern)) ***REMOVED***
              patternMatchingCount.set(pattern, 0)
        ***REMOVED***

            if (!pattern.test(util)) continue

            patternMatchingCount.set(pattern, patternMatchingCount.get(pattern) + 1)

            context.changedContent.push(***REMOVED*** content: util, extension: 'html' ***REMOVED***)
            for (let variant of variants) ***REMOVED***
              context.changedContent.push(***REMOVED***
                content: variant + context.tailwindConfig.separator + util,
                extension: 'html',
          ***REMOVED***)
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

      for (let [regex, count] of patternMatchingCount.entries()) ***REMOVED***
        if (count !== 0) continue

        log.warn([
          `The safelist pattern \`$***REMOVED***regex***REMOVED***\` doesn't match any Tailwind CSS classes.`,
          'Fix this pattern or remove it from your `safelist` configuration.',
          'https://tailwindcss.com/docs/content-configuration#safelisting-classes',
        ])
  ***REMOVED***
***REMOVED***
***REMOVED***

  // A list of utilities that are used by certain Tailwind CSS utilities but
  // that don't exist on their own. This will result in them "not existing" and
  // sorting could be weird since you still require them in order to make the
  // host utitlies work properly. (Thanks Biology)
  let parasiteUtilities = new Set([prefix(context, 'group'), prefix(context, 'peer')])
  context.getClassOrder = function getClassOrder(classes) ***REMOVED***
    let sortedClassNames = new Map()
    for (let [sort, rule] of generateRules(new Set(classes), context)) ***REMOVED***
      if (sortedClassNames.has(rule.raws.tailwind.candidate)) continue
      sortedClassNames.set(rule.raws.tailwind.candidate, sort)
***REMOVED***

    return classes.map((className) => ***REMOVED***
      let order = sortedClassNames.get(className) ?? null

      if (order === null && parasiteUtilities.has(className)) ***REMOVED***
        // This will make sure that it is at the very beginning of the
        // `components` layer which technically means 'before any
        // components'.
        order = context.layerOrder.components
  ***REMOVED***

      return [className, order]
***REMOVED***)
***REMOVED***

  // Generate a list of strings for autocompletion purposes, e.g.
  // ['uppercase', 'lowercase', ...]
  context.getClassList = function getClassList() ***REMOVED***
    let output = []

    for (let util of classList) ***REMOVED***
      if (Array.isArray(util)) ***REMOVED***
        let [utilName, options] = util
        let negativeClasses = []

        for (let [key, value] of Object.entries(options?.values ?? ***REMOVED******REMOVED***)) ***REMOVED***
          output.push(formatClass(utilName, key))
          if (options?.supportsNegativeValues && negateValue(value)) ***REMOVED***
            negativeClasses.push(formatClass(utilName, `-$***REMOVED***key***REMOVED***`))
      ***REMOVED***
    ***REMOVED***

        output.push(...negativeClasses)
  ***REMOVED*** else ***REMOVED***
        output.push(util)
  ***REMOVED***
***REMOVED***

    return output
***REMOVED***
***REMOVED***

export function createContext(tailwindConfig, changedContent = [], root = postcss.root()) ***REMOVED***
  let context = ***REMOVED***
    disposables: [],
    ruleCache: new Set(),
    classCache: new Map(),
    applyClassCache: new Map(),
    notClassCache: new Set(),
    postCssNodeCache: new Map(),
    candidateRuleMap: new Map(),
    tailwindConfig,
    changedContent: changedContent,
    variantMap: new Map(),
    stylesheetCache: null,
***REMOVED***

  let resolvedPlugins = resolvePlugins(context, root)
  registerPlugins(resolvedPlugins, context)

  return context
***REMOVED***

let contextMap = sharedState.contextMap
let configContextMap = sharedState.configContextMap
let contextSourcesMap = sharedState.contextSourcesMap

export function getContext(
  root,
  result,
  tailwindConfig,
  userConfigPath,
  tailwindConfigHash,
  contextDependencies
) ***REMOVED***
  let sourcePath = result.opts.from
  let isConfigFile = userConfigPath !== null

  env.DEBUG && console.log('Source path:', sourcePath)

  let existingContext

  if (isConfigFile && contextMap.has(sourcePath)) ***REMOVED***
    existingContext = contextMap.get(sourcePath)
***REMOVED*** else if (configContextMap.has(tailwindConfigHash)) ***REMOVED***
    let context = configContextMap.get(tailwindConfigHash)
    contextSourcesMap.get(context).add(sourcePath)
    contextMap.set(sourcePath, context)

    existingContext = context
***REMOVED***

  let cssDidChange = hasContentChanged(sourcePath, root)

  // If there's already a context in the cache and we don't need to
  // reset the context, return the cached context.
  if (existingContext) ***REMOVED***
    let contextDependenciesChanged = trackModified(
      [...contextDependencies],
      getFileModifiedMap(existingContext)
    )
    if (!contextDependenciesChanged && !cssDidChange) ***REMOVED***
      return [existingContext, false]
***REMOVED***
***REMOVED***

  // If this source is in the context map, get the old context.
  // Remove this source from the context sources for the old context,
  // and clean up that context if no one else is using it. This can be
  // called by many processes in rapid succession, so we check for presence
  // first because the first process to run this code will wipe it out first.
  if (contextMap.has(sourcePath)) ***REMOVED***
    let oldContext = contextMap.get(sourcePath)
    if (contextSourcesMap.has(oldContext)) ***REMOVED***
      contextSourcesMap.get(oldContext).delete(sourcePath)
      if (contextSourcesMap.get(oldContext).size === 0) ***REMOVED***
        contextSourcesMap.delete(oldContext)
        for (let [tailwindConfigHash, context] of configContextMap) ***REMOVED***
          if (context === oldContext) ***REMOVED***
            configContextMap.delete(tailwindConfigHash)
      ***REMOVED***
    ***REMOVED***
        for (let disposable of oldContext.disposables.splice(0)) ***REMOVED***
          disposable(oldContext)
    ***REMOVED***
  ***REMOVED***
***REMOVED***
***REMOVED***

  env.DEBUG && console.log('Setting up new context...')

  let context = createContext(tailwindConfig, [], root)

  trackModified([...contextDependencies], getFileModifiedMap(context))

  // ---

  // Update all context tracking state

  configContextMap.set(tailwindConfigHash, context)
  contextMap.set(sourcePath, context)

  if (!contextSourcesMap.has(context)) ***REMOVED***
    contextSourcesMap.set(context, new Set())
***REMOVED***

  contextSourcesMap.get(context).add(sourcePath)

  return [context, true]
***REMOVED***
