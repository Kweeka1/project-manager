import LRU from 'quick-lru'
import * as sharedState from './sharedState'
import ***REMOVED*** generateRules ***REMOVED*** from './generateRules'
import bigSign from '../util/bigSign'
import log from '../util/log'
import cloneNodes from '../util/cloneNodes'
import ***REMOVED*** defaultExtractor ***REMOVED*** from './defaultExtractor'

let env = sharedState.env

const builtInExtractors = ***REMOVED***
  DEFAULT: defaultExtractor,
***REMOVED***

const builtInTransformers = ***REMOVED***
  DEFAULT: (content) => content,
  svelte: (content) => content.replace(/(?:^|\s)class:/g, ' '),
***REMOVED***

function getExtractor(tailwindConfig, fileExtension) ***REMOVED***
  let extractors = tailwindConfig.content.extract

  return (
    extractors[fileExtension] ||
    extractors.DEFAULT ||
    builtInExtractors[fileExtension] ||
    builtInExtractors.DEFAULT
  )
***REMOVED***

function getTransformer(tailwindConfig, fileExtension) ***REMOVED***
  let transformers = tailwindConfig.content.transform

  return (
    transformers[fileExtension] ||
    transformers.DEFAULT ||
    builtInTransformers[fileExtension] ||
    builtInTransformers.DEFAULT
  )
***REMOVED***

let extractorCache = new WeakMap()

// Scans template contents for possible classes. This is a hot path on initial build but
// not too important for subsequent builds. The faster the better though â€” if we can speed
// up these regexes by 50% that could cut initial build time by like 20%.
function getClassCandidates(content, extractor, candidates, seen) ***REMOVED***
  if (!extractorCache.has(extractor)) ***REMOVED***
    extractorCache.set(extractor, new LRU(***REMOVED*** maxSize: 25000 ***REMOVED***))
***REMOVED***

  for (let line of content.split('\n')) ***REMOVED***
    line = line.trim()

    if (seen.has(line)) ***REMOVED***
      continue
***REMOVED***
    seen.add(line)

    if (extractorCache.get(extractor).has(line)) ***REMOVED***
      for (let match of extractorCache.get(extractor).get(line)) ***REMOVED***
        candidates.add(match)
  ***REMOVED***
***REMOVED*** else ***REMOVED***
      let extractorMatches = extractor(line).filter((s) => s !== '!*')
      let lineMatchesSet = new Set(extractorMatches)

      for (let match of lineMatchesSet) ***REMOVED***
        candidates.add(match)
  ***REMOVED***

      extractorCache.get(extractor).set(line, lineMatchesSet)
***REMOVED***
***REMOVED***
***REMOVED***

function buildStylesheet(rules, context) ***REMOVED***
  let sortedRules = rules.sort(([a], [z]) => bigSign(a - z))

  let returnValue = ***REMOVED***
    base: new Set(),
    defaults: new Set(),
    components: new Set(),
    utilities: new Set(),
    variants: new Set(),

    // All the CSS that is not Tailwind related can be put in this bucket. This
    // will make it easier to later use this information when we want to
    // `@apply` for example. The main reason we do this here is because we
    // still need to make sure the order is correct. Last but not least, we
    // will make sure to always re-inject this section into the css, even if
    // certain rules were not used. This means that it will look like a no-op
    // from the user's perspective, but we gathered all the useful information
    // we need.
    user: new Set(),
***REMOVED***

  for (let [sort, rule] of sortedRules) ***REMOVED***
    if (sort >= context.minimumScreen) ***REMOVED***
      returnValue.variants.add(rule)
      continue
***REMOVED***

    if (sort & context.layerOrder.base) ***REMOVED***
      returnValue.base.add(rule)
      continue
***REMOVED***

    if (sort & context.layerOrder.defaults) ***REMOVED***
      returnValue.defaults.add(rule)
      continue
***REMOVED***

    if (sort & context.layerOrder.components) ***REMOVED***
      returnValue.components.add(rule)
      continue
***REMOVED***

    if (sort & context.layerOrder.utilities) ***REMOVED***
      returnValue.utilities.add(rule)
      continue
***REMOVED***

    if (sort & context.layerOrder.user) ***REMOVED***
      returnValue.user.add(rule)
      continue
***REMOVED***
***REMOVED***

  return returnValue
***REMOVED***

export default function expandTailwindAtRules(context) ***REMOVED***
  return (root) => ***REMOVED***
    let layerNodes = ***REMOVED***
      base: null,
      components: null,
      utilities: null,
      variants: null,
***REMOVED***

    root.walkAtRules((rule) => ***REMOVED***
      // Make sure this file contains Tailwind directives. If not, we can save
      // a lot of work and bail early. Also we don't have to register our touch
      // file as a dependency since the output of this CSS does not depend on
      // the source of any templates. Think Vue <style> blocks for example.
      if (rule.name === 'tailwind') ***REMOVED***
        if (Object.keys(layerNodes).includes(rule.params)) ***REMOVED***
          layerNodes[rule.params] = rule
    ***REMOVED***
  ***REMOVED***
***REMOVED***)

    if (Object.values(layerNodes).every((n) => n === null)) ***REMOVED***
      return root
***REMOVED***

    // ---

    // Find potential rules in changed files
    let candidates = new Set([sharedState.NOT_ON_DEMAND])
    let seen = new Set()

    env.DEBUG && console.time('Reading changed files')

    for (let ***REMOVED*** content, extension ***REMOVED*** of context.changedContent) ***REMOVED***
      let transformer = getTransformer(context.tailwindConfig, extension)
      let extractor = getExtractor(context.tailwindConfig, extension)
      getClassCandidates(transformer(content), extractor, candidates, seen)
***REMOVED***

    env.DEBUG && console.timeEnd('Reading changed files')

    // ---

    // Generate the actual CSS
    let classCacheCount = context.classCache.size

    env.DEBUG && console.time('Generate rules')
    let rules = generateRules(candidates, context)
    env.DEBUG && console.timeEnd('Generate rules')

    // We only ever add to the classCache, so if it didn't grow, there is nothing new.
    env.DEBUG && console.time('Build stylesheet')
    if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) ***REMOVED***
      for (let rule of rules) ***REMOVED***
        context.ruleCache.add(rule)
  ***REMOVED***

      context.stylesheetCache = buildStylesheet([...context.ruleCache], context)
***REMOVED***
    env.DEBUG && console.timeEnd('Build stylesheet')

    let ***REMOVED***
      defaults: defaultNodes,
      base: baseNodes,
      components: componentNodes,
      utilities: utilityNodes,
      variants: screenNodes,
***REMOVED*** = context.stylesheetCache

    // ---

    // Replace any Tailwind directives with generated CSS

    if (layerNodes.base) ***REMOVED***
      layerNodes.base.before(
        cloneNodes([...baseNodes, ...defaultNodes], layerNodes.base.source, ***REMOVED***
          layer: 'base',
    ***REMOVED***)
      )
      layerNodes.base.remove()
***REMOVED***

    if (layerNodes.components) ***REMOVED***
      layerNodes.components.before(
        cloneNodes([...componentNodes], layerNodes.components.source, ***REMOVED***
          layer: 'components',
    ***REMOVED***)
      )
      layerNodes.components.remove()
***REMOVED***

    if (layerNodes.utilities) ***REMOVED***
      layerNodes.utilities.before(
        cloneNodes([...utilityNodes], layerNodes.utilities.source, ***REMOVED***
          layer: 'utilities',
    ***REMOVED***)
      )
      layerNodes.utilities.remove()
***REMOVED***

    // We do post-filtering to not alter the emitted order of the variants
    const variantNodes = Array.from(screenNodes).filter((node) => ***REMOVED***
      const parentLayer = node.raws.tailwind?.parentLayer

      if (parentLayer === 'components') ***REMOVED***
        return layerNodes.components !== null
  ***REMOVED***

      if (parentLayer === 'utilities') ***REMOVED***
        return layerNodes.utilities !== null
  ***REMOVED***

      return true
***REMOVED***)

    if (layerNodes.variants) ***REMOVED***
      layerNodes.variants.before(
        cloneNodes(variantNodes, layerNodes.variants.source, ***REMOVED***
          layer: 'variants',
    ***REMOVED***)
      )
      layerNodes.variants.remove()
***REMOVED*** else if (variantNodes.length > 0) ***REMOVED***
      root.append(
        cloneNodes(variantNodes, root.source, ***REMOVED***
          layer: 'variants',
    ***REMOVED***)
      )
***REMOVED***

    // If we've got a utility layer and no utilities are generated there's likely something wrong
    const hasUtilityVariants = variantNodes.some(
      (node) => node.raws.tailwind?.parentLayer === 'utilities'
    )

    if (layerNodes.utilities && utilityNodes.size === 0 && !hasUtilityVariants) ***REMOVED***
      log.warn('content-problems', [
        'No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.',
        'https://tailwindcss.com/docs/content-configuration',
      ])
***REMOVED***

    // ---

    if (env.DEBUG) ***REMOVED***
      console.log('Potential classes: ', candidates.size)
      console.log('Active contexts: ', sharedState.contextSourcesMap.size)
***REMOVED***

    // Clear the cache for the changed files
    context.changedContent = []

    // Cleanup any leftover @layer atrules
    root.walkAtRules('layer', (rule) => ***REMOVED***
      if (Object.keys(layerNodes).includes(rule.params)) ***REMOVED***
        rule.remove()
  ***REMOVED***
***REMOVED***)
***REMOVED***
***REMOVED***
