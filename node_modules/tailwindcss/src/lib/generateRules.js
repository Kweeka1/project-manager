import postcss from 'postcss'
import selectorParser from 'postcss-selector-parser'
import parseObjectStyles from '../util/parseObjectStyles'
import isPlainObject from '../util/isPlainObject'
import prefixSelector from '../util/prefixSelector'
import ***REMOVED*** updateAllClasses ***REMOVED*** from '../util/pluginUtils'
import log from '../util/log'
import * as sharedState from './sharedState'
import ***REMOVED*** formatVariantSelector, finalizeSelector ***REMOVED*** from '../util/formatVariantSelector'
import ***REMOVED*** asClass ***REMOVED*** from '../util/nameClass'
import ***REMOVED*** normalize ***REMOVED*** from '../util/dataTypes'
import isValidArbitraryValue from '../util/isValidArbitraryValue'

let classNameParser = selectorParser((selectors) => ***REMOVED***
  return selectors.first.filter((***REMOVED*** type ***REMOVED***) => type === 'class').pop().value
***REMOVED***)

function getClassNameFromSelector(selector) ***REMOVED***
  return classNameParser.transformSync(selector)
***REMOVED***

// Generate match permutations for a class candidate, like:
// ['ring-offset-blue', '100']
// ['ring-offset', 'blue-100']
// ['ring', 'offset-blue-100']
// Example with dynamic classes:
// ['grid-cols', '[[linename],1fr,auto]']
// ['grid', 'cols-[[linename],1fr,auto]']
function* candidatePermutations(candidate) ***REMOVED***
  let lastIndex = Infinity

  while (lastIndex >= 0) ***REMOVED***
    let dashIdx

    if (lastIndex === Infinity && candidate.endsWith(']')) ***REMOVED***
      let bracketIdx = candidate.indexOf('[')

      // If character before `[` isn't a dash or a slash, this isn't a dynamic class
      // eg. string[]
      dashIdx = ['-', '/'].includes(candidate[bracketIdx - 1]) ? bracketIdx - 1 : -1
***REMOVED*** else ***REMOVED***
      dashIdx = candidate.lastIndexOf('-', lastIndex)
***REMOVED***

    if (dashIdx < 0) ***REMOVED***
      break
***REMOVED***

    let prefix = candidate.slice(0, dashIdx)
    let modifier = candidate.slice(dashIdx + 1)

    yield [prefix, modifier]

    lastIndex = dashIdx - 1
***REMOVED***
***REMOVED***

function applyPrefix(matches, context) ***REMOVED***
  if (matches.length === 0 || context.tailwindConfig.prefix === '') ***REMOVED***
    return matches
***REMOVED***

  for (let match of matches) ***REMOVED***
    let [meta] = match
    if (meta.options.respectPrefix) ***REMOVED***
      let container = postcss.root(***REMOVED*** nodes: [match[1].clone()] ***REMOVED***)
      let classCandidate = match[1].raws.tailwind.classCandidate

      container.walkRules((r) => ***REMOVED***
        // If this is a negative utility with a dash *before* the prefix we
        // have to ensure that the generated selector matches the candidate

        // Not doing this will cause `-tw-top-1` to generate the class `.tw--top-1`
        // The disconnect between candidate <-> class can cause @apply to hard crash.
        let shouldPrependNegative = classCandidate.startsWith('-')

        r.selector = prefixSelector(
          context.tailwindConfig.prefix,
          r.selector,
          shouldPrependNegative
        )
  ***REMOVED***)

      match[1] = container.nodes[0]
***REMOVED***
***REMOVED***

  return matches
***REMOVED***

function applyImportant(matches, classCandidate) ***REMOVED***
  if (matches.length === 0) ***REMOVED***
    return matches
***REMOVED***
  let result = []

  for (let [meta, rule] of matches) ***REMOVED***
    let container = postcss.root(***REMOVED*** nodes: [rule.clone()] ***REMOVED***)
    container.walkRules((r) => ***REMOVED***
      r.selector = updateAllClasses(r.selector, (className) => ***REMOVED***
        if (className === classCandidate) ***REMOVED***
          return `!$***REMOVED***className***REMOVED***`
    ***REMOVED***
        return className
  ***REMOVED***)
      r.walkDecls((d) => (d.important = true))
***REMOVED***)
    result.push([***REMOVED*** ...meta, important: true ***REMOVED***, container.nodes[0]])
***REMOVED***

  return result
***REMOVED***

// Takes a list of rule tuples and applies a variant like `hover`, sm`,
// whatever to it. We used to do some extra caching here to avoid generating
// a variant of the same rule more than once, but this was never hit because
// we cache at the entire selector level further up the tree.
//
// Technically you can get a cache hit if you have `hover:focus:text-center`
// and `focus:hover:text-center` in the same project, but it doesn't feel
// worth the complexity for that case.

function applyVariant(variant, matches, context) ***REMOVED***
  if (matches.length === 0) ***REMOVED***
    return matches
***REMOVED***

  if (context.variantMap.has(variant)) ***REMOVED***
    let variantFunctionTuples = context.variantMap.get(variant)
    let result = []

    for (let [meta, rule] of matches) ***REMOVED***
      // Don't generate variants for user css
      if (meta.layer === 'user') ***REMOVED***
        continue
  ***REMOVED***

      let container = postcss.root(***REMOVED*** nodes: [rule.clone()] ***REMOVED***)

      for (let [variantSort, variantFunction] of variantFunctionTuples) ***REMOVED***
        let clone = container.clone()
        let collectedFormats = []

        let originals = new Map()

        function prepareBackup() ***REMOVED***
          if (originals.size > 0) return // Already prepared, chicken out
          clone.walkRules((rule) => originals.set(rule, rule.selector))
    ***REMOVED***

        function modifySelectors(modifierFunction) ***REMOVED***
          prepareBackup()
          clone.each((rule) => ***REMOVED***
            if (rule.type !== 'rule') ***REMOVED***
              return
        ***REMOVED***

            rule.selectors = rule.selectors.map((selector) => ***REMOVED***
              return modifierFunction(***REMOVED***
                get className() ***REMOVED***
                  return getClassNameFromSelector(selector)
            ***REMOVED***,
                selector,
          ***REMOVED***)
        ***REMOVED***)
      ***REMOVED***)

          return clone
    ***REMOVED***

        let ruleWithVariant = variantFunction(***REMOVED***
          // Public API
          get container() ***REMOVED***
            prepareBackup()
            return clone
      ***REMOVED***,
          separator: context.tailwindConfig.separator,
          modifySelectors,

          // Private API for now
          wrap(wrapper) ***REMOVED***
            let nodes = clone.nodes
            clone.removeAll()
            wrapper.append(nodes)
            clone.append(wrapper)
      ***REMOVED***,
          format(selectorFormat) ***REMOVED***
            collectedFormats.push(selectorFormat)
      ***REMOVED***,
    ***REMOVED***)

        if (typeof ruleWithVariant === 'string') ***REMOVED***
          collectedFormats.push(ruleWithVariant)
    ***REMOVED***

        if (ruleWithVariant === null) ***REMOVED***
          continue
    ***REMOVED***

        // We filled the `originals`, therefore we assume that somebody touched
        // `container` or `modifySelectors`. Let's see if they did, so that we
        // can restore the selectors, and collect the format strings.
        if (originals.size > 0) ***REMOVED***
          clone.walkRules((rule) => ***REMOVED***
            if (!originals.has(rule)) return
            let before = originals.get(rule)
            if (before === rule.selector) return // No mutation happened

            let modified = rule.selector

            // Rebuild the base selector, this is what plugin authors would do
            // as well. E.g.: `$***REMOVED***variant***REMOVED***$***REMOVED***separator***REMOVED***$***REMOVED***className***REMOVED***`.
            // However, plugin authors probably also prepend or append certain
            // classes, pseudos, ids, ...
            let rebuiltBase = selectorParser((selectors) => ***REMOVED***
              selectors.walkClasses((classNode) => ***REMOVED***
                classNode.value = `$***REMOVED***variant***REMOVED***$***REMOVED***context.tailwindConfig.separator***REMOVED***$***REMOVED***classNode.value***REMOVED***`
          ***REMOVED***)
        ***REMOVED***).processSync(before)

            // Now that we know the original selector, the new selector, and
            // the rebuild part in between, we can replace the part that plugin
            // authors need to rebuild with `&`, and eventually store it in the
            // collectedFormats. Similar to what `format('...')` would do.
            //
            // E.g.:
            //                   variant: foo
            //                  selector: .markdown > p
            //      modified (by plugin): .foo .foo\\:markdown > p
            //    rebuiltBase (internal): .foo\\:markdown > p
            //                    format: .foo &
            collectedFormats.push(modified.replace(rebuiltBase, '&'))
            rule.selector = before
      ***REMOVED***)
    ***REMOVED***

        // This tracks the originating layer for the variant
        // For example:
        // .sm:underline ***REMOVED******REMOVED*** is a variant of something in the utilities layer
        // .sm:container ***REMOVED******REMOVED*** is a variant of the container component
        clone.nodes[0].raws.tailwind = ***REMOVED*** ...clone.nodes[0].raws.tailwind, parentLayer: meta.layer ***REMOVED***

        let withOffset = [
          ***REMOVED***
            ...meta,
            sort: variantSort | meta.sort,
            collectedFormats: (meta.collectedFormats ?? []).concat(collectedFormats),
      ***REMOVED***,
          clone.nodes[0],
        ]
        result.push(withOffset)
  ***REMOVED***
***REMOVED***

    return result
***REMOVED***

  return []
***REMOVED***

function parseRules(rule, cache, options = ***REMOVED******REMOVED***) ***REMOVED***
  // PostCSS node
  if (!isPlainObject(rule) && !Array.isArray(rule)) ***REMOVED***
    return [[rule], options]
***REMOVED***

  // Tuple
  if (Array.isArray(rule)) ***REMOVED***
    return parseRules(rule[0], cache, rule[1])
***REMOVED***

  // Simple object
  if (!cache.has(rule)) ***REMOVED***
    cache.set(rule, parseObjectStyles(rule))
***REMOVED***

  return [cache.get(rule), options]
***REMOVED***

const IS_VALID_PROPERTY_NAME = /^[a-z_-]/

function isValidPropName(name) ***REMOVED***
  return IS_VALID_PROPERTY_NAME.test(name)
***REMOVED***

/**
 * @param ***REMOVED***string***REMOVED*** declaration
 * @returns ***REMOVED***boolean***REMOVED***
 */
function looksLikeUri(declaration) ***REMOVED***
  // Quick bailout for obvious non-urls
  // This doesn't support schemes that don't use a leading // but that's unlikely to be a problem
  if (!declaration.includes('://')) ***REMOVED***
    return false
***REMOVED***

  try ***REMOVED***
    const url = new URL(declaration)
    return url.scheme !== '' && url.host !== ''
***REMOVED*** catch (err) ***REMOVED***
    // Definitely not a valid url
    return false
***REMOVED***
***REMOVED***

function isParsableNode(node) ***REMOVED***
  let isParsable = true

  node.walkDecls((decl) => ***REMOVED***
    if (!isParsableCssValue(decl.name, decl.value)) ***REMOVED***
      isParsable = false
      return false
***REMOVED***
***REMOVED***)

  return isParsable
***REMOVED***

function isParsableCssValue(property, value) ***REMOVED***
  // We don't want to to treat [https://example.com] as a custom property
  // Even though, according to the CSS grammar, it's a totally valid CSS declaration
  // So we short-circuit here by checking if the custom property looks like a url
  if (looksLikeUri(`$***REMOVED***property***REMOVED***:$***REMOVED***value***REMOVED***`)) ***REMOVED***
    return false
***REMOVED***

  try ***REMOVED***
    postcss.parse(`a***REMOVED***$***REMOVED***property***REMOVED***:$***REMOVED***value***REMOVED******REMOVED***`).toResult()
    return true
***REMOVED*** catch (err) ***REMOVED***
    return false
***REMOVED***
***REMOVED***

function extractArbitraryProperty(classCandidate, context) ***REMOVED***
  let [, property, value] = classCandidate.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/) ?? []

  if (value === undefined) ***REMOVED***
    return null
***REMOVED***

  if (!isValidPropName(property)) ***REMOVED***
    return null
***REMOVED***

  if (!isValidArbitraryValue(value)) ***REMOVED***
    return null
***REMOVED***

  let normalized = normalize(value)

  if (!isParsableCssValue(property, normalized)) ***REMOVED***
    return null
***REMOVED***

  return [
    [
      ***REMOVED*** sort: context.arbitraryPropertiesSort, layer: 'utilities' ***REMOVED***,
      () => (***REMOVED***
        [asClass(classCandidate)]: ***REMOVED***
          [property]: normalized,
    ***REMOVED***,
  ***REMOVED***),
    ],
  ]
***REMOVED***

function* resolveMatchedPlugins(classCandidate, context) ***REMOVED***
  if (context.candidateRuleMap.has(classCandidate)) ***REMOVED***
    yield [context.candidateRuleMap.get(classCandidate), 'DEFAULT']
***REMOVED***

  yield* (function* (arbitraryPropertyRule) ***REMOVED***
    if (arbitraryPropertyRule !== null) ***REMOVED***
      yield [arbitraryPropertyRule, 'DEFAULT']
***REMOVED***
***REMOVED***)(extractArbitraryProperty(classCandidate, context))

  let candidatePrefix = classCandidate
  let negative = false

  const twConfigPrefix = context.tailwindConfig.prefix

  const twConfigPrefixLen = twConfigPrefix.length
  if (candidatePrefix[twConfigPrefixLen] === '-') ***REMOVED***
    negative = true
    candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1)
***REMOVED***

  if (negative && context.candidateRuleMap.has(candidatePrefix)) ***REMOVED***
    yield [context.candidateRuleMap.get(candidatePrefix), '-DEFAULT']
***REMOVED***

  for (let [prefix, modifier] of candidatePermutations(candidatePrefix)) ***REMOVED***
    if (context.candidateRuleMap.has(prefix)) ***REMOVED***
      yield [context.candidateRuleMap.get(prefix), negative ? `-$***REMOVED***modifier***REMOVED***` : modifier]
***REMOVED***
***REMOVED***
***REMOVED***

function splitWithSeparator(input, separator) ***REMOVED***
  if (input === sharedState.NOT_ON_DEMAND) ***REMOVED***
    return [sharedState.NOT_ON_DEMAND]
***REMOVED***

  return input.split(new RegExp(`\\$***REMOVED***separator***REMOVED***(?![^[]*\\])`, 'g'))
***REMOVED***

function* recordCandidates(matches, classCandidate) ***REMOVED***
  for (const match of matches) ***REMOVED***
    match[1].raws.tailwind = ***REMOVED*** ...match[1].raws.tailwind, classCandidate ***REMOVED***

    yield match
***REMOVED***
***REMOVED***

function* resolveMatches(candidate, context) ***REMOVED***
  let separator = context.tailwindConfig.separator
  let [classCandidate, ...variants] = splitWithSeparator(candidate, separator).reverse()
  let important = false

  if (classCandidate.startsWith('!')) ***REMOVED***
    important = true
    classCandidate = classCandidate.slice(1)
***REMOVED***

  // TODO: Reintroduce this in ways that doesn't break on false positives
  // function sortAgainst(toSort, against) ***REMOVED***
  //   return toSort.slice().sort((a, z) => ***REMOVED***
  //     return bigSign(against.get(a)[0] - against.get(z)[0])
  // ***REMOVED***)
  // ***REMOVED***
  // let sorted = sortAgainst(variants, context.variantMap)
  // if (sorted.toString() !== variants.toString()) ***REMOVED***
  //   let corrected = sorted.reverse().concat(classCandidate).join(':')
  //   throw new Error(`Class $***REMOVED***candidate***REMOVED*** should be written as $***REMOVED***corrected***REMOVED***`)
  // ***REMOVED***

  for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)) ***REMOVED***
    let matches = []
    let typesByMatches = new Map()

    let [plugins, modifier] = matchedPlugins
    let isOnlyPlugin = plugins.length === 1

    for (let [sort, plugin] of plugins) ***REMOVED***
      let matchesPerPlugin = []

      if (typeof plugin === 'function') ***REMOVED***
        for (let ruleSet of [].concat(plugin(modifier, ***REMOVED*** isOnlyPlugin ***REMOVED***))) ***REMOVED***
          let [rules, options] = parseRules(ruleSet, context.postCssNodeCache)
          for (let rule of rules) ***REMOVED***
            matchesPerPlugin.push([***REMOVED*** ...sort, options: ***REMOVED*** ...sort.options, ...options ***REMOVED*** ***REMOVED***, rule])
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
      // Only process static plugins on exact matches
      else if (modifier === 'DEFAULT' || modifier === '-DEFAULT') ***REMOVED***
        let ruleSet = plugin
        let [rules, options] = parseRules(ruleSet, context.postCssNodeCache)
        for (let rule of rules) ***REMOVED***
          matchesPerPlugin.push([***REMOVED*** ...sort, options: ***REMOVED*** ...sort.options, ...options ***REMOVED*** ***REMOVED***, rule])
    ***REMOVED***
  ***REMOVED***

      if (matchesPerPlugin.length > 0) ***REMOVED***
        typesByMatches.set(matchesPerPlugin, sort.options?.type)
        matches.push(matchesPerPlugin)
  ***REMOVED***
***REMOVED***

    if (isArbitraryValue(modifier)) ***REMOVED***
      // When generated arbitrary values are ambiguous, we can't know
      // which to pick so don't generate any utilities for them
      if (matches.length > 1) ***REMOVED***
        let typesPerPlugin = matches.map((match) => new Set([...(typesByMatches.get(match) ?? [])]))

        // Remove duplicates, so that we can detect proper unique types for each plugin.
        for (let pluginTypes of typesPerPlugin) ***REMOVED***
          for (let type of pluginTypes) ***REMOVED***
            let removeFromOwnGroup = false

            for (let otherGroup of typesPerPlugin) ***REMOVED***
              if (pluginTypes === otherGroup) continue

              if (otherGroup.has(type)) ***REMOVED***
                otherGroup.delete(type)
                removeFromOwnGroup = true
          ***REMOVED***
        ***REMOVED***

            if (removeFromOwnGroup) pluginTypes.delete(type)
      ***REMOVED***
    ***REMOVED***

        let messages = []

        for (let [idx, group] of typesPerPlugin.entries()) ***REMOVED***
          for (let type of group) ***REMOVED***
            let rules = matches[idx]
              .map(([, rule]) => rule)
              .flat()
              .map((rule) =>
                rule
                  .toString()
                  .split('\n')
                  .slice(1, -1) // Remove selector and closing '***REMOVED***'
                  .map((line) => line.trim())
                  .map((x) => `      $***REMOVED***x***REMOVED***`) // Re-indent
                  .join('\n')
              )
              .join('\n\n')

            messages.push(
              `  Use \`$***REMOVED***candidate.replace('[', `[$***REMOVED***type***REMOVED***:`)***REMOVED***\` for \`$***REMOVED***rules.trim()***REMOVED***\``
            )
            break
      ***REMOVED***
    ***REMOVED***

        log.warn([
          `The class \`$***REMOVED***candidate***REMOVED***\` is ambiguous and matches multiple utilities.`,
          ...messages,
          `If this is content and not a class, replace it with \`$***REMOVED***candidate
            .replace('[', '&lsqb;')
            .replace(']', '&rsqb;')***REMOVED***\` to silence this warning.`,
        ])
        continue
  ***REMOVED***

      matches = matches.map((list) => list.filter((match) => isParsableNode(match[1])))
***REMOVED***

    matches = matches.flat()
    matches = Array.from(recordCandidates(matches, classCandidate))
    matches = applyPrefix(matches, context)

    if (important) ***REMOVED***
      matches = applyImportant(matches, classCandidate)
***REMOVED***

    for (let variant of variants) ***REMOVED***
      matches = applyVariant(variant, matches, context)
***REMOVED***

    for (let match of matches) ***REMOVED***
      match[1].raws.tailwind = ***REMOVED*** ...match[1].raws.tailwind, candidate ***REMOVED***

      // Apply final format selector
      if (match[0].collectedFormats) ***REMOVED***
        let finalFormat = formatVariantSelector('&', ...match[0].collectedFormats)
        let container = postcss.root(***REMOVED*** nodes: [match[1].clone()] ***REMOVED***)
        container.walkRules((rule) => ***REMOVED***
          if (inKeyframes(rule)) return

          rule.selector = finalizeSelector(finalFormat, ***REMOVED***
            selector: rule.selector,
            candidate,
            context,
      ***REMOVED***)
    ***REMOVED***)
        match[1] = container.nodes[0]
  ***REMOVED***

      yield match
***REMOVED***
***REMOVED***
***REMOVED***

function inKeyframes(rule) ***REMOVED***
  return rule.parent && rule.parent.type === 'atrule' && rule.parent.name === 'keyframes'
***REMOVED***

function generateRules(candidates, context) ***REMOVED***
  let allRules = []

  for (let candidate of candidates) ***REMOVED***
    if (context.notClassCache.has(candidate)) ***REMOVED***
      continue
***REMOVED***

    if (context.classCache.has(candidate)) ***REMOVED***
      allRules.push(context.classCache.get(candidate))
      continue
***REMOVED***

    let matches = Array.from(resolveMatches(candidate, context))

    if (matches.length === 0) ***REMOVED***
      context.notClassCache.add(candidate)
      continue
***REMOVED***

    context.classCache.set(candidate, matches)
    allRules.push(matches)
***REMOVED***

  // Strategy based on `tailwindConfig.important`
  let strategy = ((important) => ***REMOVED***
    if (important === true) ***REMOVED***
      return (rule) => ***REMOVED***
        rule.walkDecls((d) => ***REMOVED***
          if (d.parent.type === 'rule' && !inKeyframes(d.parent)) ***REMOVED***
            d.important = true
      ***REMOVED***
    ***REMOVED***)
  ***REMOVED***
***REMOVED***

    if (typeof important === 'string') ***REMOVED***
      return (rule) => ***REMOVED***
        rule.selectors = rule.selectors.map((selector) => ***REMOVED***
          return `$***REMOVED***important***REMOVED*** $***REMOVED***selector***REMOVED***`
    ***REMOVED***)
  ***REMOVED***
***REMOVED***
***REMOVED***)(context.tailwindConfig.important)

  return allRules.flat(1).map(([***REMOVED*** sort, layer, options ***REMOVED***, rule]) => ***REMOVED***
    if (options.respectImportant) ***REMOVED***
      if (strategy) ***REMOVED***
        let container = postcss.root(***REMOVED*** nodes: [rule.clone()] ***REMOVED***)
        container.walkRules((r) => ***REMOVED***
          if (inKeyframes(r)) ***REMOVED***
            return
      ***REMOVED***

          strategy(r)
    ***REMOVED***)
        rule = container.nodes[0]
  ***REMOVED***
***REMOVED***

    return [sort | context.layerOrder[layer], rule]
***REMOVED***)
***REMOVED***

function isArbitraryValue(input) ***REMOVED***
  return input.startsWith('[') && input.endsWith(']')
***REMOVED***

export ***REMOVED*** resolveMatches, generateRules ***REMOVED***
