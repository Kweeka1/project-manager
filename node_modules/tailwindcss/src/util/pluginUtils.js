import selectorParser from 'postcss-selector-parser'
import escapeCommas from './escapeCommas'
import ***REMOVED*** withAlphaValue ***REMOVED*** from './withAlphaVariable'
import ***REMOVED***
  normalize,
  length,
  number,
  percentage,
  url,
  color as validateColor,
  genericName,
  familyName,
  image,
  absoluteSize,
  relativeSize,
  position,
  lineWidth,
  shadow,
***REMOVED*** from './dataTypes'
import negateValue from './negateValue'

export function updateAllClasses(selectors, updateClass) ***REMOVED***
  let parser = selectorParser((selectors) => ***REMOVED***
    selectors.walkClasses((sel) => ***REMOVED***
      let updatedClass = updateClass(sel.value)
      sel.value = updatedClass
      if (sel.raws && sel.raws.value) ***REMOVED***
        sel.raws.value = escapeCommas(sel.raws.value)
  ***REMOVED***
***REMOVED***)
***REMOVED***)

  let result = parser.processSync(selectors)

  return result
***REMOVED***

function resolveArbitraryValue(modifier, validate) ***REMOVED***
  if (!isArbitraryValue(modifier)) ***REMOVED***
    return undefined
***REMOVED***

  let value = modifier.slice(1, -1)

  if (!validate(value)) ***REMOVED***
    return undefined
***REMOVED***

  return normalize(value)
***REMOVED***

function asNegativeValue(modifier, lookup = ***REMOVED******REMOVED***, validate) ***REMOVED***
  let positiveValue = lookup[modifier]

  if (positiveValue !== undefined) ***REMOVED***
    return negateValue(positiveValue)
***REMOVED***

  if (isArbitraryValue(modifier)) ***REMOVED***
    let resolved = resolveArbitraryValue(modifier, validate)

    if (resolved === undefined) ***REMOVED***
      return undefined
***REMOVED***

    return negateValue(resolved)
***REMOVED***
***REMOVED***

export function asValue(modifier, options = ***REMOVED******REMOVED***, ***REMOVED*** validate = () => true ***REMOVED*** = ***REMOVED******REMOVED***) ***REMOVED***
  let value = options.values?.[modifier]

  if (value !== undefined) ***REMOVED***
    return value
***REMOVED***

  if (options.supportsNegativeValues && modifier.startsWith('-')) ***REMOVED***
    return asNegativeValue(modifier.slice(1), options.values, validate)
***REMOVED***

  return resolveArbitraryValue(modifier, validate)
***REMOVED***

function isArbitraryValue(input) ***REMOVED***
  return input.startsWith('[') && input.endsWith(']')
***REMOVED***

function splitAlpha(modifier) ***REMOVED***
  let slashIdx = modifier.lastIndexOf('/')

  if (slashIdx === -1 || slashIdx === modifier.length - 1) ***REMOVED***
    return [modifier]
***REMOVED***

  return [modifier.slice(0, slashIdx), modifier.slice(slashIdx + 1)]
***REMOVED***

export function asColor(modifier, options = ***REMOVED******REMOVED***, ***REMOVED*** tailwindConfig = ***REMOVED******REMOVED*** ***REMOVED*** = ***REMOVED******REMOVED***) ***REMOVED***
  if (options.values?.[modifier] !== undefined) ***REMOVED***
    return options.values?.[modifier]
***REMOVED***

  let [color, alpha] = splitAlpha(modifier)

  if (alpha !== undefined) ***REMOVED***
    let normalizedColor =
      options.values?.[color] ?? (isArbitraryValue(color) ? color.slice(1, -1) : undefined)

    if (normalizedColor === undefined) ***REMOVED***
      return undefined
***REMOVED***

    if (isArbitraryValue(alpha)) ***REMOVED***
      return withAlphaValue(normalizedColor, alpha.slice(1, -1))
***REMOVED***

    if (tailwindConfig.theme?.opacity?.[alpha] === undefined) ***REMOVED***
      return undefined
***REMOVED***

    return withAlphaValue(normalizedColor, tailwindConfig.theme.opacity[alpha])
***REMOVED***

  return asValue(modifier, options, ***REMOVED*** validate: validateColor ***REMOVED***)
***REMOVED***

export function asLookupValue(modifier, options = ***REMOVED******REMOVED***) ***REMOVED***
  return options.values?.[modifier]
***REMOVED***

function guess(validate) ***REMOVED***
  return (modifier, options) => ***REMOVED***
    return asValue(modifier, options, ***REMOVED*** validate ***REMOVED***)
***REMOVED***
***REMOVED***

let typeMap = ***REMOVED***
  any: asValue,
  color: asColor,
  url: guess(url),
  image: guess(image),
  length: guess(length),
  percentage: guess(percentage),
  position: guess(position),
  lookup: asLookupValue,
  'generic-name': guess(genericName),
  'family-name': guess(familyName),
  number: guess(number),
  'line-width': guess(lineWidth),
  'absolute-size': guess(absoluteSize),
  'relative-size': guess(relativeSize),
  shadow: guess(shadow),
***REMOVED***

let supportedTypes = Object.keys(typeMap)

function splitAtFirst(input, delim) ***REMOVED***
  let idx = input.indexOf(delim)
  if (idx === -1) return [undefined, input]
  return [input.slice(0, idx), input.slice(idx + 1)]
***REMOVED***

export function coerceValue(types, modifier, options, tailwindConfig) ***REMOVED***
  if (isArbitraryValue(modifier)) ***REMOVED***
    let arbitraryValue = modifier.slice(1, -1)
    let [explicitType, value] = splitAtFirst(arbitraryValue, ':')

    // It could be that this resolves to `url(https` which is not a valid
    // identifier. We currently only support "simple" words with dashes or
    // underscores. E.g.: family-name
    if (!/^[\w-_]+$/g.test(explicitType)) ***REMOVED***
      value = arbitraryValue
***REMOVED***

    //
    else if (explicitType !== undefined && !supportedTypes.includes(explicitType)) ***REMOVED***
      return []
***REMOVED***

    if (value.length > 0 && supportedTypes.includes(explicitType)) ***REMOVED***
      return [asValue(`[$***REMOVED***value***REMOVED***]`, options), explicitType]
***REMOVED***
***REMOVED***

  // Find first matching type
  for (let type of [].concat(types)) ***REMOVED***
    let result = typeMap[type](modifier, options, ***REMOVED*** tailwindConfig ***REMOVED***)
    if (result !== undefined) return [result, type]
***REMOVED***

  return []
***REMOVED***
