let KEYWORDS = new Set(['inset', 'inherit', 'initial', 'revert', 'unset'])
let SPACE = /\ +(?![^(]*\))/g // Similar to the one above, but with spaces instead.
let LENGTH = /^-?(\d+|\.\d+)(.*?)$/g

let SPECIALS = /[(),]/g

/**
 * This splits a string on top-level commas.
 *
 * Regex doesn't support recursion (at least not the JS-flavored version).
 * So we have to use a tiny state machine to keep track of paren vs comma
 * placement. Before we'd only exclude commas from the inner-most nested
 * set of parens rather than any commas that were not contained in parens
 * at all which is the intended behavior here.
 *
 * Expected behavior:
 * var(--a, 0 0 1px rgb(0, 0, 0)), 0 0 1px rgb(0, 0, 0)
 *       ─┬─             ┬  ┬    ┬
 *        x              x  x    ╰──────── Split because top-level
 *        ╰──────────────┴──┴───────────── Ignored b/c inside >= 1 levels of parens
 *
 * @param ***REMOVED***string***REMOVED*** input
 */
function* splitByTopLevelCommas(input) ***REMOVED***
  SPECIALS.lastIndex = -1

  let depth = 0
  let lastIndex = 0
  let found = false

  // Find all parens & commas
  // And only split on commas if they're top-level
  for (let match of input.matchAll(SPECIALS)) ***REMOVED***
    if (match[0] === '(') depth++
    if (match[0] === ')') depth--
    if (match[0] === ',' && depth === 0) ***REMOVED***
      found = true

      yield input.substring(lastIndex, match.index)
      lastIndex = match.index + match[0].length
***REMOVED***
***REMOVED***

  // Provide the last segment of the string if available
  // Otherwise the whole string since no commas were found
  // This mirrors the behavior of string.split()
  if (found) ***REMOVED***
    yield input.substring(lastIndex)
***REMOVED*** else ***REMOVED***
    yield input
***REMOVED***
***REMOVED***

export function parseBoxShadowValue(input) ***REMOVED***
  let shadows = Array.from(splitByTopLevelCommas(input))
  return shadows.map((shadow) => ***REMOVED***
    let value = shadow.trim()
    let result = ***REMOVED*** raw: value ***REMOVED***
    let parts = value.split(SPACE)
    let seen = new Set()

    for (let part of parts) ***REMOVED***
      // Reset index, since the regex is stateful.
      LENGTH.lastIndex = 0

      // Keyword
      if (!seen.has('KEYWORD') && KEYWORDS.has(part)) ***REMOVED***
        result.keyword = part
        seen.add('KEYWORD')
  ***REMOVED***

      // Length value
      else if (LENGTH.test(part)) ***REMOVED***
        if (!seen.has('X')) ***REMOVED***
          result.x = part
          seen.add('X')
    ***REMOVED*** else if (!seen.has('Y')) ***REMOVED***
          result.y = part
          seen.add('Y')
    ***REMOVED*** else if (!seen.has('BLUR')) ***REMOVED***
          result.blur = part
          seen.add('BLUR')
    ***REMOVED*** else if (!seen.has('SPREAD')) ***REMOVED***
          result.spread = part
          seen.add('SPREAD')
    ***REMOVED***
  ***REMOVED***

      // Color or unknown
      else ***REMOVED***
        if (!result.color) ***REMOVED***
          result.color = part
    ***REMOVED*** else ***REMOVED***
          if (!result.unknown) result.unknown = []
          result.unknown.push(part)
    ***REMOVED***
  ***REMOVED***
***REMOVED***

    // Check if valid
    result.valid = result.x !== undefined && result.y !== undefined

    return result
***REMOVED***)
***REMOVED***

export function formatBoxShadowValue(shadows) ***REMOVED***
  return shadows
    .map((shadow) => ***REMOVED***
      if (!shadow.valid) ***REMOVED***
        return shadow.raw
  ***REMOVED***

      return [shadow.keyword, shadow.x, shadow.y, shadow.blur, shadow.spread, shadow.color]
        .filter(Boolean)
        .join(' ')
***REMOVED***)
    .join(', ')
***REMOVED***
