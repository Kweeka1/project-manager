import fs from 'node:fs';
import arrayUnion from 'array-union';
import merge2 from 'merge2';
import fastGlob from 'fast-glob';
import dirGlob from 'dir-glob';
import toPath from './to-path.js';
import ***REMOVED***isGitIgnored, isGitIgnoredSync***REMOVED*** from './gitignore.js';
import ***REMOVED***FilterStream, UniqueStream***REMOVED*** from './stream-utils.js';

const DEFAULT_FILTER = () => false;

const isNegative = pattern => pattern[0] === '!';

const assertPatternsInput = patterns => ***REMOVED***
	if (!patterns.every(pattern => typeof pattern === 'string')) ***REMOVED***
		throw new TypeError('Patterns must be a string or an array of strings');
	***REMOVED***
***REMOVED***;

const checkCwdOption = options => ***REMOVED***
	if (!options.cwd) ***REMOVED***
		return;
	***REMOVED***

	let stat;
	try ***REMOVED***
		stat = fs.statSync(options.cwd);
	***REMOVED*** catch ***REMOVED***
		return;
	***REMOVED***

	if (!stat.isDirectory()) ***REMOVED***
		throw new Error('The `cwd` option must be a path to a directory');
	***REMOVED***
***REMOVED***;

const getPathString = p => p.stats instanceof fs.Stats ? p.path : p;

export const generateGlobTasks = (patterns, taskOptions = ***REMOVED******REMOVED***) => ***REMOVED***
	patterns = arrayUnion([patterns].flat());
	assertPatternsInput(patterns);

	const globTasks = [];

	taskOptions = ***REMOVED***
		ignore: [],
		expandDirectories: true,
		...taskOptions,
		cwd: toPath(taskOptions.cwd),
	***REMOVED***;

	checkCwdOption(taskOptions);

	for (const [index, pattern] of patterns.entries()) ***REMOVED***
		if (isNegative(pattern)) ***REMOVED***
			continue;
		***REMOVED***

		const ignore = patterns
			.slice(index)
			.filter(pattern => isNegative(pattern))
			.map(pattern => pattern.slice(1));

		const options = ***REMOVED***
			...taskOptions,
			ignore: [...taskOptions.ignore, ...ignore],
		***REMOVED***;

		globTasks.push(***REMOVED***pattern, options***REMOVED***);
	***REMOVED***

	return globTasks;
***REMOVED***;

const globDirectories = (task, fn) => ***REMOVED***
	let options = ***REMOVED******REMOVED***;
	if (task.options.cwd) ***REMOVED***
		options.cwd = task.options.cwd;
	***REMOVED***

	if (Array.isArray(task.options.expandDirectories)) ***REMOVED***
		options = ***REMOVED***
			...options,
			files: task.options.expandDirectories,
		***REMOVED***;
	***REMOVED*** else if (typeof task.options.expandDirectories === 'object') ***REMOVED***
		options = ***REMOVED***
			...options,
			...task.options.expandDirectories,
		***REMOVED***;
	***REMOVED***

	return fn(task.pattern, options);
***REMOVED***;

const getPattern = (task, fn) => task.options.expandDirectories ? globDirectories(task, fn) : [task.pattern];

const getFilterSync = options => options && options.gitignore
	? isGitIgnoredSync(***REMOVED***cwd: options.cwd, ignore: options.ignore***REMOVED***)
	: DEFAULT_FILTER;

const globToTask = task => async glob => ***REMOVED***
	const ***REMOVED***options***REMOVED*** = task;
	if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) ***REMOVED***
		options.ignore = await dirGlob(options.ignore);
	***REMOVED***

	return ***REMOVED***
		pattern: glob,
		options,
	***REMOVED***;
***REMOVED***;

const globToTaskSync = task => glob => ***REMOVED***
	const ***REMOVED***options***REMOVED*** = task;
	if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) ***REMOVED***
		options.ignore = dirGlob.sync(options.ignore);
	***REMOVED***

	return ***REMOVED***
		pattern: glob,
		options,
	***REMOVED***;
***REMOVED***;

export const globby = async (patterns, options) => ***REMOVED***
	const globTasks = generateGlobTasks(patterns, options);

	const getFilter = async () => options && options.gitignore
		? isGitIgnored(***REMOVED***cwd: options.cwd, ignore: options.ignore***REMOVED***)
		: DEFAULT_FILTER;

	const getTasks = async () => ***REMOVED***
		const tasks = await Promise.all(globTasks.map(async task => ***REMOVED***
			const globs = await getPattern(task, dirGlob);
			return Promise.all(globs.map(globToTask(task)));
		***REMOVED***));

		return arrayUnion(...tasks);
	***REMOVED***;

	const [filter, tasks] = await Promise.all([getFilter(), getTasks()]);
	const paths = await Promise.all(tasks.map(task => fastGlob(task.pattern, task.options)));

	return arrayUnion(...paths).filter(path_ => !filter(getPathString(path_)));
***REMOVED***;

export const globbySync = (patterns, options) => ***REMOVED***
	const globTasks = generateGlobTasks(patterns, options);

	const tasks = [];
	for (const task of globTasks) ***REMOVED***
		const newTask = getPattern(task, dirGlob.sync).map(globToTaskSync(task));
		tasks.push(...newTask);
	***REMOVED***

	const filter = getFilterSync(options);

	let matches = [];
	for (const task of tasks) ***REMOVED***
		matches = arrayUnion(matches, fastGlob.sync(task.pattern, task.options));
	***REMOVED***

	return matches.filter(path_ => !filter(path_));
***REMOVED***;

export const globbyStream = (patterns, options) => ***REMOVED***
	const globTasks = generateGlobTasks(patterns, options);

	const tasks = [];
	for (const task of globTasks) ***REMOVED***
		const newTask = getPattern(task, dirGlob.sync).map(globToTaskSync(task));
		tasks.push(...newTask);
	***REMOVED***

	const filter = getFilterSync(options);
	const filterStream = new FilterStream(p => !filter(p));
	const uniqueStream = new UniqueStream();

	return merge2(tasks.map(task => fastGlob.stream(task.pattern, task.options)))
		.pipe(filterStream)
		.pipe(uniqueStream);
***REMOVED***;

export const isDynamicPattern = (patterns, options = ***REMOVED******REMOVED***) => ***REMOVED***
	options = ***REMOVED***
		...options,
		cwd: toPath(options.cwd),
	***REMOVED***;

	return [patterns].flat().some(pattern => fastGlob.isDynamicPattern(pattern, options));
***REMOVED***;

export ***REMOVED***
	isGitIgnored,
	isGitIgnoredSync,
***REMOVED*** from './gitignore.js';
