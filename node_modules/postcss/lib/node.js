'use strict'

let ***REMOVED*** isClean, my ***REMOVED*** = require('./symbols')
let CssSyntaxError = require('./css-syntax-error')
let Stringifier = require('./stringifier')
let stringify = require('./stringify')

function cloneNode(obj, parent) ***REMOVED***
  let cloned = new obj.constructor()

  for (let i in obj) ***REMOVED***
    if (!Object.prototype.hasOwnProperty.call(obj, i)) ***REMOVED***
      /* c8 ignore next 2 */
      continue
***REMOVED***
    if (i === 'proxyCache') continue
    let value = obj[i]
    let type = typeof value

    if (i === 'parent' && type === 'object') ***REMOVED***
      if (parent) cloned[i] = parent
***REMOVED*** else if (i === 'source') ***REMOVED***
      cloned[i] = value
***REMOVED*** else if (Array.isArray(value)) ***REMOVED***
      cloned[i] = value.map(j => cloneNode(j, cloned))
***REMOVED*** else ***REMOVED***
      if (type === 'object' && value !== null) value = cloneNode(value)
      cloned[i] = value
***REMOVED***
***REMOVED***

  return cloned
***REMOVED***

class Node ***REMOVED***
  constructor(defaults = ***REMOVED******REMOVED***) ***REMOVED***
    this.raws = ***REMOVED******REMOVED***
    this[isClean] = false
    this[my] = true

    for (let name in defaults) ***REMOVED***
      if (name === 'nodes') ***REMOVED***
        this.nodes = []
        for (let node of defaults[name]) ***REMOVED***
          if (typeof node.clone === 'function') ***REMOVED***
            this.append(node.clone())
      ***REMOVED*** else ***REMOVED***
            this.append(node)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
        this[name] = defaults[name]
  ***REMOVED***
***REMOVED***
***REMOVED***

  error(message, opts = ***REMOVED******REMOVED***) ***REMOVED***
    if (this.source) ***REMOVED***
      let ***REMOVED*** start, end ***REMOVED*** = this.rangeBy(opts)
      return this.source.input.error(
        message,
        ***REMOVED*** line: start.line, column: start.column ***REMOVED***,
        ***REMOVED*** line: end.line, column: end.column ***REMOVED***,
        opts
      )
***REMOVED***
    return new CssSyntaxError(message)
***REMOVED***

  warn(result, text, opts) ***REMOVED***
    let data = ***REMOVED*** node: this ***REMOVED***
    for (let i in opts) data[i] = opts[i]
    return result.warn(text, data)
***REMOVED***

  remove() ***REMOVED***
    if (this.parent) ***REMOVED***
      this.parent.removeChild(this)
***REMOVED***
    this.parent = undefined
    return this
***REMOVED***

  toString(stringifier = stringify) ***REMOVED***
    if (stringifier.stringify) stringifier = stringifier.stringify
    let result = ''
    stringifier(this, i => ***REMOVED***
      result += i
***REMOVED***)
    return result
***REMOVED***

  assign(overrides = ***REMOVED******REMOVED***) ***REMOVED***
    for (let name in overrides) ***REMOVED***
      this[name] = overrides[name]
***REMOVED***
    return this
***REMOVED***

  clone(overrides = ***REMOVED******REMOVED***) ***REMOVED***
    let cloned = cloneNode(this)
    for (let name in overrides) ***REMOVED***
      cloned[name] = overrides[name]
***REMOVED***
    return cloned
***REMOVED***

  cloneBefore(overrides = ***REMOVED******REMOVED***) ***REMOVED***
    let cloned = this.clone(overrides)
    this.parent.insertBefore(this, cloned)
    return cloned
***REMOVED***

  cloneAfter(overrides = ***REMOVED******REMOVED***) ***REMOVED***
    let cloned = this.clone(overrides)
    this.parent.insertAfter(this, cloned)
    return cloned
***REMOVED***

  replaceWith(...nodes) ***REMOVED***
    if (this.parent) ***REMOVED***
      let bookmark = this
      let foundSelf = false
      for (let node of nodes) ***REMOVED***
        if (node === this) ***REMOVED***
          foundSelf = true
    ***REMOVED*** else if (foundSelf) ***REMOVED***
          this.parent.insertAfter(bookmark, node)
          bookmark = node
    ***REMOVED*** else ***REMOVED***
          this.parent.insertBefore(bookmark, node)
    ***REMOVED***
  ***REMOVED***

      if (!foundSelf) ***REMOVED***
        this.remove()
  ***REMOVED***
***REMOVED***

    return this
***REMOVED***

  next() ***REMOVED***
    if (!this.parent) return undefined
    let index = this.parent.index(this)
    return this.parent.nodes[index + 1]
***REMOVED***

  prev() ***REMOVED***
    if (!this.parent) return undefined
    let index = this.parent.index(this)
    return this.parent.nodes[index - 1]
***REMOVED***

  before(add) ***REMOVED***
    this.parent.insertBefore(this, add)
    return this
***REMOVED***

  after(add) ***REMOVED***
    this.parent.insertAfter(this, add)
    return this
***REMOVED***

  root() ***REMOVED***
    let result = this
    while (result.parent && result.parent.type !== 'document') ***REMOVED***
      result = result.parent
***REMOVED***
    return result
***REMOVED***

  raw(prop, defaultType) ***REMOVED***
    let str = new Stringifier()
    return str.raw(this, prop, defaultType)
***REMOVED***

  cleanRaws(keepBetween) ***REMOVED***
    delete this.raws.before
    delete this.raws.after
    if (!keepBetween) delete this.raws.between
***REMOVED***

  toJSON(_, inputs) ***REMOVED***
    let fixed = ***REMOVED******REMOVED***
    let emitInputs = inputs == null
    inputs = inputs || new Map()
    let inputsNextIndex = 0

    for (let name in this) ***REMOVED***
      if (!Object.prototype.hasOwnProperty.call(this, name)) ***REMOVED***
        /* c8 ignore next 2 */
        continue
  ***REMOVED***
      if (name === 'parent' || name === 'proxyCache') continue
      let value = this[name]

      if (Array.isArray(value)) ***REMOVED***
        fixed[name] = value.map(i => ***REMOVED***
          if (typeof i === 'object' && i.toJSON) ***REMOVED***
            return i.toJSON(null, inputs)
      ***REMOVED*** else ***REMOVED***
            return i
      ***REMOVED***
    ***REMOVED***)
  ***REMOVED*** else if (typeof value === 'object' && value.toJSON) ***REMOVED***
        fixed[name] = value.toJSON(null, inputs)
  ***REMOVED*** else if (name === 'source') ***REMOVED***
        let inputId = inputs.get(value.input)
        if (inputId == null) ***REMOVED***
          inputId = inputsNextIndex
          inputs.set(value.input, inputsNextIndex)
          inputsNextIndex++
    ***REMOVED***
        fixed[name] = ***REMOVED***
          inputId,
          start: value.start,
          end: value.end
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
        fixed[name] = value
  ***REMOVED***
***REMOVED***

    if (emitInputs) ***REMOVED***
      fixed.inputs = [...inputs.keys()].map(input => input.toJSON())
***REMOVED***

    return fixed
***REMOVED***

  positionInside(index) ***REMOVED***
    let string = this.toString()
    let column = this.source.start.column
    let line = this.source.start.line

    for (let i = 0; i < index; i++) ***REMOVED***
      if (string[i] === '\n') ***REMOVED***
        column = 1
        line += 1
  ***REMOVED*** else ***REMOVED***
        column += 1
  ***REMOVED***
***REMOVED***

    return ***REMOVED*** line, column ***REMOVED***
***REMOVED***

  positionBy(opts) ***REMOVED***
    let pos = this.source.start
    if (opts.index) ***REMOVED***
      pos = this.positionInside(opts.index)
***REMOVED*** else if (opts.word) ***REMOVED***
      let index = this.toString().indexOf(opts.word)
      if (index !== -1) pos = this.positionInside(index)
***REMOVED***
    return pos
***REMOVED***

  rangeBy(opts) ***REMOVED***
    let start = ***REMOVED***
      line: this.source.start.line,
      column: this.source.start.column
***REMOVED***
    let end = this.source.end
      ? ***REMOVED***
          line: this.source.end.line,
          column: this.source.end.column + 1
    ***REMOVED***
      : ***REMOVED***
          line: start.line,
          column: start.column + 1
    ***REMOVED***

    if (opts.word) ***REMOVED***
      let index = this.toString().indexOf(opts.word)
      if (index !== -1) ***REMOVED***
        start = this.positionInside(index)
        end = this.positionInside(index + opts.word.length)
  ***REMOVED***
***REMOVED*** else ***REMOVED***
      if (opts.start) ***REMOVED***
        start = ***REMOVED***
          line: opts.start.line,
          column: opts.start.column
    ***REMOVED***
  ***REMOVED*** else if (opts.index) ***REMOVED***
        start = this.positionInside(opts.index)
  ***REMOVED***

      if (opts.end) ***REMOVED***
        end = ***REMOVED***
          line: opts.end.line,
          column: opts.end.column
    ***REMOVED***
  ***REMOVED*** else if (opts.endIndex) ***REMOVED***
        end = this.positionInside(opts.endIndex)
  ***REMOVED*** else if (opts.index) ***REMOVED***
        end = this.positionInside(opts.index + 1)
  ***REMOVED***
***REMOVED***

    if (
      end.line < start.line ||
      (end.line === start.line && end.column <= start.column)
    ) ***REMOVED***
      end = ***REMOVED*** line: start.line, column: start.column + 1 ***REMOVED***
***REMOVED***

    return ***REMOVED*** start, end ***REMOVED***
***REMOVED***

  getProxyProcessor() ***REMOVED***
    return ***REMOVED***
      set(node, prop, value) ***REMOVED***
        if (node[prop] === value) return true
        node[prop] = value
        if (
          prop === 'prop' ||
          prop === 'value' ||
          prop === 'name' ||
          prop === 'params' ||
          prop === 'important' ||
          /* c8 ignore next */
          prop === 'text'
        ) ***REMOVED***
          node.markDirty()
    ***REMOVED***
        return true
  ***REMOVED***,

      get(node, prop) ***REMOVED***
        if (prop === 'proxyOf') ***REMOVED***
          return node
    ***REMOVED*** else if (prop === 'root') ***REMOVED***
          return () => node.root().toProxy()
    ***REMOVED*** else ***REMOVED***
          return node[prop]
    ***REMOVED***
  ***REMOVED***
***REMOVED***
***REMOVED***

  toProxy() ***REMOVED***
    if (!this.proxyCache) ***REMOVED***
      this.proxyCache = new Proxy(this, this.getProxyProcessor())
***REMOVED***
    return this.proxyCache
***REMOVED***

  addToError(error) ***REMOVED***
    error.postcssNode = this
    if (error.stack && this.source && /\n\s***REMOVED***4***REMOVED***at /.test(error.stack)) ***REMOVED***
      let s = this.source
      error.stack = error.stack.replace(
        /\n\s***REMOVED***4***REMOVED***at /,
        `$&$***REMOVED***s.input.from***REMOVED***:$***REMOVED***s.start.line***REMOVED***:$***REMOVED***s.start.column***REMOVED***$&`
      )
***REMOVED***
    return error
***REMOVED***

  markDirty() ***REMOVED***
    if (this[isClean]) ***REMOVED***
      this[isClean] = false
      let next = this
      while ((next = next.parent)) ***REMOVED***
        next[isClean] = false
  ***REMOVED***
***REMOVED***
***REMOVED***

  get proxyOf() ***REMOVED***
    return this
***REMOVED***
***REMOVED***

module.exports = Node
Node.default = Node
