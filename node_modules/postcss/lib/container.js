'use strict'

let ***REMOVED*** isClean, my ***REMOVED*** = require('./symbols')
let Declaration = require('./declaration')
let Comment = require('./comment')
let Node = require('./node')

let parse, Rule, AtRule

function cleanSource(nodes) ***REMOVED***
  return nodes.map(i => ***REMOVED***
    if (i.nodes) i.nodes = cleanSource(i.nodes)
    delete i.source
    return i
***REMOVED***)
***REMOVED***

function markDirtyUp(node) ***REMOVED***
  node[isClean] = false
  if (node.proxyOf.nodes) ***REMOVED***
    for (let i of node.proxyOf.nodes) ***REMOVED***
      markDirtyUp(i)
***REMOVED***
***REMOVED***
***REMOVED***

class Container extends Node ***REMOVED***
  push(child) ***REMOVED***
    child.parent = this
    this.proxyOf.nodes.push(child)
    return this
***REMOVED***

  each(callback) ***REMOVED***
    if (!this.proxyOf.nodes) return undefined
    let iterator = this.getIterator()

    let index, result
    while (this.indexes[iterator] < this.proxyOf.nodes.length) ***REMOVED***
      index = this.indexes[iterator]
      result = callback(this.proxyOf.nodes[index], index)
      if (result === false) break

      this.indexes[iterator] += 1
***REMOVED***

    delete this.indexes[iterator]
    return result
***REMOVED***

  walk(callback) ***REMOVED***
    return this.each((child, i) => ***REMOVED***
      let result
      try ***REMOVED***
        result = callback(child, i)
  ***REMOVED*** catch (e) ***REMOVED***
        throw child.addToError(e)
  ***REMOVED***
      if (result !== false && child.walk) ***REMOVED***
        result = child.walk(callback)
  ***REMOVED***

      return result
***REMOVED***)
***REMOVED***

  walkDecls(prop, callback) ***REMOVED***
    if (!callback) ***REMOVED***
      callback = prop
      return this.walk((child, i) => ***REMOVED***
        if (child.type === 'decl') ***REMOVED***
          return callback(child, i)
    ***REMOVED***
  ***REMOVED***)
***REMOVED***
    if (prop instanceof RegExp) ***REMOVED***
      return this.walk((child, i) => ***REMOVED***
        if (child.type === 'decl' && prop.test(child.prop)) ***REMOVED***
          return callback(child, i)
    ***REMOVED***
  ***REMOVED***)
***REMOVED***
    return this.walk((child, i) => ***REMOVED***
      if (child.type === 'decl' && child.prop === prop) ***REMOVED***
        return callback(child, i)
  ***REMOVED***
***REMOVED***)
***REMOVED***

  walkRules(selector, callback) ***REMOVED***
    if (!callback) ***REMOVED***
      callback = selector

      return this.walk((child, i) => ***REMOVED***
        if (child.type === 'rule') ***REMOVED***
          return callback(child, i)
    ***REMOVED***
  ***REMOVED***)
***REMOVED***
    if (selector instanceof RegExp) ***REMOVED***
      return this.walk((child, i) => ***REMOVED***
        if (child.type === 'rule' && selector.test(child.selector)) ***REMOVED***
          return callback(child, i)
    ***REMOVED***
  ***REMOVED***)
***REMOVED***
    return this.walk((child, i) => ***REMOVED***
      if (child.type === 'rule' && child.selector === selector) ***REMOVED***
        return callback(child, i)
  ***REMOVED***
***REMOVED***)
***REMOVED***

  walkAtRules(name, callback) ***REMOVED***
    if (!callback) ***REMOVED***
      callback = name
      return this.walk((child, i) => ***REMOVED***
        if (child.type === 'atrule') ***REMOVED***
          return callback(child, i)
    ***REMOVED***
  ***REMOVED***)
***REMOVED***
    if (name instanceof RegExp) ***REMOVED***
      return this.walk((child, i) => ***REMOVED***
        if (child.type === 'atrule' && name.test(child.name)) ***REMOVED***
          return callback(child, i)
    ***REMOVED***
  ***REMOVED***)
***REMOVED***
    return this.walk((child, i) => ***REMOVED***
      if (child.type === 'atrule' && child.name === name) ***REMOVED***
        return callback(child, i)
  ***REMOVED***
***REMOVED***)
***REMOVED***

  walkComments(callback) ***REMOVED***
    return this.walk((child, i) => ***REMOVED***
      if (child.type === 'comment') ***REMOVED***
        return callback(child, i)
  ***REMOVED***
***REMOVED***)
***REMOVED***

  append(...children) ***REMOVED***
    for (let child of children) ***REMOVED***
      let nodes = this.normalize(child, this.last)
      for (let node of nodes) this.proxyOf.nodes.push(node)
***REMOVED***

    this.markDirty()

    return this
***REMOVED***

  prepend(...children) ***REMOVED***
    children = children.reverse()
    for (let child of children) ***REMOVED***
      let nodes = this.normalize(child, this.first, 'prepend').reverse()
      for (let node of nodes) this.proxyOf.nodes.unshift(node)
      for (let id in this.indexes) ***REMOVED***
        this.indexes[id] = this.indexes[id] + nodes.length
  ***REMOVED***
***REMOVED***

    this.markDirty()

    return this
***REMOVED***

  cleanRaws(keepBetween) ***REMOVED***
    super.cleanRaws(keepBetween)
    if (this.nodes) ***REMOVED***
      for (let node of this.nodes) node.cleanRaws(keepBetween)
***REMOVED***
***REMOVED***

  insertBefore(exist, add) ***REMOVED***
    exist = this.index(exist)

    let type = exist === 0 ? 'prepend' : false
    let nodes = this.normalize(add, this.proxyOf.nodes[exist], type).reverse()
    for (let node of nodes) this.proxyOf.nodes.splice(exist, 0, node)

    let index
    for (let id in this.indexes) ***REMOVED***
      index = this.indexes[id]
      if (exist <= index) ***REMOVED***
        this.indexes[id] = index + nodes.length
  ***REMOVED***
***REMOVED***

    this.markDirty()

    return this
***REMOVED***

  insertAfter(exist, add) ***REMOVED***
    exist = this.index(exist)

    let nodes = this.normalize(add, this.proxyOf.nodes[exist]).reverse()
    for (let node of nodes) this.proxyOf.nodes.splice(exist + 1, 0, node)

    let index
    for (let id in this.indexes) ***REMOVED***
      index = this.indexes[id]
      if (exist < index) ***REMOVED***
        this.indexes[id] = index + nodes.length
  ***REMOVED***
***REMOVED***

    this.markDirty()

    return this
***REMOVED***

  removeChild(child) ***REMOVED***
    child = this.index(child)
    this.proxyOf.nodes[child].parent = undefined
    this.proxyOf.nodes.splice(child, 1)

    let index
    for (let id in this.indexes) ***REMOVED***
      index = this.indexes[id]
      if (index >= child) ***REMOVED***
        this.indexes[id] = index - 1
  ***REMOVED***
***REMOVED***

    this.markDirty()

    return this
***REMOVED***

  removeAll() ***REMOVED***
    for (let node of this.proxyOf.nodes) node.parent = undefined
    this.proxyOf.nodes = []

    this.markDirty()

    return this
***REMOVED***

  replaceValues(pattern, opts, callback) ***REMOVED***
    if (!callback) ***REMOVED***
      callback = opts
      opts = ***REMOVED******REMOVED***
***REMOVED***

    this.walkDecls(decl => ***REMOVED***
      if (opts.props && !opts.props.includes(decl.prop)) return
      if (opts.fast && !decl.value.includes(opts.fast)) return

      decl.value = decl.value.replace(pattern, callback)
***REMOVED***)

    this.markDirty()

    return this
***REMOVED***

  every(condition) ***REMOVED***
    return this.nodes.every(condition)
***REMOVED***

  some(condition) ***REMOVED***
    return this.nodes.some(condition)
***REMOVED***

  index(child) ***REMOVED***
    if (typeof child === 'number') return child
    if (child.proxyOf) child = child.proxyOf
    return this.proxyOf.nodes.indexOf(child)
***REMOVED***

  get first() ***REMOVED***
    if (!this.proxyOf.nodes) return undefined
    return this.proxyOf.nodes[0]
***REMOVED***

  get last() ***REMOVED***
    if (!this.proxyOf.nodes) return undefined
    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1]
***REMOVED***

  normalize(nodes, sample) ***REMOVED***
    if (typeof nodes === 'string') ***REMOVED***
      nodes = cleanSource(parse(nodes).nodes)
***REMOVED*** else if (Array.isArray(nodes)) ***REMOVED***
      nodes = nodes.slice(0)
      for (let i of nodes) ***REMOVED***
        if (i.parent) i.parent.removeChild(i, 'ignore')
  ***REMOVED***
***REMOVED*** else if (nodes.type === 'root' && this.type !== 'document') ***REMOVED***
      nodes = nodes.nodes.slice(0)
      for (let i of nodes) ***REMOVED***
        if (i.parent) i.parent.removeChild(i, 'ignore')
  ***REMOVED***
***REMOVED*** else if (nodes.type) ***REMOVED***
      nodes = [nodes]
***REMOVED*** else if (nodes.prop) ***REMOVED***
      if (typeof nodes.value === 'undefined') ***REMOVED***
        throw new Error('Value field is missed in node creation')
  ***REMOVED*** else if (typeof nodes.value !== 'string') ***REMOVED***
        nodes.value = String(nodes.value)
  ***REMOVED***
      nodes = [new Declaration(nodes)]
***REMOVED*** else if (nodes.selector) ***REMOVED***
      nodes = [new Rule(nodes)]
***REMOVED*** else if (nodes.name) ***REMOVED***
      nodes = [new AtRule(nodes)]
***REMOVED*** else if (nodes.text) ***REMOVED***
      nodes = [new Comment(nodes)]
***REMOVED*** else ***REMOVED***
      throw new Error('Unknown node type in node creation')
***REMOVED***

    let processed = nodes.map(i => ***REMOVED***
      /* c8 ignore next */
      if (!i[my]) Container.rebuild(i)
      i = i.proxyOf
      if (i.parent) i.parent.removeChild(i)
      if (i[isClean]) markDirtyUp(i)
      if (typeof i.raws.before === 'undefined') ***REMOVED***
        if (sample && typeof sample.raws.before !== 'undefined') ***REMOVED***
          i.raws.before = sample.raws.before.replace(/\S/g, '')
    ***REMOVED***
  ***REMOVED***
      i.parent = this.proxyOf
      return i
***REMOVED***)

    return processed
***REMOVED***

  getProxyProcessor() ***REMOVED***
    return ***REMOVED***
      set(node, prop, value) ***REMOVED***
        if (node[prop] === value) return true
        node[prop] = value
        if (prop === 'name' || prop === 'params' || prop === 'selector') ***REMOVED***
          node.markDirty()
    ***REMOVED***
        return true
  ***REMOVED***,

      get(node, prop) ***REMOVED***
        if (prop === 'proxyOf') ***REMOVED***
          return node
    ***REMOVED*** else if (!node[prop]) ***REMOVED***
          return node[prop]
    ***REMOVED*** else if (
          prop === 'each' ||
          (typeof prop === 'string' && prop.startsWith('walk'))
        ) ***REMOVED***
          return (...args) => ***REMOVED***
            return node[prop](
              ...args.map(i => ***REMOVED***
                if (typeof i === 'function') ***REMOVED***
                  return (child, index) => i(child.toProxy(), index)
            ***REMOVED*** else ***REMOVED***
                  return i
            ***REMOVED***
          ***REMOVED***)
            )
      ***REMOVED***
    ***REMOVED*** else if (prop === 'every' || prop === 'some') ***REMOVED***
          return cb => ***REMOVED***
            return node[prop]((child, ...other) =>
              cb(child.toProxy(), ...other)
            )
      ***REMOVED***
    ***REMOVED*** else if (prop === 'root') ***REMOVED***
          return () => node.root().toProxy()
    ***REMOVED*** else if (prop === 'nodes') ***REMOVED***
          return node.nodes.map(i => i.toProxy())
    ***REMOVED*** else if (prop === 'first' || prop === 'last') ***REMOVED***
          return node[prop].toProxy()
    ***REMOVED*** else ***REMOVED***
          return node[prop]
    ***REMOVED***
  ***REMOVED***
***REMOVED***
***REMOVED***

  getIterator() ***REMOVED***
    if (!this.lastEach) this.lastEach = 0
    if (!this.indexes) this.indexes = ***REMOVED******REMOVED***

    this.lastEach += 1
    let iterator = this.lastEach
    this.indexes[iterator] = 0

    return iterator
***REMOVED***
***REMOVED***

Container.registerParse = dependant => ***REMOVED***
  parse = dependant
***REMOVED***

Container.registerRule = dependant => ***REMOVED***
  Rule = dependant
***REMOVED***

Container.registerAtRule = dependant => ***REMOVED***
  AtRule = dependant
***REMOVED***

module.exports = Container
Container.default = Container

/* c8 ignore start */
Container.rebuild = node => ***REMOVED***
  if (node.type === 'atrule') ***REMOVED***
    Object.setPrototypeOf(node, AtRule.prototype)
***REMOVED*** else if (node.type === 'rule') ***REMOVED***
    Object.setPrototypeOf(node, Rule.prototype)
***REMOVED*** else if (node.type === 'decl') ***REMOVED***
    Object.setPrototypeOf(node, Declaration.prototype)
***REMOVED*** else if (node.type === 'comment') ***REMOVED***
    Object.setPrototypeOf(node, Comment.prototype)
***REMOVED***

  node[my] = true

  if (node.nodes) ***REMOVED***
    node.nodes.forEach(child => ***REMOVED***
      Container.rebuild(child)
***REMOVED***)
***REMOVED***
***REMOVED***
/* c8 ignore stop */
