'use strict'

let ***REMOVED*** isClean, my ***REMOVED*** = require('./symbols')
let MapGenerator = require('./map-generator')
let stringify = require('./stringify')
let Container = require('./container')
let Document = require('./document')
let warnOnce = require('./warn-once')
let Result = require('./result')
let parse = require('./parse')
let Root = require('./root')

const TYPE_TO_CLASS_NAME = ***REMOVED***
  document: 'Document',
  root: 'Root',
  atrule: 'AtRule',
  rule: 'Rule',
  decl: 'Declaration',
  comment: 'Comment'
***REMOVED***

const PLUGIN_PROPS = ***REMOVED***
  postcssPlugin: true,
  prepare: true,
  Once: true,
  Document: true,
  Root: true,
  Declaration: true,
  Rule: true,
  AtRule: true,
  Comment: true,
  DeclarationExit: true,
  RuleExit: true,
  AtRuleExit: true,
  CommentExit: true,
  RootExit: true,
  DocumentExit: true,
  OnceExit: true
***REMOVED***

const NOT_VISITORS = ***REMOVED***
  postcssPlugin: true,
  prepare: true,
  Once: true
***REMOVED***

const CHILDREN = 0

function isPromise(obj) ***REMOVED***
  return typeof obj === 'object' && typeof obj.then === 'function'
***REMOVED***

function getEvents(node) ***REMOVED***
  let key = false
  let type = TYPE_TO_CLASS_NAME[node.type]
  if (node.type === 'decl') ***REMOVED***
    key = node.prop.toLowerCase()
***REMOVED*** else if (node.type === 'atrule') ***REMOVED***
    key = node.name.toLowerCase()
***REMOVED***

  if (key && node.append) ***REMOVED***
    return [
      type,
      type + '-' + key,
      CHILDREN,
      type + 'Exit',
      type + 'Exit-' + key
    ]
***REMOVED*** else if (key) ***REMOVED***
    return [type, type + '-' + key, type + 'Exit', type + 'Exit-' + key]
***REMOVED*** else if (node.append) ***REMOVED***
    return [type, CHILDREN, type + 'Exit']
***REMOVED*** else ***REMOVED***
    return [type, type + 'Exit']
***REMOVED***
***REMOVED***

function toStack(node) ***REMOVED***
  let events
  if (node.type === 'document') ***REMOVED***
    events = ['Document', CHILDREN, 'DocumentExit']
***REMOVED*** else if (node.type === 'root') ***REMOVED***
    events = ['Root', CHILDREN, 'RootExit']
***REMOVED*** else ***REMOVED***
    events = getEvents(node)
***REMOVED***

  return ***REMOVED***
    node,
    events,
    eventIndex: 0,
    visitors: [],
    visitorIndex: 0,
    iterator: 0
***REMOVED***
***REMOVED***

function cleanMarks(node) ***REMOVED***
  node[isClean] = false
  if (node.nodes) node.nodes.forEach(i => cleanMarks(i))
  return node
***REMOVED***

let postcss = ***REMOVED******REMOVED***

class LazyResult ***REMOVED***
  constructor(processor, css, opts) ***REMOVED***
    this.stringified = false
    this.processed = false

    let root
    if (
      typeof css === 'object' &&
      css !== null &&
      (css.type === 'root' || css.type === 'document')
    ) ***REMOVED***
      root = cleanMarks(css)
***REMOVED*** else if (css instanceof LazyResult || css instanceof Result) ***REMOVED***
      root = cleanMarks(css.root)
      if (css.map) ***REMOVED***
        if (typeof opts.map === 'undefined') opts.map = ***REMOVED******REMOVED***
        if (!opts.map.inline) opts.map.inline = false
        opts.map.prev = css.map
  ***REMOVED***
***REMOVED*** else ***REMOVED***
      let parser = parse
      if (opts.syntax) parser = opts.syntax.parse
      if (opts.parser) parser = opts.parser
      if (parser.parse) parser = parser.parse

      try ***REMOVED***
        root = parser(css, opts)
  ***REMOVED*** catch (error) ***REMOVED***
        this.processed = true
        this.error = error
  ***REMOVED***

      if (root && !root[my]) ***REMOVED***
        /* c8 ignore next 2 */
        Container.rebuild(root)
  ***REMOVED***
***REMOVED***

    this.result = new Result(processor, root, opts)
    this.helpers = ***REMOVED*** ...postcss, result: this.result, postcss ***REMOVED***
    this.plugins = this.processor.plugins.map(plugin => ***REMOVED***
      if (typeof plugin === 'object' && plugin.prepare) ***REMOVED***
        return ***REMOVED*** ...plugin, ...plugin.prepare(this.result) ***REMOVED***
  ***REMOVED*** else ***REMOVED***
        return plugin
  ***REMOVED***
***REMOVED***)
***REMOVED***

  get [Symbol.toStringTag]() ***REMOVED***
    return 'LazyResult'
***REMOVED***

  get processor() ***REMOVED***
    return this.result.processor
***REMOVED***

  get opts() ***REMOVED***
    return this.result.opts
***REMOVED***

  get css() ***REMOVED***
    return this.stringify().css
***REMOVED***

  get content() ***REMOVED***
    return this.stringify().content
***REMOVED***

  get map() ***REMOVED***
    return this.stringify().map
***REMOVED***

  get root() ***REMOVED***
    return this.sync().root
***REMOVED***

  get messages() ***REMOVED***
    return this.sync().messages
***REMOVED***

  warnings() ***REMOVED***
    return this.sync().warnings()
***REMOVED***

  toString() ***REMOVED***
    return this.css
***REMOVED***

  then(onFulfilled, onRejected) ***REMOVED***
    if (process.env.NODE_ENV !== 'production') ***REMOVED***
      if (!('from' in this.opts)) ***REMOVED***
        warnOnce(
          'Without `from` option PostCSS could generate wrong source map ' +
            'and will not find Browserslist config. Set it to CSS file path ' +
            'or to `undefined` to prevent this warning.'
        )
  ***REMOVED***
***REMOVED***
    return this.async().then(onFulfilled, onRejected)
***REMOVED***

  catch(onRejected) ***REMOVED***
    return this.async().catch(onRejected)
***REMOVED***

  finally(onFinally) ***REMOVED***
    return this.async().then(onFinally, onFinally)
***REMOVED***

  async() ***REMOVED***
    if (this.error) return Promise.reject(this.error)
    if (this.processed) return Promise.resolve(this.result)
    if (!this.processing) ***REMOVED***
      this.processing = this.runAsync()
***REMOVED***
    return this.processing
***REMOVED***

  sync() ***REMOVED***
    if (this.error) throw this.error
    if (this.processed) return this.result
    this.processed = true

    if (this.processing) ***REMOVED***
      throw this.getAsyncError()
***REMOVED***

    for (let plugin of this.plugins) ***REMOVED***
      let promise = this.runOnRoot(plugin)
      if (isPromise(promise)) ***REMOVED***
        throw this.getAsyncError()
  ***REMOVED***
***REMOVED***

    this.prepareVisitors()
    if (this.hasListener) ***REMOVED***
      let root = this.result.root
      while (!root[isClean]) ***REMOVED***
        root[isClean] = true
        this.walkSync(root)
  ***REMOVED***
      if (this.listeners.OnceExit) ***REMOVED***
        if (root.type === 'document') ***REMOVED***
          for (let subRoot of root.nodes) ***REMOVED***
            this.visitSync(this.listeners.OnceExit, subRoot)
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
          this.visitSync(this.listeners.OnceExit, root)
    ***REMOVED***
  ***REMOVED***
***REMOVED***

    return this.result
***REMOVED***

  stringify() ***REMOVED***
    if (this.error) throw this.error
    if (this.stringified) return this.result
    this.stringified = true

    this.sync()

    let opts = this.result.opts
    let str = stringify
    if (opts.syntax) str = opts.syntax.stringify
    if (opts.stringifier) str = opts.stringifier
    if (str.stringify) str = str.stringify

    let map = new MapGenerator(str, this.result.root, this.result.opts)
    let data = map.generate()
    this.result.css = data[0]
    this.result.map = data[1]

    return this.result
***REMOVED***

  walkSync(node) ***REMOVED***
    node[isClean] = true
    let events = getEvents(node)
    for (let event of events) ***REMOVED***
      if (event === CHILDREN) ***REMOVED***
        if (node.nodes) ***REMOVED***
          node.each(child => ***REMOVED***
            if (!child[isClean]) this.walkSync(child)
      ***REMOVED***)
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
        let visitors = this.listeners[event]
        if (visitors) ***REMOVED***
          if (this.visitSync(visitors, node.toProxy())) return
    ***REMOVED***
  ***REMOVED***
***REMOVED***
***REMOVED***

  visitSync(visitors, node) ***REMOVED***
    for (let [plugin, visitor] of visitors) ***REMOVED***
      this.result.lastPlugin = plugin
      let promise
      try ***REMOVED***
        promise = visitor(node, this.helpers)
  ***REMOVED*** catch (e) ***REMOVED***
        throw this.handleError(e, node.proxyOf)
  ***REMOVED***
      if (node.type !== 'root' && node.type !== 'document' && !node.parent) ***REMOVED***
        return true
  ***REMOVED***
      if (isPromise(promise)) ***REMOVED***
        throw this.getAsyncError()
  ***REMOVED***
***REMOVED***
***REMOVED***

  runOnRoot(plugin) ***REMOVED***
    this.result.lastPlugin = plugin
    try ***REMOVED***
      if (typeof plugin === 'object' && plugin.Once) ***REMOVED***
        if (this.result.root.type === 'document') ***REMOVED***
          let roots = this.result.root.nodes.map(root =>
            plugin.Once(root, this.helpers)
          )

          if (isPromise(roots[0])) ***REMOVED***
            return Promise.all(roots)
      ***REMOVED***

          return roots
    ***REMOVED***

        return plugin.Once(this.result.root, this.helpers)
  ***REMOVED*** else if (typeof plugin === 'function') ***REMOVED***
        return plugin(this.result.root, this.result)
  ***REMOVED***
***REMOVED*** catch (error) ***REMOVED***
      throw this.handleError(error)
***REMOVED***
***REMOVED***

  getAsyncError() ***REMOVED***
    throw new Error('Use process(css).then(cb) to work with async plugins')
***REMOVED***

  handleError(error, node) ***REMOVED***
    let plugin = this.result.lastPlugin
    try ***REMOVED***
      if (node) node.addToError(error)
      this.error = error
      if (error.name === 'CssSyntaxError' && !error.plugin) ***REMOVED***
        error.plugin = plugin.postcssPlugin
        error.setMessage()
  ***REMOVED*** else if (plugin.postcssVersion) ***REMOVED***
        if (process.env.NODE_ENV !== 'production') ***REMOVED***
          let pluginName = plugin.postcssPlugin
          let pluginVer = plugin.postcssVersion
          let runtimeVer = this.result.processor.version
          let a = pluginVer.split('.')
          let b = runtimeVer.split('.')

          if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) ***REMOVED***
            // eslint-disable-next-line no-console
            console.error(
              'Unknown error from PostCSS plugin. Your current PostCSS ' +
                'version is ' +
                runtimeVer +
                ', but ' +
                pluginName +
                ' uses ' +
                pluginVer +
                '. Perhaps this is the source of the error below.'
            )
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED*** catch (err) ***REMOVED***
      /* c8 ignore next 3 */
      // eslint-disable-next-line no-console
      if (console && console.error) console.error(err)
***REMOVED***
    return error
***REMOVED***

  async runAsync() ***REMOVED***
    this.plugin = 0
    for (let i = 0; i < this.plugins.length; i++) ***REMOVED***
      let plugin = this.plugins[i]
      let promise = this.runOnRoot(plugin)
      if (isPromise(promise)) ***REMOVED***
        try ***REMOVED***
          await promise
    ***REMOVED*** catch (error) ***REMOVED***
          throw this.handleError(error)
    ***REMOVED***
  ***REMOVED***
***REMOVED***

    this.prepareVisitors()
    if (this.hasListener) ***REMOVED***
      let root = this.result.root
      while (!root[isClean]) ***REMOVED***
        root[isClean] = true
        let stack = [toStack(root)]
        while (stack.length > 0) ***REMOVED***
          let promise = this.visitTick(stack)
          if (isPromise(promise)) ***REMOVED***
            try ***REMOVED***
              await promise
        ***REMOVED*** catch (e) ***REMOVED***
              let node = stack[stack.length - 1].node
              throw this.handleError(e, node)
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

      if (this.listeners.OnceExit) ***REMOVED***
        for (let [plugin, visitor] of this.listeners.OnceExit) ***REMOVED***
          this.result.lastPlugin = plugin
          try ***REMOVED***
            if (root.type === 'document') ***REMOVED***
              let roots = root.nodes.map(subRoot =>
                visitor(subRoot, this.helpers)
              )

              await Promise.all(roots)
        ***REMOVED*** else ***REMOVED***
              await visitor(root, this.helpers)
        ***REMOVED***
      ***REMOVED*** catch (e) ***REMOVED***
            throw this.handleError(e)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

    this.processed = true
    return this.stringify()
***REMOVED***

  prepareVisitors() ***REMOVED***
    this.listeners = ***REMOVED******REMOVED***
    let add = (plugin, type, cb) => ***REMOVED***
      if (!this.listeners[type]) this.listeners[type] = []
      this.listeners[type].push([plugin, cb])
***REMOVED***
    for (let plugin of this.plugins) ***REMOVED***
      if (typeof plugin === 'object') ***REMOVED***
        for (let event in plugin) ***REMOVED***
          if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) ***REMOVED***
            throw new Error(
              `Unknown event $***REMOVED***event***REMOVED*** in $***REMOVED***plugin.postcssPlugin***REMOVED***. ` +
                `Try to update PostCSS ($***REMOVED***this.processor.version***REMOVED*** now).`
            )
      ***REMOVED***
          if (!NOT_VISITORS[event]) ***REMOVED***
            if (typeof plugin[event] === 'object') ***REMOVED***
              for (let filter in plugin[event]) ***REMOVED***
                if (filter === '*') ***REMOVED***
                  add(plugin, event, plugin[event][filter])
            ***REMOVED*** else ***REMOVED***
                  add(
                    plugin,
                    event + '-' + filter.toLowerCase(),
                    plugin[event][filter]
                  )
            ***REMOVED***
          ***REMOVED***
        ***REMOVED*** else if (typeof plugin[event] === 'function') ***REMOVED***
              add(plugin, event, plugin[event])
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***
    this.hasListener = Object.keys(this.listeners).length > 0
***REMOVED***

  visitTick(stack) ***REMOVED***
    let visit = stack[stack.length - 1]
    let ***REMOVED*** node, visitors ***REMOVED*** = visit

    if (node.type !== 'root' && node.type !== 'document' && !node.parent) ***REMOVED***
      stack.pop()
      return
***REMOVED***

    if (visitors.length > 0 && visit.visitorIndex < visitors.length) ***REMOVED***
      let [plugin, visitor] = visitors[visit.visitorIndex]
      visit.visitorIndex += 1
      if (visit.visitorIndex === visitors.length) ***REMOVED***
        visit.visitors = []
        visit.visitorIndex = 0
  ***REMOVED***
      this.result.lastPlugin = plugin
      try ***REMOVED***
        return visitor(node.toProxy(), this.helpers)
  ***REMOVED*** catch (e) ***REMOVED***
        throw this.handleError(e, node)
  ***REMOVED***
***REMOVED***

    if (visit.iterator !== 0) ***REMOVED***
      let iterator = visit.iterator
      let child
      while ((child = node.nodes[node.indexes[iterator]])) ***REMOVED***
        node.indexes[iterator] += 1
        if (!child[isClean]) ***REMOVED***
          child[isClean] = true
          stack.push(toStack(child))
          return
    ***REMOVED***
  ***REMOVED***
      visit.iterator = 0
      delete node.indexes[iterator]
***REMOVED***

    let events = visit.events
    while (visit.eventIndex < events.length) ***REMOVED***
      let event = events[visit.eventIndex]
      visit.eventIndex += 1
      if (event === CHILDREN) ***REMOVED***
        if (node.nodes && node.nodes.length) ***REMOVED***
          node[isClean] = true
          visit.iterator = node.getIterator()
    ***REMOVED***
        return
  ***REMOVED*** else if (this.listeners[event]) ***REMOVED***
        visit.visitors = this.listeners[event]
        return
  ***REMOVED***
***REMOVED***
    stack.pop()
***REMOVED***
***REMOVED***

LazyResult.registerPostcss = dependant => ***REMOVED***
  postcss = dependant
***REMOVED***

module.exports = LazyResult
LazyResult.default = LazyResult

Root.registerLazyResult(LazyResult)
Document.registerLazyResult(LazyResult)
