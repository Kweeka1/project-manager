'use strict'

let ***REMOVED*** SourceMapConsumer, SourceMapGenerator ***REMOVED*** = require('source-map-js')
let ***REMOVED*** fileURLToPath, pathToFileURL ***REMOVED*** = require('url')
let ***REMOVED*** resolve, isAbsolute ***REMOVED*** = require('path')
let ***REMOVED*** nanoid ***REMOVED*** = require('nanoid/non-secure')

let terminalHighlight = require('./terminal-highlight')
let CssSyntaxError = require('./css-syntax-error')
let PreviousMap = require('./previous-map')

let fromOffsetCache = Symbol('fromOffsetCache')

let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)
let pathAvailable = Boolean(resolve && isAbsolute)

class Input ***REMOVED***
  constructor(css, opts = ***REMOVED******REMOVED***) ***REMOVED***
    if (
      css === null ||
      typeof css === 'undefined' ||
      (typeof css === 'object' && !css.toString)
    ) ***REMOVED***
      throw new Error(`PostCSS received $***REMOVED***css***REMOVED*** instead of CSS string`)
***REMOVED***

    this.css = css.toString()

    if (this.css[0] === '\uFEFF' || this.css[0] === '\uFFFE') ***REMOVED***
      this.hasBOM = true
      this.css = this.css.slice(1)
***REMOVED*** else ***REMOVED***
      this.hasBOM = false
***REMOVED***

    if (opts.from) ***REMOVED***
      if (
        !pathAvailable ||
        /^\w+:\/\//.test(opts.from) ||
        isAbsolute(opts.from)
      ) ***REMOVED***
        this.file = opts.from
  ***REMOVED*** else ***REMOVED***
        this.file = resolve(opts.from)
  ***REMOVED***
***REMOVED***

    if (pathAvailable && sourceMapAvailable) ***REMOVED***
      let map = new PreviousMap(this.css, opts)
      if (map.text) ***REMOVED***
        this.map = map
        let file = map.consumer().file
        if (!this.file && file) this.file = this.mapResolve(file)
  ***REMOVED***
***REMOVED***

    if (!this.file) ***REMOVED***
      this.id = '<input css ' + nanoid(6) + '>'
***REMOVED***
    if (this.map) this.map.file = this.from
***REMOVED***

  fromOffset(offset) ***REMOVED***
    let lastLine, lineToIndex
    if (!this[fromOffsetCache]) ***REMOVED***
      let lines = this.css.split('\n')
      lineToIndex = new Array(lines.length)
      let prevIndex = 0

      for (let i = 0, l = lines.length; i < l; i++) ***REMOVED***
        lineToIndex[i] = prevIndex
        prevIndex += lines[i].length + 1
  ***REMOVED***

      this[fromOffsetCache] = lineToIndex
***REMOVED*** else ***REMOVED***
      lineToIndex = this[fromOffsetCache]
***REMOVED***
    lastLine = lineToIndex[lineToIndex.length - 1]

    let min = 0
    if (offset >= lastLine) ***REMOVED***
      min = lineToIndex.length - 1
***REMOVED*** else ***REMOVED***
      let max = lineToIndex.length - 2
      let mid
      while (min < max) ***REMOVED***
        mid = min + ((max - min) >> 1)
        if (offset < lineToIndex[mid]) ***REMOVED***
          max = mid - 1
    ***REMOVED*** else if (offset >= lineToIndex[mid + 1]) ***REMOVED***
          min = mid + 1
    ***REMOVED*** else ***REMOVED***
          min = mid
          break
    ***REMOVED***
  ***REMOVED***
***REMOVED***
    return ***REMOVED***
      line: min + 1,
      col: offset - lineToIndex[min] + 1
***REMOVED***
***REMOVED***

  error(message, line, column, opts = ***REMOVED******REMOVED***) ***REMOVED***
    let result, endLine, endColumn

    if (line && typeof line === 'object') ***REMOVED***
      let start = line
      let end = column
      if (typeof line.offset === 'number') ***REMOVED***
        let pos = this.fromOffset(start.offset)
        line = pos.line
        column = pos.col
  ***REMOVED*** else ***REMOVED***
        line = start.line
        column = start.column
  ***REMOVED***
      if (typeof end.offset === 'number') ***REMOVED***
        let pos = this.fromOffset(end.offset)
        endLine = pos.line
        endColumn = pos.col
  ***REMOVED*** else ***REMOVED***
        endLine = end.line
        endColumn = end.column
  ***REMOVED***
***REMOVED*** else if (!column) ***REMOVED***
      let pos = this.fromOffset(line)
      line = pos.line
      column = pos.col
***REMOVED***

    let origin = this.origin(line, column, endLine, endColumn)
    if (origin) ***REMOVED***
      result = new CssSyntaxError(
        message,
        origin.endLine === undefined
          ? origin.line
          : ***REMOVED*** line: origin.line, column: origin.column ***REMOVED***,
        origin.endLine === undefined
          ? origin.column
          : ***REMOVED*** line: origin.endLine, column: origin.endColumn ***REMOVED***,
        origin.source,
        origin.file,
        opts.plugin
      )
***REMOVED*** else ***REMOVED***
      result = new CssSyntaxError(
        message,
        endLine === undefined ? line : ***REMOVED*** line, column ***REMOVED***,
        endLine === undefined ? column : ***REMOVED*** line: endLine, column: endColumn ***REMOVED***,
        this.css,
        this.file,
        opts.plugin
      )
***REMOVED***

    result.input = ***REMOVED*** line, column, endLine, endColumn, source: this.css ***REMOVED***
    if (this.file) ***REMOVED***
      if (pathToFileURL) ***REMOVED***
        result.input.url = pathToFileURL(this.file).toString()
  ***REMOVED***
      result.input.file = this.file
***REMOVED***

    return result
***REMOVED***

  origin(line, column, endLine, endColumn) ***REMOVED***
    if (!this.map) return false
    let consumer = this.map.consumer()

    let from = consumer.originalPositionFor(***REMOVED*** line, column ***REMOVED***)
    if (!from.source) return false

    let to
    if (typeof endLine === 'number') ***REMOVED***
      to = consumer.originalPositionFor(***REMOVED*** line: endLine, column: endColumn ***REMOVED***)
***REMOVED***

    let fromUrl

    if (isAbsolute(from.source)) ***REMOVED***
      fromUrl = pathToFileURL(from.source)
***REMOVED*** else ***REMOVED***
      fromUrl = new URL(
        from.source,
        this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)
      )
***REMOVED***

    let result = ***REMOVED***
      url: fromUrl.toString(),
      line: from.line,
      column: from.column,
      endLine: to && to.line,
      endColumn: to && to.column
***REMOVED***

    if (fromUrl.protocol === 'file:') ***REMOVED***
      if (fileURLToPath) ***REMOVED***
        result.file = fileURLToPath(fromUrl)
  ***REMOVED*** else ***REMOVED***
        /* c8 ignore next 2 */
        throw new Error(`file: protocol is not available in this PostCSS build`)
  ***REMOVED***
***REMOVED***

    let source = consumer.sourceContentFor(from.source)
    if (source) result.source = source

    return result
***REMOVED***

  mapResolve(file) ***REMOVED***
    if (/^\w+:\/\//.test(file)) ***REMOVED***
      return file
***REMOVED***
    return resolve(this.map.consumer().sourceRoot || this.map.root || '.', file)
***REMOVED***

  get from() ***REMOVED***
    return this.file || this.id
***REMOVED***

  toJSON() ***REMOVED***
    let json = ***REMOVED******REMOVED***
    for (let name of ['hasBOM', 'css', 'file', 'id']) ***REMOVED***
      if (this[name] != null) ***REMOVED***
        json[name] = this[name]
  ***REMOVED***
***REMOVED***
    if (this.map) ***REMOVED***
      json.map = ***REMOVED*** ...this.map ***REMOVED***
      if (json.map.consumerCache) ***REMOVED***
        json.map.consumerCache = undefined
  ***REMOVED***
***REMOVED***
    return json
***REMOVED***
***REMOVED***

module.exports = Input
Input.default = Input

if (terminalHighlight && terminalHighlight.registerInput) ***REMOVED***
  terminalHighlight.registerInput(Input)
***REMOVED***
