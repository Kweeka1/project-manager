'use strict'

let Declaration = require('./declaration')
let tokenizer = require('./tokenize')
let Comment = require('./comment')
let AtRule = require('./at-rule')
let Root = require('./root')
let Rule = require('./rule')

const SAFE_COMMENT_NEIGHBOR = ***REMOVED***
  empty: true,
  space: true
***REMOVED***

function findLastWithPosition(tokens) ***REMOVED***
  for (let i = tokens.length - 1; i >= 0; i--) ***REMOVED***
    let token = tokens[i]
    let pos = token[3] || token[2]
    if (pos) return pos
***REMOVED***
***REMOVED***

class Parser ***REMOVED***
  constructor(input) ***REMOVED***
    this.input = input

    this.root = new Root()
    this.current = this.root
    this.spaces = ''
    this.semicolon = false
    this.customProperty = false

    this.createTokenizer()
    this.root.source = ***REMOVED*** input, start: ***REMOVED*** offset: 0, line: 1, column: 1 ***REMOVED*** ***REMOVED***
***REMOVED***

  createTokenizer() ***REMOVED***
    this.tokenizer = tokenizer(this.input)
***REMOVED***

  parse() ***REMOVED***
    let token
    while (!this.tokenizer.endOfFile()) ***REMOVED***
      token = this.tokenizer.nextToken()

      switch (token[0]) ***REMOVED***
        case 'space':
          this.spaces += token[1]
          break

        case ';':
          this.freeSemicolon(token)
          break

        case '***REMOVED***':
          this.end(token)
          break

        case 'comment':
          this.comment(token)
          break

        case 'at-word':
          this.atrule(token)
          break

        case '***REMOVED***':
          this.emptyRule(token)
          break

        default:
          this.other(token)
          break
  ***REMOVED***
***REMOVED***
    this.endFile()
***REMOVED***

  comment(token) ***REMOVED***
    let node = new Comment()
    this.init(node, token[2])
    node.source.end = this.getPosition(token[3] || token[2])

    let text = token[1].slice(2, -2)
    if (/^\s*$/.test(text)) ***REMOVED***
      node.text = ''
      node.raws.left = text
      node.raws.right = ''
***REMOVED*** else ***REMOVED***
      let match = text.match(/^(\s*)([^]*\S)(\s*)$/)
      node.text = match[2]
      node.raws.left = match[1]
      node.raws.right = match[3]
***REMOVED***
***REMOVED***

  emptyRule(token) ***REMOVED***
    let node = new Rule()
    this.init(node, token[2])
    node.selector = ''
    node.raws.between = ''
    this.current = node
***REMOVED***

  other(start) ***REMOVED***
    let end = false
    let type = null
    let colon = false
    let bracket = null
    let brackets = []
    let customProperty = start[1].startsWith('--')

    let tokens = []
    let token = start
    while (token) ***REMOVED***
      type = token[0]
      tokens.push(token)

      if (type === '(' || type === '[') ***REMOVED***
        if (!bracket) bracket = token
        brackets.push(type === '(' ? ')' : ']')
  ***REMOVED*** else if (customProperty && colon && type === '***REMOVED***') ***REMOVED***
        if (!bracket) bracket = token
        brackets.push('***REMOVED***')
  ***REMOVED*** else if (brackets.length === 0) ***REMOVED***
        if (type === ';') ***REMOVED***
          if (colon) ***REMOVED***
            this.decl(tokens, customProperty)
            return
      ***REMOVED*** else ***REMOVED***
            break
      ***REMOVED***
    ***REMOVED*** else if (type === '***REMOVED***') ***REMOVED***
          this.rule(tokens)
          return
    ***REMOVED*** else if (type === '***REMOVED***') ***REMOVED***
          this.tokenizer.back(tokens.pop())
          end = true
          break
    ***REMOVED*** else if (type === ':') ***REMOVED***
          colon = true
    ***REMOVED***
  ***REMOVED*** else if (type === brackets[brackets.length - 1]) ***REMOVED***
        brackets.pop()
        if (brackets.length === 0) bracket = null
  ***REMOVED***

      token = this.tokenizer.nextToken()
***REMOVED***

    if (this.tokenizer.endOfFile()) end = true
    if (brackets.length > 0) this.unclosedBracket(bracket)

    if (end && colon) ***REMOVED***
      if (!customProperty) ***REMOVED***
        while (tokens.length) ***REMOVED***
          token = tokens[tokens.length - 1][0]
          if (token !== 'space' && token !== 'comment') break
          this.tokenizer.back(tokens.pop())
    ***REMOVED***
  ***REMOVED***
      this.decl(tokens, customProperty)
***REMOVED*** else ***REMOVED***
      this.unknownWord(tokens)
***REMOVED***
***REMOVED***

  rule(tokens) ***REMOVED***
    tokens.pop()

    let node = new Rule()
    this.init(node, tokens[0][2])

    node.raws.between = this.spacesAndCommentsFromEnd(tokens)
    this.raw(node, 'selector', tokens)
    this.current = node
***REMOVED***

  decl(tokens, customProperty) ***REMOVED***
    let node = new Declaration()
    this.init(node, tokens[0][2])

    let last = tokens[tokens.length - 1]
    if (last[0] === ';') ***REMOVED***
      this.semicolon = true
      tokens.pop()
***REMOVED***

    node.source.end = this.getPosition(
      last[3] || last[2] || findLastWithPosition(tokens)
    )

    while (tokens[0][0] !== 'word') ***REMOVED***
      if (tokens.length === 1) this.unknownWord(tokens)
      node.raws.before += tokens.shift()[1]
***REMOVED***
    node.source.start = this.getPosition(tokens[0][2])

    node.prop = ''
    while (tokens.length) ***REMOVED***
      let type = tokens[0][0]
      if (type === ':' || type === 'space' || type === 'comment') ***REMOVED***
        break
  ***REMOVED***
      node.prop += tokens.shift()[1]
***REMOVED***

    node.raws.between = ''

    let token
    while (tokens.length) ***REMOVED***
      token = tokens.shift()

      if (token[0] === ':') ***REMOVED***
        node.raws.between += token[1]
        break
  ***REMOVED*** else ***REMOVED***
        if (token[0] === 'word' && /\w/.test(token[1])) ***REMOVED***
          this.unknownWord([token])
    ***REMOVED***
        node.raws.between += token[1]
  ***REMOVED***
***REMOVED***

    if (node.prop[0] === '_' || node.prop[0] === '*') ***REMOVED***
      node.raws.before += node.prop[0]
      node.prop = node.prop.slice(1)
***REMOVED***

    let firstSpaces = []
    let next
    while (tokens.length) ***REMOVED***
      next = tokens[0][0]
      if (next !== 'space' && next !== 'comment') break
      firstSpaces.push(tokens.shift())
***REMOVED***

    this.precheckMissedSemicolon(tokens)

    for (let i = tokens.length - 1; i >= 0; i--) ***REMOVED***
      token = tokens[i]
      if (token[1].toLowerCase() === '!important') ***REMOVED***
        node.important = true
        let string = this.stringFrom(tokens, i)
        string = this.spacesFromEnd(tokens) + string
        if (string !== ' !important') node.raws.important = string
        break
  ***REMOVED*** else if (token[1].toLowerCase() === 'important') ***REMOVED***
        let cache = tokens.slice(0)
        let str = ''
        for (let j = i; j > 0; j--) ***REMOVED***
          let type = cache[j][0]
          if (str.trim().indexOf('!') === 0 && type !== 'space') ***REMOVED***
            break
      ***REMOVED***
          str = cache.pop()[1] + str
    ***REMOVED***
        if (str.trim().indexOf('!') === 0) ***REMOVED***
          node.important = true
          node.raws.important = str
          tokens = cache
    ***REMOVED***
  ***REMOVED***

      if (token[0] !== 'space' && token[0] !== 'comment') ***REMOVED***
        break
  ***REMOVED***
***REMOVED***

    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment')

    if (hasWord) ***REMOVED***
      node.raws.between += firstSpaces.map(i => i[1]).join('')
      firstSpaces = []
***REMOVED***
    this.raw(node, 'value', firstSpaces.concat(tokens), customProperty)

    if (node.value.includes(':') && !customProperty) ***REMOVED***
      this.checkMissedSemicolon(tokens)
***REMOVED***
***REMOVED***

  atrule(token) ***REMOVED***
    let node = new AtRule()
    node.name = token[1].slice(1)
    if (node.name === '') ***REMOVED***
      this.unnamedAtrule(node, token)
***REMOVED***
    this.init(node, token[2])

    let type
    let prev
    let shift
    let last = false
    let open = false
    let params = []
    let brackets = []

    while (!this.tokenizer.endOfFile()) ***REMOVED***
      token = this.tokenizer.nextToken()
      type = token[0]

      if (type === '(' || type === '[') ***REMOVED***
        brackets.push(type === '(' ? ')' : ']')
  ***REMOVED*** else if (type === '***REMOVED***' && brackets.length > 0) ***REMOVED***
        brackets.push('***REMOVED***')
  ***REMOVED*** else if (type === brackets[brackets.length - 1]) ***REMOVED***
        brackets.pop()
  ***REMOVED***

      if (brackets.length === 0) ***REMOVED***
        if (type === ';') ***REMOVED***
          node.source.end = this.getPosition(token[2])
          this.semicolon = true
          break
    ***REMOVED*** else if (type === '***REMOVED***') ***REMOVED***
          open = true
          break
    ***REMOVED*** else if (type === '***REMOVED***') ***REMOVED***
          if (params.length > 0) ***REMOVED***
            shift = params.length - 1
            prev = params[shift]
            while (prev && prev[0] === 'space') ***REMOVED***
              prev = params[--shift]
        ***REMOVED***
            if (prev) ***REMOVED***
              node.source.end = this.getPosition(prev[3] || prev[2])
        ***REMOVED***
      ***REMOVED***
          this.end(token)
          break
    ***REMOVED*** else ***REMOVED***
          params.push(token)
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
        params.push(token)
  ***REMOVED***

      if (this.tokenizer.endOfFile()) ***REMOVED***
        last = true
        break
  ***REMOVED***
***REMOVED***

    node.raws.between = this.spacesAndCommentsFromEnd(params)
    if (params.length) ***REMOVED***
      node.raws.afterName = this.spacesAndCommentsFromStart(params)
      this.raw(node, 'params', params)
      if (last) ***REMOVED***
        token = params[params.length - 1]
        node.source.end = this.getPosition(token[3] || token[2])
        this.spaces = node.raws.between
        node.raws.between = ''
  ***REMOVED***
***REMOVED*** else ***REMOVED***
      node.raws.afterName = ''
      node.params = ''
***REMOVED***

    if (open) ***REMOVED***
      node.nodes = []
      this.current = node
***REMOVED***
***REMOVED***

  end(token) ***REMOVED***
    if (this.current.nodes && this.current.nodes.length) ***REMOVED***
      this.current.raws.semicolon = this.semicolon
***REMOVED***
    this.semicolon = false

    this.current.raws.after = (this.current.raws.after || '') + this.spaces
    this.spaces = ''

    if (this.current.parent) ***REMOVED***
      this.current.source.end = this.getPosition(token[2])
      this.current = this.current.parent
***REMOVED*** else ***REMOVED***
      this.unexpectedClose(token)
***REMOVED***
***REMOVED***

  endFile() ***REMOVED***
    if (this.current.parent) this.unclosedBlock()
    if (this.current.nodes && this.current.nodes.length) ***REMOVED***
      this.current.raws.semicolon = this.semicolon
***REMOVED***
    this.current.raws.after = (this.current.raws.after || '') + this.spaces
***REMOVED***

  freeSemicolon(token) ***REMOVED***
    this.spaces += token[1]
    if (this.current.nodes) ***REMOVED***
      let prev = this.current.nodes[this.current.nodes.length - 1]
      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) ***REMOVED***
        prev.raws.ownSemicolon = this.spaces
        this.spaces = ''
  ***REMOVED***
***REMOVED***
***REMOVED***

  // Helpers

  getPosition(offset) ***REMOVED***
    let pos = this.input.fromOffset(offset)
    return ***REMOVED***
      offset,
      line: pos.line,
      column: pos.col
***REMOVED***
***REMOVED***

  init(node, offset) ***REMOVED***
    this.current.push(node)
    node.source = ***REMOVED***
      start: this.getPosition(offset),
      input: this.input
***REMOVED***
    node.raws.before = this.spaces
    this.spaces = ''
    if (node.type !== 'comment') this.semicolon = false
***REMOVED***

  raw(node, prop, tokens, customProperty) ***REMOVED***
    let token, type
    let length = tokens.length
    let value = ''
    let clean = true
    let next, prev

    for (let i = 0; i < length; i += 1) ***REMOVED***
      token = tokens[i]
      type = token[0]
      if (type === 'space' && i === length - 1 && !customProperty) ***REMOVED***
        clean = false
  ***REMOVED*** else if (type === 'comment') ***REMOVED***
        prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty'
        next = tokens[i + 1] ? tokens[i + 1][0] : 'empty'
        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) ***REMOVED***
          if (value.slice(-1) === ',') ***REMOVED***
            clean = false
      ***REMOVED*** else ***REMOVED***
            value += token[1]
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
          clean = false
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
        value += token[1]
  ***REMOVED***
***REMOVED***
    if (!clean) ***REMOVED***
      let raw = tokens.reduce((all, i) => all + i[1], '')
      node.raws[prop] = ***REMOVED*** value, raw ***REMOVED***
***REMOVED***
    node[prop] = value
***REMOVED***

  spacesAndCommentsFromEnd(tokens) ***REMOVED***
    let lastTokenType
    let spaces = ''
    while (tokens.length) ***REMOVED***
      lastTokenType = tokens[tokens.length - 1][0]
      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break
      spaces = tokens.pop()[1] + spaces
***REMOVED***
    return spaces
***REMOVED***

  spacesAndCommentsFromStart(tokens) ***REMOVED***
    let next
    let spaces = ''
    while (tokens.length) ***REMOVED***
      next = tokens[0][0]
      if (next !== 'space' && next !== 'comment') break
      spaces += tokens.shift()[1]
***REMOVED***
    return spaces
***REMOVED***

  spacesFromEnd(tokens) ***REMOVED***
    let lastTokenType
    let spaces = ''
    while (tokens.length) ***REMOVED***
      lastTokenType = tokens[tokens.length - 1][0]
      if (lastTokenType !== 'space') break
      spaces = tokens.pop()[1] + spaces
***REMOVED***
    return spaces
***REMOVED***

  stringFrom(tokens, from) ***REMOVED***
    let result = ''
    for (let i = from; i < tokens.length; i++) ***REMOVED***
      result += tokens[i][1]
***REMOVED***
    tokens.splice(from, tokens.length - from)
    return result
***REMOVED***

  colon(tokens) ***REMOVED***
    let brackets = 0
    let token, type, prev
    for (let [i, element] of tokens.entries()) ***REMOVED***
      token = element
      type = token[0]

      if (type === '(') ***REMOVED***
        brackets += 1
  ***REMOVED***
      if (type === ')') ***REMOVED***
        brackets -= 1
  ***REMOVED***
      if (brackets === 0 && type === ':') ***REMOVED***
        if (!prev) ***REMOVED***
          this.doubleColon(token)
    ***REMOVED*** else if (prev[0] === 'word' && prev[1] === 'progid') ***REMOVED***
          continue
    ***REMOVED*** else ***REMOVED***
          return i
    ***REMOVED***
  ***REMOVED***

      prev = token
***REMOVED***
    return false
***REMOVED***

  // Errors

  unclosedBracket(bracket) ***REMOVED***
    throw this.input.error(
      'Unclosed bracket',
      ***REMOVED*** offset: bracket[2] ***REMOVED***,
      ***REMOVED*** offset: bracket[2] + 1 ***REMOVED***
    )
***REMOVED***

  unknownWord(tokens) ***REMOVED***
    throw this.input.error(
      'Unknown word',
      ***REMOVED*** offset: tokens[0][2] ***REMOVED***,
      ***REMOVED*** offset: tokens[0][2] + tokens[0][1].length ***REMOVED***
    )
***REMOVED***

  unexpectedClose(token) ***REMOVED***
    throw this.input.error(
      'Unexpected ***REMOVED***',
      ***REMOVED*** offset: token[2] ***REMOVED***,
      ***REMOVED*** offset: token[2] + 1 ***REMOVED***
    )
***REMOVED***

  unclosedBlock() ***REMOVED***
    let pos = this.current.source.start
    throw this.input.error('Unclosed block', pos.line, pos.column)
***REMOVED***

  doubleColon(token) ***REMOVED***
    throw this.input.error(
      'Double colon',
      ***REMOVED*** offset: token[2] ***REMOVED***,
      ***REMOVED*** offset: token[2] + token[1].length ***REMOVED***
    )
***REMOVED***

  unnamedAtrule(node, token) ***REMOVED***
    throw this.input.error(
      'At-rule without name',
      ***REMOVED*** offset: token[2] ***REMOVED***,
      ***REMOVED*** offset: token[2] + token[1].length ***REMOVED***
    )
***REMOVED***

  precheckMissedSemicolon(/* tokens */) ***REMOVED***
    // Hook for Safe Parser
***REMOVED***

  checkMissedSemicolon(tokens) ***REMOVED***
    let colon = this.colon(tokens)
    if (colon === false) return

    let founded = 0
    let token
    for (let j = colon - 1; j >= 0; j--) ***REMOVED***
      token = tokens[j]
      if (token[0] !== 'space') ***REMOVED***
        founded += 1
        if (founded === 2) break
  ***REMOVED***
***REMOVED***
    // If the token is a word, e.g. `!important`, `red` or any other valid property's value.
    // Then we need to return the colon after that word token. [3] is the "end" colon of that word.
    // And because we need it after that one we do +1 to get the next one.
    throw this.input.error(
      'Missed semicolon',
      token[0] === 'word' ? token[3] + 1 : token[2]
    )
***REMOVED***
***REMOVED***

module.exports = Parser
