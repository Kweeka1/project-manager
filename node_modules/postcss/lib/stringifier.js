'use strict'

const DEFAULT_RAW = ***REMOVED***
  colon: ': ',
  indent: '    ',
  beforeDecl: '\n',
  beforeRule: '\n',
  beforeOpen: ' ',
  beforeClose: '\n',
  beforeComment: '\n',
  after: '\n',
  emptyBody: '',
  commentLeft: ' ',
  commentRight: ' ',
  semicolon: false
***REMOVED***

function capitalize(str) ***REMOVED***
  return str[0].toUpperCase() + str.slice(1)
***REMOVED***

class Stringifier ***REMOVED***
  constructor(builder) ***REMOVED***
    this.builder = builder
***REMOVED***

  stringify(node, semicolon) ***REMOVED***
    /* c8 ignore start */
    if (!this[node.type]) ***REMOVED***
      throw new Error(
        'Unknown AST node type ' +
          node.type +
          '. ' +
          'Maybe you need to change PostCSS stringifier.'
      )
***REMOVED***
    /* c8 ignore stop */
    this[node.type](node, semicolon)
***REMOVED***

  document(node) ***REMOVED***
    this.body(node)
***REMOVED***

  root(node) ***REMOVED***
    this.body(node)
    if (node.raws.after) this.builder(node.raws.after)
***REMOVED***

  comment(node) ***REMOVED***
    let left = this.raw(node, 'left', 'commentLeft')
    let right = this.raw(node, 'right', 'commentRight')
    this.builder('/*' + left + node.text + right + '*/', node)
***REMOVED***

  decl(node, semicolon) ***REMOVED***
    let between = this.raw(node, 'between', 'colon')
    let string = node.prop + between + this.rawValue(node, 'value')

    if (node.important) ***REMOVED***
      string += node.raws.important || ' !important'
***REMOVED***

    if (semicolon) string += ';'
    this.builder(string, node)
***REMOVED***

  rule(node) ***REMOVED***
    this.block(node, this.rawValue(node, 'selector'))
    if (node.raws.ownSemicolon) ***REMOVED***
      this.builder(node.raws.ownSemicolon, node, 'end')
***REMOVED***
***REMOVED***

  atrule(node, semicolon) ***REMOVED***
    let name = '@' + node.name
    let params = node.params ? this.rawValue(node, 'params') : ''

    if (typeof node.raws.afterName !== 'undefined') ***REMOVED***
      name += node.raws.afterName
***REMOVED*** else if (params) ***REMOVED***
      name += ' '
***REMOVED***

    if (node.nodes) ***REMOVED***
      this.block(node, name + params)
***REMOVED*** else ***REMOVED***
      let end = (node.raws.between || '') + (semicolon ? ';' : '')
      this.builder(name + params + end, node)
***REMOVED***
***REMOVED***

  body(node) ***REMOVED***
    let last = node.nodes.length - 1
    while (last > 0) ***REMOVED***
      if (node.nodes[last].type !== 'comment') break
      last -= 1
***REMOVED***

    let semicolon = this.raw(node, 'semicolon')
    for (let i = 0; i < node.nodes.length; i++) ***REMOVED***
      let child = node.nodes[i]
      let before = this.raw(child, 'before')
      if (before) this.builder(before)
      this.stringify(child, last !== i || semicolon)
***REMOVED***
***REMOVED***

  block(node, start) ***REMOVED***
    let between = this.raw(node, 'between', 'beforeOpen')
    this.builder(start + between + '***REMOVED***', node, 'start')

    let after
    if (node.nodes && node.nodes.length) ***REMOVED***
      this.body(node)
      after = this.raw(node, 'after')
***REMOVED*** else ***REMOVED***
      after = this.raw(node, 'after', 'emptyBody')
***REMOVED***

    if (after) this.builder(after)
    this.builder('***REMOVED***', node, 'end')
***REMOVED***

  raw(node, own, detect) ***REMOVED***
    let value
    if (!detect) detect = own

    // Already had
    if (own) ***REMOVED***
      value = node.raws[own]
      if (typeof value !== 'undefined') return value
***REMOVED***

    let parent = node.parent

    if (detect === 'before') ***REMOVED***
      // Hack for first rule in CSS
      if (!parent || (parent.type === 'root' && parent.first === node)) ***REMOVED***
        return ''
  ***REMOVED***

      // `root` nodes in `document` should use only their own raws
      if (parent && parent.type === 'document') ***REMOVED***
        return ''
  ***REMOVED***
***REMOVED***

    // Floating child without parent
    if (!parent) return DEFAULT_RAW[detect]

    // Detect style by other nodes
    let root = node.root()
    if (!root.rawCache) root.rawCache = ***REMOVED******REMOVED***
    if (typeof root.rawCache[detect] !== 'undefined') ***REMOVED***
      return root.rawCache[detect]
***REMOVED***

    if (detect === 'before' || detect === 'after') ***REMOVED***
      return this.beforeAfter(node, detect)
***REMOVED*** else ***REMOVED***
      let method = 'raw' + capitalize(detect)
      if (this[method]) ***REMOVED***
        value = this[method](root, node)
  ***REMOVED*** else ***REMOVED***
        root.walk(i => ***REMOVED***
          value = i.raws[own]
          if (typeof value !== 'undefined') return false
    ***REMOVED***)
  ***REMOVED***
***REMOVED***

    if (typeof value === 'undefined') value = DEFAULT_RAW[detect]

    root.rawCache[detect] = value
    return value
***REMOVED***

  rawSemicolon(root) ***REMOVED***
    let value
    root.walk(i => ***REMOVED***
      if (i.nodes && i.nodes.length && i.last.type === 'decl') ***REMOVED***
        value = i.raws.semicolon
        if (typeof value !== 'undefined') return false
  ***REMOVED***
***REMOVED***)
    return value
***REMOVED***

  rawEmptyBody(root) ***REMOVED***
    let value
    root.walk(i => ***REMOVED***
      if (i.nodes && i.nodes.length === 0) ***REMOVED***
        value = i.raws.after
        if (typeof value !== 'undefined') return false
  ***REMOVED***
***REMOVED***)
    return value
***REMOVED***

  rawIndent(root) ***REMOVED***
    if (root.raws.indent) return root.raws.indent
    let value
    root.walk(i => ***REMOVED***
      let p = i.parent
      if (p && p !== root && p.parent && p.parent === root) ***REMOVED***
        if (typeof i.raws.before !== 'undefined') ***REMOVED***
          let parts = i.raws.before.split('\n')
          value = parts[parts.length - 1]
          value = value.replace(/\S/g, '')
          return false
    ***REMOVED***
  ***REMOVED***
***REMOVED***)
    return value
***REMOVED***

  rawBeforeComment(root, node) ***REMOVED***
    let value
    root.walkComments(i => ***REMOVED***
      if (typeof i.raws.before !== 'undefined') ***REMOVED***
        value = i.raws.before
        if (value.includes('\n')) ***REMOVED***
          value = value.replace(/[^\n]+$/, '')
    ***REMOVED***
        return false
  ***REMOVED***
***REMOVED***)
    if (typeof value === 'undefined') ***REMOVED***
      value = this.raw(node, null, 'beforeDecl')
***REMOVED*** else if (value) ***REMOVED***
      value = value.replace(/\S/g, '')
***REMOVED***
    return value
***REMOVED***

  rawBeforeDecl(root, node) ***REMOVED***
    let value
    root.walkDecls(i => ***REMOVED***
      if (typeof i.raws.before !== 'undefined') ***REMOVED***
        value = i.raws.before
        if (value.includes('\n')) ***REMOVED***
          value = value.replace(/[^\n]+$/, '')
    ***REMOVED***
        return false
  ***REMOVED***
***REMOVED***)
    if (typeof value === 'undefined') ***REMOVED***
      value = this.raw(node, null, 'beforeRule')
***REMOVED*** else if (value) ***REMOVED***
      value = value.replace(/\S/g, '')
***REMOVED***
    return value
***REMOVED***

  rawBeforeRule(root) ***REMOVED***
    let value
    root.walk(i => ***REMOVED***
      if (i.nodes && (i.parent !== root || root.first !== i)) ***REMOVED***
        if (typeof i.raws.before !== 'undefined') ***REMOVED***
          value = i.raws.before
          if (value.includes('\n')) ***REMOVED***
            value = value.replace(/[^\n]+$/, '')
      ***REMOVED***
          return false
    ***REMOVED***
  ***REMOVED***
***REMOVED***)
    if (value) value = value.replace(/\S/g, '')
    return value
***REMOVED***

  rawBeforeClose(root) ***REMOVED***
    let value
    root.walk(i => ***REMOVED***
      if (i.nodes && i.nodes.length > 0) ***REMOVED***
        if (typeof i.raws.after !== 'undefined') ***REMOVED***
          value = i.raws.after
          if (value.includes('\n')) ***REMOVED***
            value = value.replace(/[^\n]+$/, '')
      ***REMOVED***
          return false
    ***REMOVED***
  ***REMOVED***
***REMOVED***)
    if (value) value = value.replace(/\S/g, '')
    return value
***REMOVED***

  rawBeforeOpen(root) ***REMOVED***
    let value
    root.walk(i => ***REMOVED***
      if (i.type !== 'decl') ***REMOVED***
        value = i.raws.between
        if (typeof value !== 'undefined') return false
  ***REMOVED***
***REMOVED***)
    return value
***REMOVED***

  rawColon(root) ***REMOVED***
    let value
    root.walkDecls(i => ***REMOVED***
      if (typeof i.raws.between !== 'undefined') ***REMOVED***
        value = i.raws.between.replace(/[^\s:]/g, '')
        return false
  ***REMOVED***
***REMOVED***)
    return value
***REMOVED***

  beforeAfter(node, detect) ***REMOVED***
    let value
    if (node.type === 'decl') ***REMOVED***
      value = this.raw(node, null, 'beforeDecl')
***REMOVED*** else if (node.type === 'comment') ***REMOVED***
      value = this.raw(node, null, 'beforeComment')
***REMOVED*** else if (detect === 'before') ***REMOVED***
      value = this.raw(node, null, 'beforeRule')
***REMOVED*** else ***REMOVED***
      value = this.raw(node, null, 'beforeClose')
***REMOVED***

    let buf = node.parent
    let depth = 0
    while (buf && buf.type !== 'root') ***REMOVED***
      depth += 1
      buf = buf.parent
***REMOVED***

    if (value.includes('\n')) ***REMOVED***
      let indent = this.raw(node, null, 'indent')
      if (indent.length) ***REMOVED***
        for (let step = 0; step < depth; step++) value += indent
  ***REMOVED***
***REMOVED***

    return value
***REMOVED***

  rawValue(node, prop) ***REMOVED***
    let value = node[prop]
    let raw = node.raws[prop]
    if (raw && raw.value === value) ***REMOVED***
      return raw.raw
***REMOVED***

    return value
***REMOVED***
***REMOVED***

module.exports = Stringifier
Stringifier.default = Stringifier
