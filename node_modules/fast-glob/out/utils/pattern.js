"use strict";
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;
const path = require("path");
const globParent = require("glob-parent");
const micromatch = require("micromatch");
const GLOBSTAR = '**';
const ESCAPE_SYMBOL = '\\';
const COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
const REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
const REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
const GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
const BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
function isStaticPattern(pattern, options = ***REMOVED******REMOVED***) ***REMOVED***
    return !isDynamicPattern(pattern, options);
***REMOVED***
exports.isStaticPattern = isStaticPattern;
function isDynamicPattern(pattern, options = ***REMOVED******REMOVED***) ***REMOVED***
    /**
     * A special case with an empty string is necessary for matching patterns that start with a forward slash.
     * An empty string cannot be a dynamic pattern.
     * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.
     */
    if (pattern === '') ***REMOVED***
        return false;
***REMOVED***
    /**
     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check
     * filepath directly (without read directory).
     */
    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) ***REMOVED***
        return true;
***REMOVED***
    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) ***REMOVED***
        return true;
***REMOVED***
    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) ***REMOVED***
        return true;
***REMOVED***
    if (options.braceExpansion !== false && hasBraceExpansion(pattern)) ***REMOVED***
        return true;
***REMOVED***
    return false;
***REMOVED***
exports.isDynamicPattern = isDynamicPattern;
function hasBraceExpansion(pattern) ***REMOVED***
    const openingBraceIndex = pattern.indexOf('***REMOVED***');
    if (openingBraceIndex === -1) ***REMOVED***
        return false;
***REMOVED***
    const closingBraceIndex = pattern.indexOf('***REMOVED***', openingBraceIndex + 1);
    if (closingBraceIndex === -1) ***REMOVED***
        return false;
***REMOVED***
    const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
    return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
***REMOVED***
function convertToPositivePattern(pattern) ***REMOVED***
    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
***REMOVED***
exports.convertToPositivePattern = convertToPositivePattern;
function convertToNegativePattern(pattern) ***REMOVED***
    return '!' + pattern;
***REMOVED***
exports.convertToNegativePattern = convertToNegativePattern;
function isNegativePattern(pattern) ***REMOVED***
    return pattern.startsWith('!') && pattern[1] !== '(';
***REMOVED***
exports.isNegativePattern = isNegativePattern;
function isPositivePattern(pattern) ***REMOVED***
    return !isNegativePattern(pattern);
***REMOVED***
exports.isPositivePattern = isPositivePattern;
function getNegativePatterns(patterns) ***REMOVED***
    return patterns.filter(isNegativePattern);
***REMOVED***
exports.getNegativePatterns = getNegativePatterns;
function getPositivePatterns(patterns) ***REMOVED***
    return patterns.filter(isPositivePattern);
***REMOVED***
exports.getPositivePatterns = getPositivePatterns;
/**
 * Returns patterns that can be applied inside the current directory.
 *
 * @example
 * // ['./*', '*', 'a/*']
 * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])
 */
function getPatternsInsideCurrentDirectory(patterns) ***REMOVED***
    return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
***REMOVED***
exports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
/**
 * Returns patterns to be expanded relative to (outside) the current directory.
 *
 * @example
 * // ['../*', './../*']
 * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])
 */
function getPatternsOutsideCurrentDirectory(patterns) ***REMOVED***
    return patterns.filter(isPatternRelatedToParentDirectory);
***REMOVED***
exports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
function isPatternRelatedToParentDirectory(pattern) ***REMOVED***
    return pattern.startsWith('..') || pattern.startsWith('./..');
***REMOVED***
exports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
function getBaseDirectory(pattern) ***REMOVED***
    return globParent(pattern, ***REMOVED*** flipBackslashes: false ***REMOVED***);
***REMOVED***
exports.getBaseDirectory = getBaseDirectory;
function hasGlobStar(pattern) ***REMOVED***
    return pattern.includes(GLOBSTAR);
***REMOVED***
exports.hasGlobStar = hasGlobStar;
function endsWithSlashGlobStar(pattern) ***REMOVED***
    return pattern.endsWith('/' + GLOBSTAR);
***REMOVED***
exports.endsWithSlashGlobStar = endsWithSlashGlobStar;
function isAffectDepthOfReadingPattern(pattern) ***REMOVED***
    const basename = path.basename(pattern);
    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
***REMOVED***
exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
function expandPatternsWithBraceExpansion(patterns) ***REMOVED***
    return patterns.reduce((collection, pattern) => ***REMOVED***
        return collection.concat(expandBraceExpansion(pattern));
***REMOVED***, []);
***REMOVED***
exports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
function expandBraceExpansion(pattern) ***REMOVED***
    return micromatch.braces(pattern, ***REMOVED***
        expand: true,
        nodupes: true
***REMOVED***);
***REMOVED***
exports.expandBraceExpansion = expandBraceExpansion;
function getPatternParts(pattern, options) ***REMOVED***
    let ***REMOVED*** parts ***REMOVED*** = micromatch.scan(pattern, Object.assign(Object.assign(***REMOVED******REMOVED***, options), ***REMOVED*** parts: true ***REMOVED***));
    /**
     * The scan method returns an empty array in some cases.
     * See micromatch/picomatch#58 for more details.
     */
    if (parts.length === 0) ***REMOVED***
        parts = [pattern];
***REMOVED***
    /**
     * The scan method does not return an empty part for the pattern with a forward slash.
     * This is another part of micromatch/picomatch#58.
     */
    if (parts[0].startsWith('/')) ***REMOVED***
        parts[0] = parts[0].slice(1);
        parts.unshift('');
***REMOVED***
    return parts;
***REMOVED***
exports.getPatternParts = getPatternParts;
function makeRe(pattern, options) ***REMOVED***
    return micromatch.makeRe(pattern, options);
***REMOVED***
exports.makeRe = makeRe;
function convertPatternsToRe(patterns, options) ***REMOVED***
    return patterns.map((pattern) => makeRe(pattern, options));
***REMOVED***
exports.convertPatternsToRe = convertPatternsToRe;
function matchAny(entry, patternsRe) ***REMOVED***
    return patternsRe.some((patternRe) => patternRe.test(entry));
***REMOVED***
exports.matchAny = matchAny;
