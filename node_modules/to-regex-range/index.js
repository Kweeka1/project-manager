/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

const isNumber = require('is-number');

const toRegexRange = (min, max, options) => ***REMOVED***
  if (isNumber(min) === false) ***REMOVED***
    throw new TypeError('toRegexRange: expected the first argument to be a number');
***REMOVED***

  if (max === void 0 || min === max) ***REMOVED***
    return String(min);
***REMOVED***

  if (isNumber(max) === false) ***REMOVED***
    throw new TypeError('toRegexRange: expected the second argument to be a number.');
***REMOVED***

  let opts = ***REMOVED*** relaxZeros: true, ...options ***REMOVED***;
  if (typeof opts.strictZeros === 'boolean') ***REMOVED***
    opts.relaxZeros = opts.strictZeros === false;
***REMOVED***

  let relax = String(opts.relaxZeros);
  let shorthand = String(opts.shorthand);
  let capture = String(opts.capture);
  let wrap = String(opts.wrap);
  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;

  if (toRegexRange.cache.hasOwnProperty(cacheKey)) ***REMOVED***
    return toRegexRange.cache[cacheKey].result;
***REMOVED***

  let a = Math.min(min, max);
  let b = Math.max(min, max);

  if (Math.abs(a - b) === 1) ***REMOVED***
    let result = min + '|' + max;
    if (opts.capture) ***REMOVED***
      return `($***REMOVED***result***REMOVED***)`;
***REMOVED***
    if (opts.wrap === false) ***REMOVED***
      return result;
***REMOVED***
    return `(?:$***REMOVED***result***REMOVED***)`;
***REMOVED***

  let isPadded = hasPadding(min) || hasPadding(max);
  let state = ***REMOVED*** min, max, a, b ***REMOVED***;
  let positives = [];
  let negatives = [];

  if (isPadded) ***REMOVED***
    state.isPadded = isPadded;
    state.maxLen = String(state.max).length;
***REMOVED***

  if (a < 0) ***REMOVED***
    let newMin = b < 0 ? Math.abs(b) : 1;
    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
    a = state.a = 0;
***REMOVED***

  if (b >= 0) ***REMOVED***
    positives = splitToPatterns(a, b, state, opts);
***REMOVED***

  state.negatives = negatives;
  state.positives = positives;
  state.result = collatePatterns(negatives, positives, opts);

  if (opts.capture === true) ***REMOVED***
    state.result = `($***REMOVED***state.result***REMOVED***)`;
***REMOVED*** else if (opts.wrap !== false && (positives.length + negatives.length) > 1) ***REMOVED***
    state.result = `(?:$***REMOVED***state.result***REMOVED***)`;
***REMOVED***

  toRegexRange.cache[cacheKey] = state;
  return state.result;
***REMOVED***;

function collatePatterns(neg, pos, options) ***REMOVED***
  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];
  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];
  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];
  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join('|');
***REMOVED***

function splitToRanges(min, max) ***REMOVED***
  let nines = 1;
  let zeros = 1;

  let stop = countNines(min, nines);
  let stops = new Set([max]);

  while (min <= stop && stop <= max) ***REMOVED***
    stops.add(stop);
    nines += 1;
    stop = countNines(min, nines);
***REMOVED***

  stop = countZeros(max + 1, zeros) - 1;

  while (min < stop && stop <= max) ***REMOVED***
    stops.add(stop);
    zeros += 1;
    stop = countZeros(max + 1, zeros) - 1;
***REMOVED***

  stops = [...stops];
  stops.sort(compare);
  return stops;
***REMOVED***

/**
 * Convert a range to a regex pattern
 * @param ***REMOVED***Number***REMOVED*** `start`
 * @param ***REMOVED***Number***REMOVED*** `stop`
 * @return ***REMOVED***String***REMOVED***
 */

function rangeToPattern(start, stop, options) ***REMOVED***
  if (start === stop) ***REMOVED***
    return ***REMOVED*** pattern: start, count: [], digits: 0 ***REMOVED***;
***REMOVED***

  let zipped = zip(start, stop);
  let digits = zipped.length;
  let pattern = '';
  let count = 0;

  for (let i = 0; i < digits; i++) ***REMOVED***
    let [startDigit, stopDigit] = zipped[i];

    if (startDigit === stopDigit) ***REMOVED***
      pattern += startDigit;

***REMOVED*** else if (startDigit !== '0' || stopDigit !== '9') ***REMOVED***
      pattern += toCharacterClass(startDigit, stopDigit, options);

***REMOVED*** else ***REMOVED***
      count++;
***REMOVED***
***REMOVED***

  if (count) ***REMOVED***
    pattern += options.shorthand === true ? '\\d' : '[0-9]';
***REMOVED***

  return ***REMOVED*** pattern, count: [count], digits ***REMOVED***;
***REMOVED***

function splitToPatterns(min, max, tok, options) ***REMOVED***
  let ranges = splitToRanges(min, max);
  let tokens = [];
  let start = min;
  let prev;

  for (let i = 0; i < ranges.length; i++) ***REMOVED***
    let max = ranges[i];
    let obj = rangeToPattern(String(start), String(max), options);
    let zeros = '';

    if (!tok.isPadded && prev && prev.pattern === obj.pattern) ***REMOVED***
      if (prev.count.length > 1) ***REMOVED***
        prev.count.pop();
  ***REMOVED***

      prev.count.push(obj.count[0]);
      prev.string = prev.pattern + toQuantifier(prev.count);
      start = max + 1;
      continue;
***REMOVED***

    if (tok.isPadded) ***REMOVED***
      zeros = padZeros(max, tok, options);
***REMOVED***

    obj.string = zeros + obj.pattern + toQuantifier(obj.count);
    tokens.push(obj);
    start = max + 1;
    prev = obj;
***REMOVED***

  return tokens;
***REMOVED***

function filterPatterns(arr, comparison, prefix, intersection, options) ***REMOVED***
  let result = [];

  for (let ele of arr) ***REMOVED***
    let ***REMOVED*** string ***REMOVED*** = ele;

    // only push if _both_ are negative...
    if (!intersection && !contains(comparison, 'string', string)) ***REMOVED***
      result.push(prefix + string);
***REMOVED***

    // or _both_ are positive
    if (intersection && contains(comparison, 'string', string)) ***REMOVED***
      result.push(prefix + string);
***REMOVED***
***REMOVED***
  return result;
***REMOVED***

/**
 * Zip strings
 */

function zip(a, b) ***REMOVED***
  let arr = [];
  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
  return arr;
***REMOVED***

function compare(a, b) ***REMOVED***
  return a > b ? 1 : b > a ? -1 : 0;
***REMOVED***

function contains(arr, key, val) ***REMOVED***
  return arr.some(ele => ele[key] === val);
***REMOVED***

function countNines(min, len) ***REMOVED***
  return Number(String(min).slice(0, -len) + '9'.repeat(len));
***REMOVED***

function countZeros(integer, zeros) ***REMOVED***
  return integer - (integer % Math.pow(10, zeros));
***REMOVED***

function toQuantifier(digits) ***REMOVED***
  let [start = 0, stop = ''] = digits;
  if (stop || start > 1) ***REMOVED***
    return `***REMOVED***$***REMOVED***start + (stop ? ',' + stop : '')***REMOVED******REMOVED***`;
***REMOVED***
  return '';
***REMOVED***

function toCharacterClass(a, b, options) ***REMOVED***
  return `[$***REMOVED***a***REMOVED***$***REMOVED***(b - a === 1) ? '' : '-'***REMOVED***$***REMOVED***b***REMOVED***]`;
***REMOVED***

function hasPadding(str) ***REMOVED***
  return /^-?(0+)\d/.test(str);
***REMOVED***

function padZeros(value, tok, options) ***REMOVED***
  if (!tok.isPadded) ***REMOVED***
    return value;
***REMOVED***

  let diff = Math.abs(tok.maxLen - String(value).length);
  let relax = options.relaxZeros !== false;

  switch (diff) ***REMOVED***
    case 0:
      return '';
    case 1:
      return relax ? '0?' : '0';
    case 2:
      return relax ? '0***REMOVED***0,2***REMOVED***' : '00';
    default: ***REMOVED***
      return relax ? `0***REMOVED***0,$***REMOVED***diff***REMOVED******REMOVED***` : `0***REMOVED***$***REMOVED***diff***REMOVED******REMOVED***`;
***REMOVED***
***REMOVED***
***REMOVED***

/**
 * Cache
 */

toRegexRange.cache = ***REMOVED******REMOVED***;
toRegexRange.clearCache = () => (toRegexRange.cache = ***REMOVED******REMOVED***);

/**
 * Expose `toRegexRange`
 */

module.exports = toRegexRange;
