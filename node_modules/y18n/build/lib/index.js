let shim;
class Y18N ***REMOVED***
    constructor(opts) ***REMOVED***
        // configurable options.
        opts = opts || ***REMOVED******REMOVED***;
        this.directory = opts.directory || './locales';
        this.updateFiles = typeof opts.updateFiles === 'boolean' ? opts.updateFiles : true;
        this.locale = opts.locale || 'en';
        this.fallbackToLanguage = typeof opts.fallbackToLanguage === 'boolean' ? opts.fallbackToLanguage : true;
        // internal stuff.
        this.cache = Object.create(null);
        this.writeQueue = [];
***REMOVED***
    __(...args) ***REMOVED***
        if (typeof arguments[0] !== 'string') ***REMOVED***
            return this._taggedLiteral(arguments[0], ...arguments);
    ***REMOVED***
        const str = args.shift();
        let cb = function () ***REMOVED*** ***REMOVED***; // start with noop.
        if (typeof args[args.length - 1] === 'function')
            cb = args.pop();
        cb = cb || function () ***REMOVED*** ***REMOVED***; // noop.
        if (!this.cache[this.locale])
            this._readLocaleFile();
        // we've observed a new string, update the language file.
        if (!this.cache[this.locale][str] && this.updateFiles) ***REMOVED***
            this.cache[this.locale][str] = str;
            // include the current directory and locale,
            // since these values could change before the
            // write is performed.
            this._enqueueWrite(***REMOVED***
                directory: this.directory,
                locale: this.locale,
                cb
        ***REMOVED***);
    ***REMOVED***
        else ***REMOVED***
            cb();
    ***REMOVED***
        return shim.format.apply(shim.format, [this.cache[this.locale][str] || str].concat(args));
***REMOVED***
    __n() ***REMOVED***
        const args = Array.prototype.slice.call(arguments);
        const singular = args.shift();
        const plural = args.shift();
        const quantity = args.shift();
        let cb = function () ***REMOVED*** ***REMOVED***; // start with noop.
        if (typeof args[args.length - 1] === 'function')
            cb = args.pop();
        if (!this.cache[this.locale])
            this._readLocaleFile();
        let str = quantity === 1 ? singular : plural;
        if (this.cache[this.locale][singular]) ***REMOVED***
            const entry = this.cache[this.locale][singular];
            str = entry[quantity === 1 ? 'one' : 'other'];
    ***REMOVED***
        // we've observed a new string, update the language file.
        if (!this.cache[this.locale][singular] && this.updateFiles) ***REMOVED***
            this.cache[this.locale][singular] = ***REMOVED***
                one: singular,
                other: plural
        ***REMOVED***;
            // include the current directory and locale,
            // since these values could change before the
            // write is performed.
            this._enqueueWrite(***REMOVED***
                directory: this.directory,
                locale: this.locale,
                cb
        ***REMOVED***);
    ***REMOVED***
        else ***REMOVED***
            cb();
    ***REMOVED***
        // if a %d placeholder is provided, add quantity
        // to the arguments expanded by util.format.
        const values = [str];
        if (~str.indexOf('%d'))
            values.push(quantity);
        return shim.format.apply(shim.format, values.concat(args));
***REMOVED***
    setLocale(locale) ***REMOVED***
        this.locale = locale;
***REMOVED***
    getLocale() ***REMOVED***
        return this.locale;
***REMOVED***
    updateLocale(obj) ***REMOVED***
        if (!this.cache[this.locale])
            this._readLocaleFile();
        for (const key in obj) ***REMOVED***
            if (Object.prototype.hasOwnProperty.call(obj, key)) ***REMOVED***
                this.cache[this.locale][key] = obj[key];
        ***REMOVED***
    ***REMOVED***
***REMOVED***
    _taggedLiteral(parts, ...args) ***REMOVED***
        let str = '';
        parts.forEach(function (part, i) ***REMOVED***
            const arg = args[i + 1];
            str += part;
            if (typeof arg !== 'undefined') ***REMOVED***
                str += '%s';
        ***REMOVED***
    ***REMOVED***);
        return this.__.apply(this, [str].concat([].slice.call(args, 1)));
***REMOVED***
    _enqueueWrite(work) ***REMOVED***
        this.writeQueue.push(work);
        if (this.writeQueue.length === 1)
            this._processWriteQueue();
***REMOVED***
    _processWriteQueue() ***REMOVED***
        const _this = this;
        const work = this.writeQueue[0];
        // destructure the enqueued work.
        const directory = work.directory;
        const locale = work.locale;
        const cb = work.cb;
        const languageFile = this._resolveLocaleFile(directory, locale);
        const serializedLocale = JSON.stringify(this.cache[locale], null, 2);
        shim.fs.writeFile(languageFile, serializedLocale, 'utf-8', function (err) ***REMOVED***
            _this.writeQueue.shift();
            if (_this.writeQueue.length > 0)
                _this._processWriteQueue();
            cb(err);
    ***REMOVED***);
***REMOVED***
    _readLocaleFile() ***REMOVED***
        let localeLookup = ***REMOVED******REMOVED***;
        const languageFile = this._resolveLocaleFile(this.directory, this.locale);
        try ***REMOVED***
            // When using a bundler such as webpack, readFileSync may not be defined:
            if (shim.fs.readFileSync) ***REMOVED***
                localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, 'utf-8'));
        ***REMOVED***
    ***REMOVED***
        catch (err) ***REMOVED***
            if (err instanceof SyntaxError) ***REMOVED***
                err.message = 'syntax error in ' + languageFile;
        ***REMOVED***
            if (err.code === 'ENOENT')
                localeLookup = ***REMOVED******REMOVED***;
            else
                throw err;
    ***REMOVED***
        this.cache[this.locale] = localeLookup;
***REMOVED***
    _resolveLocaleFile(directory, locale) ***REMOVED***
        let file = shim.resolve(directory, './', locale + '.json');
        if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf('_')) ***REMOVED***
            // attempt fallback to language only
            const languageFile = shim.resolve(directory, './', locale.split('_')[0] + '.json');
            if (this._fileExistsSync(languageFile))
                file = languageFile;
    ***REMOVED***
        return file;
***REMOVED***
    _fileExistsSync(file) ***REMOVED***
        return shim.exists(file);
***REMOVED***
***REMOVED***
export function y18n(opts, _shim) ***REMOVED***
    shim = _shim;
    const y18n = new Y18N(opts);
    return ***REMOVED***
        __: y18n.__.bind(y18n),
        __n: y18n.__n.bind(y18n),
        setLocale: y18n.setLocale.bind(y18n),
        getLocale: y18n.getLocale.bind(y18n),
        updateLocale: y18n.updateLocale.bind(y18n),
        locale: y18n.locale
***REMOVED***;
***REMOVED***
