/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

const util = require('util');
const toRegexRange = require('to-regex-range');

const isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);

const transform = toNumber => ***REMOVED***
  return value => toNumber === true ? Number(value) : String(value);
***REMOVED***;

const isValidValue = value => ***REMOVED***
  return typeof value === 'number' || (typeof value === 'string' && value !== '');
***REMOVED***;

const isNumber = num => Number.isInteger(+num);

const zeros = input => ***REMOVED***
  let value = `$***REMOVED***input***REMOVED***`;
  let index = -1;
  if (value[0] === '-') value = value.slice(1);
  if (value === '0') return false;
  while (value[++index] === '0');
  return index > 0;
***REMOVED***;

const stringify = (start, end, options) => ***REMOVED***
  if (typeof start === 'string' || typeof end === 'string') ***REMOVED***
    return true;
***REMOVED***
  return options.stringify === true;
***REMOVED***;

const pad = (input, maxLength, toNumber) => ***REMOVED***
  if (maxLength > 0) ***REMOVED***
    let dash = input[0] === '-' ? '-' : '';
    if (dash) input = input.slice(1);
    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));
***REMOVED***
  if (toNumber === false) ***REMOVED***
    return String(input);
***REMOVED***
  return input;
***REMOVED***;

const toMaxLen = (input, maxLength) => ***REMOVED***
  let negative = input[0] === '-' ? '-' : '';
  if (negative) ***REMOVED***
    input = input.slice(1);
    maxLength--;
***REMOVED***
  while (input.length < maxLength) input = '0' + input;
  return negative ? ('-' + input) : input;
***REMOVED***;

const toSequence = (parts, options) => ***REMOVED***
  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);

  let prefix = options.capture ? '' : '?:';
  let positives = '';
  let negatives = '';
  let result;

  if (parts.positives.length) ***REMOVED***
    positives = parts.positives.join('|');
***REMOVED***

  if (parts.negatives.length) ***REMOVED***
    negatives = `-($***REMOVED***prefix***REMOVED***$***REMOVED***parts.negatives.join('|')***REMOVED***)`;
***REMOVED***

  if (positives && negatives) ***REMOVED***
    result = `$***REMOVED***positives***REMOVED***|$***REMOVED***negatives***REMOVED***`;
***REMOVED*** else ***REMOVED***
    result = positives || negatives;
***REMOVED***

  if (options.wrap) ***REMOVED***
    return `($***REMOVED***prefix***REMOVED***$***REMOVED***result***REMOVED***)`;
***REMOVED***

  return result;
***REMOVED***;

const toRange = (a, b, isNumbers, options) => ***REMOVED***
  if (isNumbers) ***REMOVED***
    return toRegexRange(a, b, ***REMOVED*** wrap: false, ...options ***REMOVED***);
***REMOVED***

  let start = String.fromCharCode(a);
  if (a === b) return start;

  let stop = String.fromCharCode(b);
  return `[$***REMOVED***start***REMOVED***-$***REMOVED***stop***REMOVED***]`;
***REMOVED***;

const toRegex = (start, end, options) => ***REMOVED***
  if (Array.isArray(start)) ***REMOVED***
    let wrap = options.wrap === true;
    let prefix = options.capture ? '' : '?:';
    return wrap ? `($***REMOVED***prefix***REMOVED***$***REMOVED***start.join('|')***REMOVED***)` : start.join('|');
***REMOVED***
  return toRegexRange(start, end, options);
***REMOVED***;

const rangeError = (...args) => ***REMOVED***
  return new RangeError('Invalid range arguments: ' + util.inspect(...args));
***REMOVED***;

const invalidRange = (start, end, options) => ***REMOVED***
  if (options.strictRanges === true) throw rangeError([start, end]);
  return [];
***REMOVED***;

const invalidStep = (step, options) => ***REMOVED***
  if (options.strictRanges === true) ***REMOVED***
    throw new TypeError(`Expected step "$***REMOVED***step***REMOVED***" to be a number`);
***REMOVED***
  return [];
***REMOVED***;

const fillNumbers = (start, end, step = 1, options = ***REMOVED******REMOVED***) => ***REMOVED***
  let a = Number(start);
  let b = Number(end);

  if (!Number.isInteger(a) || !Number.isInteger(b)) ***REMOVED***
    if (options.strictRanges === true) throw rangeError([start, end]);
    return [];
***REMOVED***

  // fix negative zero
  if (a === 0) a = 0;
  if (b === 0) b = 0;

  let descending = a > b;
  let startString = String(start);
  let endString = String(end);
  let stepString = String(step);
  step = Math.max(Math.abs(step), 1);

  let padded = zeros(startString) || zeros(endString) || zeros(stepString);
  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
  let toNumber = padded === false && stringify(start, end, options) === false;
  let format = options.transform || transform(toNumber);

  if (options.toRegex && step === 1) ***REMOVED***
    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
***REMOVED***

  let parts = ***REMOVED*** negatives: [], positives: [] ***REMOVED***;
  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));
  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) ***REMOVED***
    if (options.toRegex === true && step > 1) ***REMOVED***
      push(a);
***REMOVED*** else ***REMOVED***
      range.push(pad(format(a, index), maxLen, toNumber));
***REMOVED***
    a = descending ? a - step : a + step;
    index++;
***REMOVED***

  if (options.toRegex === true) ***REMOVED***
    return step > 1
      ? toSequence(parts, options)
      : toRegex(range, null, ***REMOVED*** wrap: false, ...options ***REMOVED***);
***REMOVED***

  return range;
***REMOVED***;

const fillLetters = (start, end, step = 1, options = ***REMOVED******REMOVED***) => ***REMOVED***
  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) ***REMOVED***
    return invalidRange(start, end, options);
***REMOVED***


  let format = options.transform || (val => String.fromCharCode(val));
  let a = `$***REMOVED***start***REMOVED***`.charCodeAt(0);
  let b = `$***REMOVED***end***REMOVED***`.charCodeAt(0);

  let descending = a > b;
  let min = Math.min(a, b);
  let max = Math.max(a, b);

  if (options.toRegex && step === 1) ***REMOVED***
    return toRange(min, max, false, options);
***REMOVED***

  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) ***REMOVED***
    range.push(format(a, index));
    a = descending ? a - step : a + step;
    index++;
***REMOVED***

  if (options.toRegex === true) ***REMOVED***
    return toRegex(range, null, ***REMOVED*** wrap: false, options ***REMOVED***);
***REMOVED***

  return range;
***REMOVED***;

const fill = (start, end, step, options = ***REMOVED******REMOVED***) => ***REMOVED***
  if (end == null && isValidValue(start)) ***REMOVED***
    return [start];
***REMOVED***

  if (!isValidValue(start) || !isValidValue(end)) ***REMOVED***
    return invalidRange(start, end, options);
***REMOVED***

  if (typeof step === 'function') ***REMOVED***
    return fill(start, end, 1, ***REMOVED*** transform: step ***REMOVED***);
***REMOVED***

  if (isObject(step)) ***REMOVED***
    return fill(start, end, 0, step);
***REMOVED***

  let opts = ***REMOVED*** ...options ***REMOVED***;
  if (opts.capture === true) opts.wrap = true;
  step = step || opts.step || 1;

  if (!isNumber(step)) ***REMOVED***
    if (step != null && !isObject(step)) return invalidStep(step, opts);
    return fill(start, end, 1, step);
***REMOVED***

  if (isNumber(start) && isNumber(end)) ***REMOVED***
    return fillNumbers(start, end, step, opts);
***REMOVED***

  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
***REMOVED***;

module.exports = fill;
