'use strict'
/*
 * merge2
 * https://github.com/teambition/merge2
 *
 * Copyright (c) 2014-2020 Teambition
 * Licensed under the MIT license.
 */
const Stream = require('stream')
const PassThrough = Stream.PassThrough
const slice = Array.prototype.slice

module.exports = merge2

function merge2 () ***REMOVED***
  const streamsQueue = []
  const args = slice.call(arguments)
  let merging = false
  let options = args[args.length - 1]

  if (options && !Array.isArray(options) && options.pipe == null) ***REMOVED***
    args.pop()
***REMOVED*** else ***REMOVED***
    options = ***REMOVED******REMOVED***
***REMOVED***

  const doEnd = options.end !== false
  const doPipeError = options.pipeError === true
  if (options.objectMode == null) ***REMOVED***
    options.objectMode = true
***REMOVED***
  if (options.highWaterMark == null) ***REMOVED***
    options.highWaterMark = 64 * 1024
***REMOVED***
  const mergedStream = PassThrough(options)

  function addStream () ***REMOVED***
    for (let i = 0, len = arguments.length; i < len; i++) ***REMOVED***
      streamsQueue.push(pauseStreams(arguments[i], options))
***REMOVED***
    mergeStream()
    return this
***REMOVED***

  function mergeStream () ***REMOVED***
    if (merging) ***REMOVED***
      return
***REMOVED***
    merging = true

    let streams = streamsQueue.shift()
    if (!streams) ***REMOVED***
      process.nextTick(endStream)
      return
***REMOVED***
    if (!Array.isArray(streams)) ***REMOVED***
      streams = [streams]
***REMOVED***

    let pipesCount = streams.length + 1

    function next () ***REMOVED***
      if (--pipesCount > 0) ***REMOVED***
        return
  ***REMOVED***
      merging = false
      mergeStream()
***REMOVED***

    function pipe (stream) ***REMOVED***
      function onend () ***REMOVED***
        stream.removeListener('merge2UnpipeEnd', onend)
        stream.removeListener('end', onend)
        if (doPipeError) ***REMOVED***
          stream.removeListener('error', onerror)
    ***REMOVED***
        next()
  ***REMOVED***
      function onerror (err) ***REMOVED***
        mergedStream.emit('error', err)
  ***REMOVED***
      // skip ended stream
      if (stream._readableState.endEmitted) ***REMOVED***
        return next()
  ***REMOVED***

      stream.on('merge2UnpipeEnd', onend)
      stream.on('end', onend)

      if (doPipeError) ***REMOVED***
        stream.on('error', onerror)
  ***REMOVED***

      stream.pipe(mergedStream, ***REMOVED*** end: false ***REMOVED***)
      // compatible for old stream
      stream.resume()
***REMOVED***

    for (let i = 0; i < streams.length; i++) ***REMOVED***
      pipe(streams[i])
***REMOVED***

    next()
***REMOVED***

  function endStream () ***REMOVED***
    merging = false
    // emit 'queueDrain' when all streams merged.
    mergedStream.emit('queueDrain')
    if (doEnd) ***REMOVED***
      mergedStream.end()
***REMOVED***
***REMOVED***

  mergedStream.setMaxListeners(0)
  mergedStream.add = addStream
  mergedStream.on('unpipe', function (stream) ***REMOVED***
    stream.emit('merge2UnpipeEnd')
***REMOVED***)

  if (args.length) ***REMOVED***
    addStream.apply(null, args)
***REMOVED***
  return mergedStream
***REMOVED***

// check and pause streams for pipe.
function pauseStreams (streams, options) ***REMOVED***
  if (!Array.isArray(streams)) ***REMOVED***
    // Backwards-compat with old-style streams
    if (!streams._readableState && streams.pipe) ***REMOVED***
      streams = streams.pipe(PassThrough(options))
***REMOVED***
    if (!streams._readableState || !streams.pause || !streams.pipe) ***REMOVED***
      throw new Error('Only readable stream can be merged.')
***REMOVED***
    streams.pause()
***REMOVED*** else ***REMOVED***
    for (let i = 0, len = streams.length; i < len; i++) ***REMOVED***
      streams[i] = pauseStreams(streams[i], options)
***REMOVED***
***REMOVED***
  return streams
***REMOVED***
