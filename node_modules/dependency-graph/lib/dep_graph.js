/**
 * A simple dependency graph
 */

/**
 * Helper for creating a Topological Sort using Depth-First-Search on a set of edges.
 *
 * Detects cycles and throws an Error if one is detected (unless the "circular"
 * parameter is "true" in which case it ignores them).
 *
 * @param edges The set of edges to DFS through
 * @param leavesOnly Whether to only return "leaf" nodes (ones who have no edges)
 * @param result An array in which the results will be populated
 * @param circular A boolean to allow circular dependencies
 */
function createDFS(edges, leavesOnly, result, circular) ***REMOVED***
  var visited = ***REMOVED******REMOVED***;
  return function (start) ***REMOVED***
    if (visited[start]) ***REMOVED***
      return;
***REMOVED***
    var inCurrentPath = ***REMOVED******REMOVED***;
    var currentPath = [];
    var todo = []; // used as a stack
    todo.push(***REMOVED*** node: start, processed: false ***REMOVED***);
    while (todo.length > 0) ***REMOVED***
      var current = todo[todo.length - 1]; // peek at the todo stack
      var processed = current.processed;
      var node = current.node;
      if (!processed) ***REMOVED***
        // Haven't visited edges yet (visiting phase)
        if (visited[node]) ***REMOVED***
          todo.pop();
          continue;
    ***REMOVED*** else if (inCurrentPath[node]) ***REMOVED***
          // It's not a DAG
          if (circular) ***REMOVED***
            todo.pop();
            // If we're tolerating cycles, don't revisit the node
            continue;
      ***REMOVED***
          currentPath.push(node);
          throw new DepGraphCycleError(currentPath);
    ***REMOVED***

        inCurrentPath[node] = true;
        currentPath.push(node);
        var nodeEdges = edges[node];
        // (push edges onto the todo stack in reverse order to be order-compatible with the old DFS implementation)
        for (var i = nodeEdges.length - 1; i >= 0; i--) ***REMOVED***
          todo.push(***REMOVED*** node: nodeEdges[i], processed: false ***REMOVED***);
    ***REMOVED***
        current.processed = true;
  ***REMOVED*** else ***REMOVED***
        // Have visited edges (stack unrolling phase)
        todo.pop();
        currentPath.pop();
        inCurrentPath[node] = false;
        visited[node] = true;
        if (!leavesOnly || edges[node].length === 0) ***REMOVED***
          result.push(node);
    ***REMOVED***
  ***REMOVED***
***REMOVED***
***REMOVED***;
***REMOVED***

/**
 * Simple Dependency Graph
 */
var DepGraph = (exports.DepGraph = function DepGraph(opts) ***REMOVED***
  this.nodes = ***REMOVED******REMOVED***; // Node -> Node/Data (treated like a Set)
  this.outgoingEdges = ***REMOVED******REMOVED***; // Node -> [Dependency Node]
  this.incomingEdges = ***REMOVED******REMOVED***; // Node -> [Dependant Node]
  this.circular = opts && !!opts.circular; // Allows circular deps
***REMOVED***);
DepGraph.prototype = ***REMOVED***
  /**
   * The number of nodes in the graph.
   */
  size: function () ***REMOVED***
    return Object.keys(this.nodes).length;
***REMOVED***
  /**
   * Add a node to the dependency graph. If a node already exists, this method will do nothing.
   */
  addNode: function (node, data) ***REMOVED***
    if (!this.hasNode(node)) ***REMOVED***
      // Checking the arguments length allows the user to add a node with undefined data
      if (arguments.length === 2) ***REMOVED***
        this.nodes[node] = data;
  ***REMOVED*** else ***REMOVED***
        this.nodes[node] = node;
  ***REMOVED***
      this.outgoingEdges[node] = [];
      this.incomingEdges[node] = [];
***REMOVED***
***REMOVED***
  /**
   * Remove a node from the dependency graph. If a node does not exist, this method will do nothing.
   */
  removeNode: function (node) ***REMOVED***
    if (this.hasNode(node)) ***REMOVED***
      delete this.nodes[node];
      delete this.outgoingEdges[node];
      delete this.incomingEdges[node];
      [this.incomingEdges, this.outgoingEdges].forEach(function (edgeList) ***REMOVED***
        Object.keys(edgeList).forEach(function (key) ***REMOVED***
          var idx = edgeList[key].indexOf(node);
          if (idx >= 0) ***REMOVED***
            edgeList[key].splice(idx, 1);
      ***REMOVED***
    ***REMOVED***, this);
  ***REMOVED***);
***REMOVED***
***REMOVED***
  /**
   * Check if a node exists in the graph
   */
  hasNode: function (node) ***REMOVED***
    return this.nodes.hasOwnProperty(node);
***REMOVED***
  /**
   * Get the data associated with a node name
   */
  getNodeData: function (node) ***REMOVED***
    if (this.hasNode(node)) ***REMOVED***
      return this.nodes[node];
***REMOVED*** else ***REMOVED***
      throw new Error("Node does not exist: " + node);
***REMOVED***
***REMOVED***
  /**
   * Set the associated data for a given node name. If the node does not exist, this method will throw an error
   */
  setNodeData: function (node, data) ***REMOVED***
    if (this.hasNode(node)) ***REMOVED***
      this.nodes[node] = data;
***REMOVED*** else ***REMOVED***
      throw new Error("Node does not exist: " + node);
***REMOVED***
***REMOVED***
  /**
   * Add a dependency between two nodes. If either of the nodes does not exist,
   * an Error will be thrown.
   */
  addDependency: function (from, to) ***REMOVED***
    if (!this.hasNode(from)) ***REMOVED***
      throw new Error("Node does not exist: " + from);
***REMOVED***
    if (!this.hasNode(to)) ***REMOVED***
      throw new Error("Node does not exist: " + to);
***REMOVED***
    if (this.outgoingEdges[from].indexOf(to) === -1) ***REMOVED***
      this.outgoingEdges[from].push(to);
***REMOVED***
    if (this.incomingEdges[to].indexOf(from) === -1) ***REMOVED***
      this.incomingEdges[to].push(from);
***REMOVED***
    return true;
***REMOVED***
  /**
   * Remove a dependency between two nodes.
   */
  removeDependency: function (from, to) ***REMOVED***
    var idx;
    if (this.hasNode(from)) ***REMOVED***
      idx = this.outgoingEdges[from].indexOf(to);
      if (idx >= 0) ***REMOVED***
        this.outgoingEdges[from].splice(idx, 1);
  ***REMOVED***
***REMOVED***

    if (this.hasNode(to)) ***REMOVED***
      idx = this.incomingEdges[to].indexOf(from);
      if (idx >= 0) ***REMOVED***
        this.incomingEdges[to].splice(idx, 1);
  ***REMOVED***
***REMOVED***
***REMOVED***
  /**
   * Return a clone of the dependency graph. If any custom data is attached
   * to the nodes, it will only be shallow copied.
   */
  clone: function () ***REMOVED***
    var source = this;
    var result = new DepGraph();
    var keys = Object.keys(source.nodes);
    keys.forEach(function (n) ***REMOVED***
      result.nodes[n] = source.nodes[n];
      result.outgoingEdges[n] = source.outgoingEdges[n].slice(0);
      result.incomingEdges[n] = source.incomingEdges[n].slice(0);
***REMOVED***);
    return result;
***REMOVED***
  /**
   * Get an array containing the direct dependencies of the specified node.
   *
   * Throws an Error if the specified node does not exist.
   */
  directDependenciesOf: function (node) ***REMOVED***
    if (this.hasNode(node)) ***REMOVED***
      return this.outgoingEdges[node].slice(0);
***REMOVED*** else ***REMOVED***
      throw new Error("Node does not exist: " + node);
***REMOVED***
***REMOVED***
  /**
   * Get an array containing the nodes that directly depend on the specified node.
   *
   * Throws an Error if the specified node does not exist.
   */
  directDependantsOf: function (node) ***REMOVED***
    if (this.hasNode(node)) ***REMOVED***
      return this.incomingEdges[node].slice(0);
***REMOVED*** else ***REMOVED***
      throw new Error("Node does not exist: " + node);
***REMOVED***
***REMOVED***
  /**
   * Get an array containing the nodes that the specified node depends on (transitively).
   *
   * Throws an Error if the graph has a cycle, or the specified node does not exist.
   *
   * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned
   * in the array.
   */
  dependenciesOf: function (node, leavesOnly) ***REMOVED***
    if (this.hasNode(node)) ***REMOVED***
      var result = [];
      var DFS = createDFS(
        this.outgoingEdges,
        leavesOnly,
        result,
        this.circular
      );
      DFS(node);
      var idx = result.indexOf(node);
      if (idx >= 0) ***REMOVED***
        result.splice(idx, 1);
  ***REMOVED***
      return result;
***REMOVED*** else ***REMOVED***
      throw new Error("Node does not exist: " + node);
***REMOVED***
***REMOVED***
  /**
   * get an array containing the nodes that depend on the specified node (transitively).
   *
   * Throws an Error if the graph has a cycle, or the specified node does not exist.
   *
   * If `leavesOnly` is true, only nodes that do not have any dependants will be returned in the array.
   */
  dependantsOf: function (node, leavesOnly) ***REMOVED***
    if (this.hasNode(node)) ***REMOVED***
      var result = [];
      var DFS = createDFS(
        this.incomingEdges,
        leavesOnly,
        result,
        this.circular
      );
      DFS(node);
      var idx = result.indexOf(node);
      if (idx >= 0) ***REMOVED***
        result.splice(idx, 1);
  ***REMOVED***
      return result;
***REMOVED*** else ***REMOVED***
      throw new Error("Node does not exist: " + node);
***REMOVED***
***REMOVED***
  /**
   * Construct the overall processing order for the dependency graph.
   *
   * Throws an Error if the graph has a cycle.
   *
   * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned.
   */
  overallOrder: function (leavesOnly) ***REMOVED***
    var self = this;
    var result = [];
    var keys = Object.keys(this.nodes);
    if (keys.length === 0) ***REMOVED***
      return result; // Empty graph
***REMOVED*** else ***REMOVED***
      if (!this.circular) ***REMOVED***
        // Look for cycles - we run the DFS starting at all the nodes in case there
        // are several disconnected subgraphs inside this dependency graph.
        var CycleDFS = createDFS(this.outgoingEdges, false, [], this.circular);
        keys.forEach(function (n) ***REMOVED***
          CycleDFS(n);
    ***REMOVED***);
  ***REMOVED***

      var DFS = createDFS(
        this.outgoingEdges,
        leavesOnly,
        result,
        this.circular
      );
      // Find all potential starting points (nodes with nothing depending on them) an
      // run a DFS starting at these points to get the order
      keys
        .filter(function (node) ***REMOVED***
          return self.incomingEdges[node].length === 0;
    ***REMOVED***)
        .forEach(function (n) ***REMOVED***
          DFS(n);
    ***REMOVED***);

      // If we're allowing cycles - we need to run the DFS against any remaining
      // nodes that did not end up in the initial result (as they are part of a
      // subgraph that does not have a clear starting point)
      if (this.circular) ***REMOVED***
        keys
          .filter(function (node) ***REMOVED***
            return result.indexOf(node) === -1;
      ***REMOVED***)
          .forEach(function (n) ***REMOVED***
            DFS(n);
      ***REMOVED***);
  ***REMOVED***

      return result;
***REMOVED***
***REMOVED***
  /**
   * Get an array of nodes that have no dependants (i.e. nothing depends on them).
   */
  entryNodes: function () ***REMOVED***
    var self = this;
    return Object.keys(this.nodes).filter(function (node) ***REMOVED***
      return self.incomingEdges[node].length === 0;
***REMOVED***);
***REMOVED***
***REMOVED***;

// Create some aliases
DepGraph.prototype.directDependentsOf = DepGraph.prototype.directDependantsOf;
DepGraph.prototype.dependentsOf = DepGraph.prototype.dependantsOf;

/**
 * Cycle error, including the path of the cycle.
 */
var DepGraphCycleError = (exports.DepGraphCycleError = function (cyclePath) ***REMOVED***
  var message = "Dependency Cycle Found: " + cyclePath.join(" -> ");
  var instance = new Error(message);
  instance.cyclePath = cyclePath;
  Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
  if (Error.captureStackTrace) ***REMOVED***
    Error.captureStackTrace(instance, DepGraphCycleError);
***REMOVED***
  return instance;
***REMOVED***);
DepGraphCycleError.prototype = Object.create(Error.prototype, ***REMOVED***
  constructor: ***REMOVED***
    value: Error,
    enumerable: false,
    writable: true,
    configurable: true
***REMOVED***
***REMOVED***);
Object.setPrototypeOf(DepGraphCycleError, Error);
