'use strict';
const align = ***REMOVED***
    right: alignRight,
    center: alignCenter
***REMOVED***;
const top = 0;
const right = 1;
const bottom = 2;
const left = 3;
export class UI ***REMOVED***
    constructor(opts) ***REMOVED***
        var _a;
        this.width = opts.width;
        this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;
        this.rows = [];
***REMOVED***
    span(...args) ***REMOVED***
        const cols = this.div(...args);
        cols.span = true;
***REMOVED***
    resetOutput() ***REMOVED***
        this.rows = [];
***REMOVED***
    div(...args) ***REMOVED***
        if (args.length === 0) ***REMOVED***
            this.div('');
    ***REMOVED***
        if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === 'string') ***REMOVED***
            return this.applyLayoutDSL(args[0]);
    ***REMOVED***
        const cols = args.map(arg => ***REMOVED***
            if (typeof arg === 'string') ***REMOVED***
                return this.colFromString(arg);
        ***REMOVED***
            return arg;
    ***REMOVED***);
        this.rows.push(cols);
        return cols;
***REMOVED***
    shouldApplyLayoutDSL(...args) ***REMOVED***
        return args.length === 1 && typeof args[0] === 'string' &&
            /[\t\n]/.test(args[0]);
***REMOVED***
    applyLayoutDSL(str) ***REMOVED***
        const rows = str.split('\n').map(row => row.split('\t'));
        let leftColumnWidth = 0;
        // simple heuristic for layout, make sure the
        // second column lines up along the left-hand.
        // don't allow the first column to take up more
        // than 50% of the screen.
        rows.forEach(columns => ***REMOVED***
            if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) ***REMOVED***
                leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));
        ***REMOVED***
    ***REMOVED***);
        // generate a table:
        //  replacing ' ' with padding calculations.
        //  using the algorithmically generated width.
        rows.forEach(columns => ***REMOVED***
            this.div(...columns.map((r, i) => ***REMOVED***
                return ***REMOVED***
                    text: r.trim(),
                    padding: this.measurePadding(r),
                    width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined
            ***REMOVED***;
        ***REMOVED***));
    ***REMOVED***);
        return this.rows[this.rows.length - 1];
***REMOVED***
    colFromString(text) ***REMOVED***
        return ***REMOVED***
            text,
            padding: this.measurePadding(text)
    ***REMOVED***;
***REMOVED***
    measurePadding(str) ***REMOVED***
        // measure padding without ansi escape codes
        const noAnsi = mixin.stripAnsi(str);
        return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
***REMOVED***
    toString() ***REMOVED***
        const lines = [];
        this.rows.forEach(row => ***REMOVED***
            this.rowToString(row, lines);
    ***REMOVED***);
        // don't display any lines with the
        // hidden flag set.
        return lines
            .filter(line => !line.hidden)
            .map(line => line.text)
            .join('\n');
***REMOVED***
    rowToString(row, lines) ***REMOVED***
        this.rasterize(row).forEach((rrow, r) => ***REMOVED***
            let str = '';
            rrow.forEach((col, c) => ***REMOVED***
                const ***REMOVED*** width ***REMOVED*** = row[c]; // the width with padding.
                const wrapWidth = this.negatePadding(row[c]); // the width without padding.
                let ts = col; // temporary string used during alignment/padding.
                if (wrapWidth > mixin.stringWidth(col)) ***REMOVED***
                    ts += ' '.repeat(wrapWidth - mixin.stringWidth(col));
            ***REMOVED***
                // align the string within its column.
                if (row[c].align && row[c].align !== 'left' && this.wrap) ***REMOVED***
                    const fn = align[row[c].align];
                    ts = fn(ts, wrapWidth);
                    if (mixin.stringWidth(ts) < wrapWidth) ***REMOVED***
                        ts += ' '.repeat((width || 0) - mixin.stringWidth(ts) - 1);
                ***REMOVED***
            ***REMOVED***
                // apply border and padding to string.
                const padding = row[c].padding || [0, 0, 0, 0];
                if (padding[left]) ***REMOVED***
                    str += ' '.repeat(padding[left]);
            ***REMOVED***
                str += addBorder(row[c], ts, '| ');
                str += ts;
                str += addBorder(row[c], ts, ' |');
                if (padding[right]) ***REMOVED***
                    str += ' '.repeat(padding[right]);
            ***REMOVED***
                // if prior row is span, try to render the
                // current row on the prior line.
                if (r === 0 && lines.length > 0) ***REMOVED***
                    str = this.renderInline(str, lines[lines.length - 1]);
            ***REMOVED***
        ***REMOVED***);
            // remove trailing whitespace.
            lines.push(***REMOVED***
                text: str.replace(/ +$/, ''),
                span: row.span
        ***REMOVED***);
    ***REMOVED***);
        return lines;
***REMOVED***
    // if the full 'source' can render in
    // the target line, do so.
    renderInline(source, previousLine) ***REMOVED***
        const match = source.match(/^ */);
        const leadingWhitespace = match ? match[0].length : 0;
        const target = previousLine.text;
        const targetTextWidth = mixin.stringWidth(target.trimRight());
        if (!previousLine.span) ***REMOVED***
            return source;
    ***REMOVED***
        // if we're not applying wrapping logic,
        // just always append to the span.
        if (!this.wrap) ***REMOVED***
            previousLine.hidden = true;
            return target + source;
    ***REMOVED***
        if (leadingWhitespace < targetTextWidth) ***REMOVED***
            return source;
    ***REMOVED***
        previousLine.hidden = true;
        return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
***REMOVED***
    rasterize(row) ***REMOVED***
        const rrows = [];
        const widths = this.columnWidths(row);
        let wrapped;
        // word wrap all columns, and create
        // a data-structure that is easy to rasterize.
        row.forEach((col, c) => ***REMOVED***
            // leave room for left and right padding.
            col.width = widths[c];
            if (this.wrap) ***REMOVED***
                wrapped = mixin.wrap(col.text, this.negatePadding(col), ***REMOVED*** hard: true ***REMOVED***).split('\n');
        ***REMOVED***
            else ***REMOVED***
                wrapped = col.text.split('\n');
        ***REMOVED***
            if (col.border) ***REMOVED***
                wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');
                wrapped.push("'" + '-'.repeat(this.negatePadding(col) + 2) + "'");
        ***REMOVED***
            // add top and bottom padding.
            if (col.padding) ***REMOVED***
                wrapped.unshift(...new Array(col.padding[top] || 0).fill(''));
                wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));
        ***REMOVED***
            wrapped.forEach((str, r) => ***REMOVED***
                if (!rrows[r]) ***REMOVED***
                    rrows.push([]);
            ***REMOVED***
                const rrow = rrows[r];
                for (let i = 0; i < c; i++) ***REMOVED***
                    if (rrow[i] === undefined) ***REMOVED***
                        rrow.push('');
                ***REMOVED***
            ***REMOVED***
                rrow.push(str);
        ***REMOVED***);
    ***REMOVED***);
        return rrows;
***REMOVED***
    negatePadding(col) ***REMOVED***
        let wrapWidth = col.width || 0;
        if (col.padding) ***REMOVED***
            wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
    ***REMOVED***
        if (col.border) ***REMOVED***
            wrapWidth -= 4;
    ***REMOVED***
        return wrapWidth;
***REMOVED***
    columnWidths(row) ***REMOVED***
        if (!this.wrap) ***REMOVED***
            return row.map(col => ***REMOVED***
                return col.width || mixin.stringWidth(col.text);
        ***REMOVED***);
    ***REMOVED***
        let unset = row.length;
        let remainingWidth = this.width;
        // column widths can be set in config.
        const widths = row.map(col => ***REMOVED***
            if (col.width) ***REMOVED***
                unset--;
                remainingWidth -= col.width;
                return col.width;
        ***REMOVED***
            return undefined;
    ***REMOVED***);
        // any unset widths should be calculated.
        const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
        return widths.map((w, i) => ***REMOVED***
            if (w === undefined) ***REMOVED***
                return Math.max(unsetWidth, _minWidth(row[i]));
        ***REMOVED***
            return w;
    ***REMOVED***);
***REMOVED***
***REMOVED***
function addBorder(col, ts, style) ***REMOVED***
    if (col.border) ***REMOVED***
        if (/[.']-+[.']/.test(ts)) ***REMOVED***
            return '';
    ***REMOVED***
        if (ts.trim().length !== 0) ***REMOVED***
            return style;
    ***REMOVED***
        return '  ';
***REMOVED***
    return '';
***REMOVED***
// calculates the minimum width of
// a column, based on padding preferences.
function _minWidth(col) ***REMOVED***
    const padding = col.padding || [];
    const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
    if (col.border) ***REMOVED***
        return minWidth + 4;
***REMOVED***
    return minWidth;
***REMOVED***
function getWindowWidth() ***REMOVED***
    /* istanbul ignore next: depends on terminal */
    if (typeof process === 'object' && process.stdout && process.stdout.columns) ***REMOVED***
        return process.stdout.columns;
***REMOVED***
    return 80;
***REMOVED***
function alignRight(str, width) ***REMOVED***
    str = str.trim();
    const strWidth = mixin.stringWidth(str);
    if (strWidth < width) ***REMOVED***
        return ' '.repeat(width - strWidth) + str;
***REMOVED***
    return str;
***REMOVED***
function alignCenter(str, width) ***REMOVED***
    str = str.trim();
    const strWidth = mixin.stringWidth(str);
    /* istanbul ignore next */
    if (strWidth >= width) ***REMOVED***
        return str;
***REMOVED***
    return ' '.repeat((width - strWidth) >> 1) + str;
***REMOVED***
let mixin;
export function cliui(opts, _mixin) ***REMOVED***
    mixin = _mixin;
    return new UI(***REMOVED***
        width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),
        wrap: opts === null || opts === void 0 ? void 0 : opts.wrap
***REMOVED***);
***REMOVED***
