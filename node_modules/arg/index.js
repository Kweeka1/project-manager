const flagSymbol = Symbol('arg flag');

class ArgError extends Error ***REMOVED***
	constructor(msg, code) ***REMOVED***
		super(msg);
		this.name = 'ArgError';
		this.code = code;

		Object.setPrototypeOf(this, ArgError.prototype);
	***REMOVED***
***REMOVED***

function arg(
	opts,
	***REMOVED***
		argv = process.argv.slice(2),
		permissive = false,
		stopAtPositional = false
	***REMOVED*** = ***REMOVED******REMOVED***
) ***REMOVED***
	if (!opts) ***REMOVED***
		throw new ArgError(
			'argument specification object is required',
			'ARG_CONFIG_NO_SPEC'
		);
	***REMOVED***

	const result = ***REMOVED*** _: [] ***REMOVED***;

	const aliases = ***REMOVED******REMOVED***;
	const handlers = ***REMOVED******REMOVED***;

	for (const key of Object.keys(opts)) ***REMOVED***
		if (!key) ***REMOVED***
			throw new ArgError(
				'argument key cannot be an empty string',
				'ARG_CONFIG_EMPTY_KEY'
			);
		***REMOVED***

		if (key[0] !== '-') ***REMOVED***
			throw new ArgError(
				`argument key must start with '-' but found: '$***REMOVED***key***REMOVED***'`,
				'ARG_CONFIG_NONOPT_KEY'
			);
		***REMOVED***

		if (key.length === 1) ***REMOVED***
			throw new ArgError(
				`argument key must have a name; singular '-' keys are not allowed: $***REMOVED***key***REMOVED***`,
				'ARG_CONFIG_NONAME_KEY'
			);
		***REMOVED***

		if (typeof opts[key] === 'string') ***REMOVED***
			aliases[key] = opts[key];
			continue;
		***REMOVED***

		let type = opts[key];
		let isFlag = false;

		if (
			Array.isArray(type) &&
			type.length === 1 &&
			typeof type[0] === 'function'
		) ***REMOVED***
			const [fn] = type;
			type = (value, name, prev = []) => ***REMOVED***
				prev.push(fn(value, name, prev[prev.length - 1]));
				return prev;
			***REMOVED***;
			isFlag = fn === Boolean || fn[flagSymbol] === true;
		***REMOVED*** else if (typeof type === 'function') ***REMOVED***
			isFlag = type === Boolean || type[flagSymbol] === true;
		***REMOVED*** else ***REMOVED***
			throw new ArgError(
				`type missing or not a function or valid array type: $***REMOVED***key***REMOVED***`,
				'ARG_CONFIG_VAD_TYPE'
			);
		***REMOVED***

		if (key[1] !== '-' && key.length > 2) ***REMOVED***
			throw new ArgError(
				`short argument keys (with a single hyphen) must have only one character: $***REMOVED***key***REMOVED***`,
				'ARG_CONFIG_SHORTOPT_TOOLONG'
			);
		***REMOVED***

		handlers[key] = [type, isFlag];
	***REMOVED***

	for (let i = 0, len = argv.length; i < len; i++) ***REMOVED***
		const wholeArg = argv[i];

		if (stopAtPositional && result._.length > 0) ***REMOVED***
			result._ = result._.concat(argv.slice(i));
			break;
		***REMOVED***

		if (wholeArg === '--') ***REMOVED***
			result._ = result._.concat(argv.slice(i + 1));
			break;
		***REMOVED***

		if (wholeArg.length > 1 && wholeArg[0] === '-') ***REMOVED***
			/* eslint-disable operator-linebreak */
			const separatedArguments =
				wholeArg[1] === '-' || wholeArg.length === 2
					? [wholeArg]
					: wholeArg
							.slice(1)
							.split('')
							.map((a) => `-$***REMOVED***a***REMOVED***`);
			/* eslint-enable operator-linebreak */

			for (let j = 0; j < separatedArguments.length; j++) ***REMOVED***
				const arg = separatedArguments[j];
				const [originalArgName, argStr] =
					arg[1] === '-' ? arg.split(/=(.*)/, 2) : [arg, undefined];

				let argName = originalArgName;
				while (argName in aliases) ***REMOVED***
					argName = aliases[argName];
				***REMOVED***

				if (!(argName in handlers)) ***REMOVED***
					if (permissive) ***REMOVED***
						result._.push(arg);
						continue;
					***REMOVED*** else ***REMOVED***
						throw new ArgError(
							`unknown or unexpected option: $***REMOVED***originalArgName***REMOVED***`,
							'ARG_UNKNOWN_OPTION'
						);
					***REMOVED***
				***REMOVED***

				const [type, isFlag] = handlers[argName];

				if (!isFlag && j + 1 < separatedArguments.length) ***REMOVED***
					throw new ArgError(
						`option requires argument (but was followed by another short argument): $***REMOVED***originalArgName***REMOVED***`,
						'ARG_MISSING_REQUIRED_SHORTARG'
					);
				***REMOVED***

				if (isFlag) ***REMOVED***
					result[argName] = type(true, argName, result[argName]);
				***REMOVED*** else if (argStr === undefined) ***REMOVED***
					if (
						argv.length < i + 2 ||
						(argv[i + 1].length > 1 &&
							argv[i + 1][0] === '-' &&
							!(
								argv[i + 1].match(/^-?\d*(\.(?=\d))?\d*$/) &&
								(type === Number ||
									// eslint-disable-next-line no-undef
									(typeof BigInt !== 'undefined' && type === BigInt))
							))
					) ***REMOVED***
						const extended =
							originalArgName === argName ? '' : ` (alias for $***REMOVED***argName***REMOVED***)`;
						throw new ArgError(
							`option requires argument: $***REMOVED***originalArgName***REMOVED***$***REMOVED***extended***REMOVED***`,
							'ARG_MISSING_REQUIRED_LONGARG'
						);
					***REMOVED***

					result[argName] = type(argv[i + 1], argName, result[argName]);
					++i;
				***REMOVED*** else ***REMOVED***
					result[argName] = type(argStr, argName, result[argName]);
				***REMOVED***
			***REMOVED***
		***REMOVED*** else ***REMOVED***
			result._.push(wholeArg);
		***REMOVED***
	***REMOVED***

	return result;
***REMOVED***

arg.flag = (fn) => ***REMOVED***
	fn[flagSymbol] = true;
	return fn;
***REMOVED***;

// Utility types
arg.COUNT = arg.flag((v, name, existingCount) => (existingCount || 0) + 1);

// Expose error class
arg.ArgError = ArgError;

module.exports = arg;
