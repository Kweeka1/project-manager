declare const flagSymbol: unique symbol;

declare function arg<T extends arg.Spec>(
	spec: T,
	options?: arg.Options
): arg.Result<T>;

declare namespace arg ***REMOVED***
	export function flag<T>(fn: T): T & ***REMOVED*** [flagSymbol]: true ***REMOVED***;

	export const COUNT: Handler<number> & ***REMOVED*** [flagSymbol]: true ***REMOVED***;

	export type Handler<T = any> = (
		value: string,
		name: string,
		previousValue?: T
	) => T;

	export class ArgError extends Error ***REMOVED***
		constructor(message: string, code: string);

		code: string;
	***REMOVED***

	export interface Spec ***REMOVED***
		[key: string]: string | Handler | [Handler];
	***REMOVED***

	export type Result<T extends Spec> = ***REMOVED*** _: string[] ***REMOVED*** & ***REMOVED***
		[K in keyof T]?: T[K] extends Handler
			? ReturnType<T[K]>
			: T[K] extends [Handler]
			? Array<ReturnType<T[K][0]>>
			: never;
	***REMOVED***;

	export interface Options ***REMOVED***
		argv?: string[];
		permissive?: boolean;
		stopAtPositional?: boolean;
	***REMOVED***
***REMOVED***

export = arg;
