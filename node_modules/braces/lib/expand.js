'use strict';

const fill = require('fill-range');
const stringify = require('./stringify');
const utils = require('./utils');

const append = (queue = '', stash = '', enclose = false) => ***REMOVED***
  let result = [];

  queue = [].concat(queue);
  stash = [].concat(stash);

  if (!stash.length) return queue;
  if (!queue.length) ***REMOVED***
    return enclose ? utils.flatten(stash).map(ele => `***REMOVED***$***REMOVED***ele***REMOVED******REMOVED***`) : stash;
***REMOVED***

  for (let item of queue) ***REMOVED***
    if (Array.isArray(item)) ***REMOVED***
      for (let value of item) ***REMOVED***
        result.push(append(value, stash, enclose));
  ***REMOVED***
***REMOVED*** else ***REMOVED***
      for (let ele of stash) ***REMOVED***
        if (enclose === true && typeof ele === 'string') ele = `***REMOVED***$***REMOVED***ele***REMOVED******REMOVED***`;
        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));
  ***REMOVED***
***REMOVED***
***REMOVED***
  return utils.flatten(result);
***REMOVED***;

const expand = (ast, options = ***REMOVED******REMOVED***) => ***REMOVED***
  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;

  let walk = (node, parent = ***REMOVED******REMOVED***) => ***REMOVED***
    node.queue = [];

    let p = parent;
    let q = parent.queue;

    while (p.type !== 'brace' && p.type !== 'root' && p.parent) ***REMOVED***
      p = p.parent;
      q = p.queue;
***REMOVED***

    if (node.invalid || node.dollar) ***REMOVED***
      q.push(append(q.pop(), stringify(node, options)));
      return;
***REMOVED***

    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) ***REMOVED***
      q.push(append(q.pop(), ['***REMOVED******REMOVED***']));
      return;
***REMOVED***

    if (node.nodes && node.ranges > 0) ***REMOVED***
      let args = utils.reduce(node.nodes);

      if (utils.exceedsLimit(...args, options.step, rangeLimit)) ***REMOVED***
        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
  ***REMOVED***

      let range = fill(...args, options);
      if (range.length === 0) ***REMOVED***
        range = stringify(node, options);
  ***REMOVED***

      q.push(append(q.pop(), range));
      node.nodes = [];
      return;
***REMOVED***

    let enclose = utils.encloseBrace(node);
    let queue = node.queue;
    let block = node;

    while (block.type !== 'brace' && block.type !== 'root' && block.parent) ***REMOVED***
      block = block.parent;
      queue = block.queue;
***REMOVED***

    for (let i = 0; i < node.nodes.length; i++) ***REMOVED***
      let child = node.nodes[i];

      if (child.type === 'comma' && node.type === 'brace') ***REMOVED***
        if (i === 1) queue.push('');
        queue.push('');
        continue;
  ***REMOVED***

      if (child.type === 'close') ***REMOVED***
        q.push(append(q.pop(), queue, enclose));
        continue;
  ***REMOVED***

      if (child.value && child.type !== 'open') ***REMOVED***
        queue.push(append(queue.pop(), child.value));
        continue;
  ***REMOVED***

      if (child.nodes) ***REMOVED***
        walk(child, node);
  ***REMOVED***
***REMOVED***

    return queue;
***REMOVED***;

  return utils.flatten(walk(ast));
***REMOVED***;

module.exports = expand;
