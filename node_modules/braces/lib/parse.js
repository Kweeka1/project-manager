'use strict';

const stringify = require('./stringify');

/**
 * Constants
 */

const ***REMOVED***
  MAX_LENGTH,
  CHAR_BACKSLASH, /* \ */
  CHAR_BACKTICK, /* ` */
  CHAR_COMMA, /* , */
  CHAR_DOT, /* . */
  CHAR_LEFT_PARENTHESES, /* ( */
  CHAR_RIGHT_PARENTHESES, /* ) */
  CHAR_LEFT_CURLY_BRACE, /* ***REMOVED*** */
  CHAR_RIGHT_CURLY_BRACE, /* ***REMOVED*** */
  CHAR_LEFT_SQUARE_BRACKET, /* [ */
  CHAR_RIGHT_SQUARE_BRACKET, /* ] */
  CHAR_DOUBLE_QUOTE, /* " */
  CHAR_SINGLE_QUOTE, /* ' */
  CHAR_NO_BREAK_SPACE,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE
***REMOVED*** = require('./constants');

/**
 * parse
 */

const parse = (input, options = ***REMOVED******REMOVED***) => ***REMOVED***
  if (typeof input !== 'string') ***REMOVED***
    throw new TypeError('Expected a string');
***REMOVED***

  let opts = options || ***REMOVED******REMOVED***;
  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  if (input.length > max) ***REMOVED***
    throw new SyntaxError(`Input length ($***REMOVED***input.length***REMOVED***), exceeds max characters ($***REMOVED***max***REMOVED***)`);
***REMOVED***

  let ast = ***REMOVED*** type: 'root', input, nodes: [] ***REMOVED***;
  let stack = [ast];
  let block = ast;
  let prev = ast;
  let brackets = 0;
  let length = input.length;
  let index = 0;
  let depth = 0;
  let value;
  let memo = ***REMOVED******REMOVED***;

  /**
   * Helpers
   */

  const advance = () => input[index++];
  const push = node => ***REMOVED***
    if (node.type === 'text' && prev.type === 'dot') ***REMOVED***
      prev.type = 'text';
***REMOVED***

    if (prev && prev.type === 'text' && node.type === 'text') ***REMOVED***
      prev.value += node.value;
      return;
***REMOVED***

    block.nodes.push(node);
    node.parent = block;
    node.prev = prev;
    prev = node;
    return node;
***REMOVED***;

  push(***REMOVED*** type: 'bos' ***REMOVED***);

  while (index < length) ***REMOVED***
    block = stack[stack.length - 1];
    value = advance();

    /**
     * Invalid chars
     */

    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) ***REMOVED***
      continue;
***REMOVED***

    /**
     * Escaped chars
     */

    if (value === CHAR_BACKSLASH) ***REMOVED***
      push(***REMOVED*** type: 'text', value: (options.keepEscaping ? value : '') + advance() ***REMOVED***);
      continue;
***REMOVED***

    /**
     * Right square bracket (literal): ']'
     */

    if (value === CHAR_RIGHT_SQUARE_BRACKET) ***REMOVED***
      push(***REMOVED*** type: 'text', value: '\\' + value ***REMOVED***);
      continue;
***REMOVED***

    /**
     * Left square bracket: '['
     */

    if (value === CHAR_LEFT_SQUARE_BRACKET) ***REMOVED***
      brackets++;

      let closed = true;
      let next;

      while (index < length && (next = advance())) ***REMOVED***
        value += next;

        if (next === CHAR_LEFT_SQUARE_BRACKET) ***REMOVED***
          brackets++;
          continue;
    ***REMOVED***

        if (next === CHAR_BACKSLASH) ***REMOVED***
          value += advance();
          continue;
    ***REMOVED***

        if (next === CHAR_RIGHT_SQUARE_BRACKET) ***REMOVED***
          brackets--;

          if (brackets === 0) ***REMOVED***
            break;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

      push(***REMOVED*** type: 'text', value ***REMOVED***);
      continue;
***REMOVED***

    /**
     * Parentheses
     */

    if (value === CHAR_LEFT_PARENTHESES) ***REMOVED***
      block = push(***REMOVED*** type: 'paren', nodes: [] ***REMOVED***);
      stack.push(block);
      push(***REMOVED*** type: 'text', value ***REMOVED***);
      continue;
***REMOVED***

    if (value === CHAR_RIGHT_PARENTHESES) ***REMOVED***
      if (block.type !== 'paren') ***REMOVED***
        push(***REMOVED*** type: 'text', value ***REMOVED***);
        continue;
  ***REMOVED***
      block = stack.pop();
      push(***REMOVED*** type: 'text', value ***REMOVED***);
      block = stack[stack.length - 1];
      continue;
***REMOVED***

    /**
     * Quotes: '|"|`
     */

    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) ***REMOVED***
      let open = value;
      let next;

      if (options.keepQuotes !== true) ***REMOVED***
        value = '';
  ***REMOVED***

      while (index < length && (next = advance())) ***REMOVED***
        if (next === CHAR_BACKSLASH) ***REMOVED***
          value += next + advance();
          continue;
    ***REMOVED***

        if (next === open) ***REMOVED***
          if (options.keepQuotes === true) value += next;
          break;
    ***REMOVED***

        value += next;
  ***REMOVED***

      push(***REMOVED*** type: 'text', value ***REMOVED***);
      continue;
***REMOVED***

    /**
     * Left curly brace: '***REMOVED***'
     */

    if (value === CHAR_LEFT_CURLY_BRACE) ***REMOVED***
      depth++;

      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;
      let brace = ***REMOVED***
        type: 'brace',
        open: true,
        close: false,
        dollar,
        depth,
        commas: 0,
        ranges: 0,
        nodes: []
  ***REMOVED***;

      block = push(brace);
      stack.push(block);
      push(***REMOVED*** type: 'open', value ***REMOVED***);
      continue;
***REMOVED***

    /**
     * Right curly brace: '***REMOVED***'
     */

    if (value === CHAR_RIGHT_CURLY_BRACE) ***REMOVED***
      if (block.type !== 'brace') ***REMOVED***
        push(***REMOVED*** type: 'text', value ***REMOVED***);
        continue;
  ***REMOVED***

      let type = 'close';
      block = stack.pop();
      block.close = true;

      push(***REMOVED*** type, value ***REMOVED***);
      depth--;

      block = stack[stack.length - 1];
      continue;
***REMOVED***

    /**
     * Comma: ','
     */

    if (value === CHAR_COMMA && depth > 0) ***REMOVED***
      if (block.ranges > 0) ***REMOVED***
        block.ranges = 0;
        let open = block.nodes.shift();
        block.nodes = [open, ***REMOVED*** type: 'text', value: stringify(block) ***REMOVED***];
  ***REMOVED***

      push(***REMOVED*** type: 'comma', value ***REMOVED***);
      block.commas++;
      continue;
***REMOVED***

    /**
     * Dot: '.'
     */

    if (value === CHAR_DOT && depth > 0 && block.commas === 0) ***REMOVED***
      let siblings = block.nodes;

      if (depth === 0 || siblings.length === 0) ***REMOVED***
        push(***REMOVED*** type: 'text', value ***REMOVED***);
        continue;
  ***REMOVED***

      if (prev.type === 'dot') ***REMOVED***
        block.range = [];
        prev.value += value;
        prev.type = 'range';

        if (block.nodes.length !== 3 && block.nodes.length !== 5) ***REMOVED***
          block.invalid = true;
          block.ranges = 0;
          prev.type = 'text';
          continue;
    ***REMOVED***

        block.ranges++;
        block.args = [];
        continue;
  ***REMOVED***

      if (prev.type === 'range') ***REMOVED***
        siblings.pop();

        let before = siblings[siblings.length - 1];
        before.value += prev.value + value;
        prev = before;
        block.ranges--;
        continue;
  ***REMOVED***

      push(***REMOVED*** type: 'dot', value ***REMOVED***);
      continue;
***REMOVED***

    /**
     * Text
     */

    push(***REMOVED*** type: 'text', value ***REMOVED***);
***REMOVED***

  // Mark imbalanced braces and brackets as invalid
  do ***REMOVED***
    block = stack.pop();

    if (block.type !== 'root') ***REMOVED***
      block.nodes.forEach(node => ***REMOVED***
        if (!node.nodes) ***REMOVED***
          if (node.type === 'open') node.isOpen = true;
          if (node.type === 'close') node.isClose = true;
          if (!node.nodes) node.type = 'text';
          node.invalid = true;
    ***REMOVED***
  ***REMOVED***);

      // get the location of the block on parent.nodes (block's siblings)
      let parent = stack[stack.length - 1];
      let index = parent.nodes.indexOf(block);
      // replace the (invalid) block with it's nodes
      parent.nodes.splice(index, 1, ...block.nodes);
***REMOVED***
***REMOVED*** while (stack.length > 0);

  push(***REMOVED*** type: 'eos' ***REMOVED***);
  return ast;
***REMOVED***;

module.exports = parse;
