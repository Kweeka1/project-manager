'use strict';

exports.isInteger = num => ***REMOVED***
  if (typeof num === 'number') ***REMOVED***
    return Number.isInteger(num);
***REMOVED***
  if (typeof num === 'string' && num.trim() !== '') ***REMOVED***
    return Number.isInteger(Number(num));
***REMOVED***
  return false;
***REMOVED***;

/**
 * Find a node of the given type
 */

exports.find = (node, type) => node.nodes.find(node => node.type === type);

/**
 * Find a node of the given type
 */

exports.exceedsLimit = (min, max, step = 1, limit) => ***REMOVED***
  if (limit === false) return false;
  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
  return ((Number(max) - Number(min)) / Number(step)) >= limit;
***REMOVED***;

/**
 * Escape the given node with '\\' before node.value
 */

exports.escapeNode = (block, n = 0, type) => ***REMOVED***
  let node = block.nodes[n];
  if (!node) return;

  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') ***REMOVED***
    if (node.escaped !== true) ***REMOVED***
      node.value = '\\' + node.value;
      node.escaped = true;
***REMOVED***
***REMOVED***
***REMOVED***;

/**
 * Returns true if the given brace node should be enclosed in literal braces
 */

exports.encloseBrace = node => ***REMOVED***
  if (node.type !== 'brace') return false;
  if ((node.commas >> 0 + node.ranges >> 0) === 0) ***REMOVED***
    node.invalid = true;
    return true;
***REMOVED***
  return false;
***REMOVED***;

/**
 * Returns true if a brace node is invalid.
 */

exports.isInvalidBrace = block => ***REMOVED***
  if (block.type !== 'brace') return false;
  if (block.invalid === true || block.dollar) return true;
  if ((block.commas >> 0 + block.ranges >> 0) === 0) ***REMOVED***
    block.invalid = true;
    return true;
***REMOVED***
  if (block.open !== true || block.close !== true) ***REMOVED***
    block.invalid = true;
    return true;
***REMOVED***
  return false;
***REMOVED***;

/**
 * Returns true if a node is an open or close node
 */

exports.isOpenOrClose = node => ***REMOVED***
  if (node.type === 'open' || node.type === 'close') ***REMOVED***
    return true;
***REMOVED***
  return node.open === true || node.close === true;
***REMOVED***;

/**
 * Reduce an array of text nodes.
 */

exports.reduce = nodes => nodes.reduce((acc, node) => ***REMOVED***
  if (node.type === 'text') acc.push(node.value);
  if (node.type === 'range') node.type = 'text';
  return acc;
***REMOVED***, []);

/**
 * Flatten an array
 */

exports.flatten = (...args) => ***REMOVED***
  const result = [];
  const flat = arr => ***REMOVED***
    for (let i = 0; i < arr.length; i++) ***REMOVED***
      let ele = arr[i];
      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
***REMOVED***
    return result;
***REMOVED***;
  flat(args);
  return result;
***REMOVED***;
