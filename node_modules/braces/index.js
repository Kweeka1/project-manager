'use strict';

const stringify = require('./lib/stringify');
const compile = require('./lib/compile');
const expand = require('./lib/expand');
const parse = require('./lib/parse');

/**
 * Expand the given pattern or create a regex-compatible string.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces('***REMOVED***a,b,c***REMOVED***', ***REMOVED*** compile: true ***REMOVED***)); //=> ['(a|b|c)']
 * console.log(braces('***REMOVED***a,b,c***REMOVED***')); //=> ['a', 'b', 'c']
 * ```
 * @param ***REMOVED***String***REMOVED*** `str`
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***String***REMOVED***
 * @api public
 */

const braces = (input, options = ***REMOVED******REMOVED***) => ***REMOVED***
  let output = [];

  if (Array.isArray(input)) ***REMOVED***
    for (let pattern of input) ***REMOVED***
      let result = braces.create(pattern, options);
      if (Array.isArray(result)) ***REMOVED***
        output.push(...result);
  ***REMOVED*** else ***REMOVED***
        output.push(result);
  ***REMOVED***
***REMOVED***
***REMOVED*** else ***REMOVED***
    output = [].concat(braces.create(input, options));
***REMOVED***

  if (options && options.expand === true && options.nodupes === true) ***REMOVED***
    output = [...new Set(output)];
***REMOVED***
  return output;
***REMOVED***;

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * // braces.parse(pattern, [, options]);
 * const ast = braces.parse('a/***REMOVED***b,c***REMOVED***/d');
 * console.log(ast);
 * ```
 * @param ***REMOVED***String***REMOVED*** pattern Brace pattern to parse
 * @param ***REMOVED***Object***REMOVED*** options
 * @return ***REMOVED***Object***REMOVED*** Returns an AST
 * @api public
 */

braces.parse = (input, options = ***REMOVED******REMOVED***) => parse(input, options);

/**
 * Creates a braces string from an AST, or an AST node.
 *
 * ```js
 * const braces = require('braces');
 * let ast = braces.parse('foo/***REMOVED***a,b***REMOVED***/bar');
 * console.log(stringify(ast.nodes[2])); //=> '***REMOVED***a,b***REMOVED***'
 * ```
 * @param ***REMOVED***String***REMOVED*** `input` Brace pattern or AST.
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***Array***REMOVED*** Returns an array of expanded values.
 * @api public
 */

braces.stringify = (input, options = ***REMOVED******REMOVED***) => ***REMOVED***
  if (typeof input === 'string') ***REMOVED***
    return stringify(braces.parse(input, options), options);
***REMOVED***
  return stringify(input, options);
***REMOVED***;

/**
 * Compiles a brace pattern into a regex-compatible, optimized string.
 * This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.compile('a/***REMOVED***b,c***REMOVED***/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param ***REMOVED***String***REMOVED*** `input` Brace pattern or AST.
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***Array***REMOVED*** Returns an array of expanded values.
 * @api public
 */

braces.compile = (input, options = ***REMOVED******REMOVED***) => ***REMOVED***
  if (typeof input === 'string') ***REMOVED***
    input = braces.parse(input, options);
***REMOVED***
  return compile(input, options);
***REMOVED***;

/**
 * Expands a brace pattern into an array. This method is called by the
 * main [braces](#braces) function when `options.expand` is true. Before
 * using this method it's recommended that you read the [performance notes](#performance))
 * and advantages of using [.compile](#compile) instead.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.expand('a/***REMOVED***b,c***REMOVED***/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param ***REMOVED***String***REMOVED*** `pattern` Brace pattern
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***Array***REMOVED*** Returns an array of expanded values.
 * @api public
 */

braces.expand = (input, options = ***REMOVED******REMOVED***) => ***REMOVED***
  if (typeof input === 'string') ***REMOVED***
    input = braces.parse(input, options);
***REMOVED***

  let result = expand(input, options);

  // filter out empty strings if specified
  if (options.noempty === true) ***REMOVED***
    result = result.filter(Boolean);
***REMOVED***

  // filter out duplicates if specified
  if (options.nodupes === true) ***REMOVED***
    result = [...new Set(result)];
***REMOVED***

  return result;
***REMOVED***;

/**
 * Processes a brace pattern and returns either an expanded array
 * (if `options.expand` is true), a highly optimized regex-compatible string.
 * This method is called by the main [braces](#braces) function.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.create('user-***REMOVED***200..300***REMOVED***/project-***REMOVED***a,b,c***REMOVED***-***REMOVED***1..10***REMOVED***'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param ***REMOVED***String***REMOVED*** `pattern` Brace pattern
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***Array***REMOVED*** Returns an array of expanded values.
 * @api public
 */

braces.create = (input, options = ***REMOVED******REMOVED***) => ***REMOVED***
  if (input === '' || input.length < 3) ***REMOVED***
    return [input];
***REMOVED***

 return options.expand !== true
    ? braces.compile(input, options)
    : braces.expand(input, options);
***REMOVED***;

/**
 * Expose "braces"
 */

module.exports = braces;
