/**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
import ***REMOVED*** tokenizeArgString ***REMOVED*** from './tokenize-arg-string.js';
import ***REMOVED*** DefaultValuesForTypeKey ***REMOVED*** from './yargs-parser-types.js';
import ***REMOVED*** camelCase, decamelize, looksLikeNumber ***REMOVED*** from './string-utils.js';
let mixin;
export class YargsParser ***REMOVED***
    constructor(_mixin) ***REMOVED***
        mixin = _mixin;
***REMOVED***
    parse(argsInput, options) ***REMOVED***
        const opts = Object.assign(***REMOVED***
            alias: undefined,
            array: undefined,
            boolean: undefined,
            config: undefined,
            configObjects: undefined,
            configuration: undefined,
            coerce: undefined,
            count: undefined,
            default: undefined,
            envPrefix: undefined,
            narg: undefined,
            normalize: undefined,
            string: undefined,
            number: undefined,
            __: undefined,
            key: undefined
    ***REMOVED***, options);
        // allow a string argument to be passed in rather
        // than an argv array.
        const args = tokenizeArgString(argsInput);
        // tokenizeArgString adds extra quotes to args if argsInput is a string
        // only strip those extra quotes in processValue if argsInput is a string
        const inputIsString = typeof argsInput === 'string';
        // aliases might have transitive relationships, normalize this.
        const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
        const configuration = Object.assign(***REMOVED***
            'boolean-negation': true,
            'camel-case-expansion': true,
            'combine-arrays': false,
            'dot-notation': true,
            'duplicate-arguments-array': true,
            'flatten-duplicate-arrays': true,
            'greedy-arrays': true,
            'halt-at-non-option': false,
            'nargs-eats-options': false,
            'negation-prefix': 'no-',
            'parse-numbers': true,
            'parse-positional-numbers': true,
            'populate--': false,
            'set-placeholder-key': false,
            'short-option-groups': true,
            'strip-aliased': false,
            'strip-dashed': false,
            'unknown-options-as-args': false
    ***REMOVED***, opts.configuration);
        const defaults = Object.assign(Object.create(null), opts.default);
        const configObjects = opts.configObjects || [];
        const envPrefix = opts.envPrefix;
        const notFlagsOption = configuration['populate--'];
        const notFlagsArgv = notFlagsOption ? '--' : '_';
        const newAliases = Object.create(null);
        const defaulted = Object.create(null);
        // allow a i18n handler to be passed in, default to a fake one (util.format).
        const __ = opts.__ || mixin.format;
        const flags = ***REMOVED***
            aliases: Object.create(null),
            arrays: Object.create(null),
            bools: Object.create(null),
            strings: Object.create(null),
            numbers: Object.create(null),
            counts: Object.create(null),
            normalize: Object.create(null),
            configs: Object.create(null),
            nargs: Object.create(null),
            coercions: Object.create(null),
            keys: []
    ***REMOVED***;
        const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
        const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');
        [].concat(opts.array || []).filter(Boolean).forEach(function (opt) ***REMOVED***
            const key = typeof opt === 'object' ? opt.key : opt;
            // assign to flags[bools|strings|numbers]
            const assignment = Object.keys(opt).map(function (key) ***REMOVED***
                const arrayFlagKeys = ***REMOVED***
                    boolean: 'bools',
                    string: 'strings',
                    number: 'numbers'
            ***REMOVED***;
                return arrayFlagKeys[key];
        ***REMOVED***).filter(Boolean).pop();
            // assign key to be coerced
            if (assignment) ***REMOVED***
                flags[assignment][key] = true;
        ***REMOVED***
            flags.arrays[key] = true;
            flags.keys.push(key);
    ***REMOVED***);
        [].concat(opts.boolean || []).filter(Boolean).forEach(function (key) ***REMOVED***
            flags.bools[key] = true;
            flags.keys.push(key);
    ***REMOVED***);
        [].concat(opts.string || []).filter(Boolean).forEach(function (key) ***REMOVED***
            flags.strings[key] = true;
            flags.keys.push(key);
    ***REMOVED***);
        [].concat(opts.number || []).filter(Boolean).forEach(function (key) ***REMOVED***
            flags.numbers[key] = true;
            flags.keys.push(key);
    ***REMOVED***);
        [].concat(opts.count || []).filter(Boolean).forEach(function (key) ***REMOVED***
            flags.counts[key] = true;
            flags.keys.push(key);
    ***REMOVED***);
        [].concat(opts.normalize || []).filter(Boolean).forEach(function (key) ***REMOVED***
            flags.normalize[key] = true;
            flags.keys.push(key);
    ***REMOVED***);
        if (typeof opts.narg === 'object') ***REMOVED***
            Object.entries(opts.narg).forEach(([key, value]) => ***REMOVED***
                if (typeof value === 'number') ***REMOVED***
                    flags.nargs[key] = value;
                    flags.keys.push(key);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***
        if (typeof opts.coerce === 'object') ***REMOVED***
            Object.entries(opts.coerce).forEach(([key, value]) => ***REMOVED***
                if (typeof value === 'function') ***REMOVED***
                    flags.coercions[key] = value;
                    flags.keys.push(key);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***
        if (typeof opts.config !== 'undefined') ***REMOVED***
            if (Array.isArray(opts.config) || typeof opts.config === 'string') ***REMOVED***
                ;
                [].concat(opts.config).filter(Boolean).forEach(function (key) ***REMOVED***
                    flags.configs[key] = true;
            ***REMOVED***);
        ***REMOVED***
            else if (typeof opts.config === 'object') ***REMOVED***
                Object.entries(opts.config).forEach(([key, value]) => ***REMOVED***
                    if (typeof value === 'boolean' || typeof value === 'function') ***REMOVED***
                        flags.configs[key] = value;
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***
    ***REMOVED***
        // create a lookup table that takes into account all
        // combinations of aliases: ***REMOVED***f: ['foo'], foo: ['f']***REMOVED***
        extendAliases(opts.key, aliases, opts.default, flags.arrays);
        // apply default values to all aliases.
        Object.keys(defaults).forEach(function (key) ***REMOVED***
            (flags.aliases[key] || []).forEach(function (alias) ***REMOVED***
                defaults[alias] = defaults[key];
        ***REMOVED***);
    ***REMOVED***);
        let error = null;
        checkConfiguration();
        let notFlags = [];
        const argv = Object.assign(Object.create(null), ***REMOVED*** _: [] ***REMOVED***);
        // TODO(bcoe): for the first pass at removing object prototype  we didn't
        // remove all prototypes from objects returned by this API, we might want
        // to gradually move towards doing so.
        const argvReturn = ***REMOVED******REMOVED***;
        for (let i = 0; i < args.length; i++) ***REMOVED***
            const arg = args[i];
            const truncatedArg = arg.replace(/^-***REMOVED***3,***REMOVED***/, '---');
            let broken;
            let key;
            let letters;
            let m;
            let next;
            let value;
            // any unknown option (except for end-of-options, "--")
            if (arg !== '--' && isUnknownOptionAsArg(arg)) ***REMOVED***
                pushPositional(arg);
                // ---, ---=, ----, etc,
        ***REMOVED***
            else if (truncatedArg.match(/---+(=|$)/)) ***REMOVED***
                // options without key name are invalid.
                pushPositional(arg);
                continue;
                // -- separated by =
        ***REMOVED***
            else if (arg.match(/^--.+=/) || (!configuration['short-option-groups'] && arg.match(/^-.+=/))) ***REMOVED***
                // Using [\s\S] instead of . because js doesn't support the
                // 'dotall' regex modifier. See:
                // http://stackoverflow.com/a/1068308/13216
                m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
                // arrays format = '--f=a b c'
                if (m !== null && Array.isArray(m) && m.length >= 3) ***REMOVED***
                    if (checkAllAliases(m[1], flags.arrays)) ***REMOVED***
                        i = eatArray(i, m[1], args, m[2]);
                ***REMOVED***
                    else if (checkAllAliases(m[1], flags.nargs) !== false) ***REMOVED***
                        // nargs format = '--f=monkey washing cat'
                        i = eatNargs(i, m[1], args, m[2]);
                ***REMOVED***
                    else ***REMOVED***
                        setArg(m[1], m[2], true);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
            else if (arg.match(negatedBoolean) && configuration['boolean-negation']) ***REMOVED***
                m = arg.match(negatedBoolean);
                if (m !== null && Array.isArray(m) && m.length >= 2) ***REMOVED***
                    key = m[1];
                    setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
            ***REMOVED***
                // -- separated by space.
        ***REMOVED***
            else if (arg.match(/^--.+/) || (!configuration['short-option-groups'] && arg.match(/^-[^-]+/))) ***REMOVED***
                m = arg.match(/^--?(.+)/);
                if (m !== null && Array.isArray(m) && m.length >= 2) ***REMOVED***
                    key = m[1];
                    if (checkAllAliases(key, flags.arrays)) ***REMOVED***
                        // array format = '--foo a b c'
                        i = eatArray(i, key, args);
                ***REMOVED***
                    else if (checkAllAliases(key, flags.nargs) !== false) ***REMOVED***
                        // nargs format = '--foo a b c'
                        // should be truthy even if: flags.nargs[key] === 0
                        i = eatNargs(i, key, args);
                ***REMOVED***
                    else ***REMOVED***
                        next = args[i + 1];
                        if (next !== undefined && (!next.match(/^-/) ||
                            next.match(negative)) &&
                            !checkAllAliases(key, flags.bools) &&
                            !checkAllAliases(key, flags.counts)) ***REMOVED***
                            setArg(key, next);
                            i++;
                    ***REMOVED***
                        else if (/^(true|false)$/.test(next)) ***REMOVED***
                            setArg(key, next);
                            i++;
                    ***REMOVED***
                        else ***REMOVED***
                            setArg(key, defaultValue(key));
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
                // dot-notation flag separated by '='.
        ***REMOVED***
            else if (arg.match(/^-.\..+=/)) ***REMOVED***
                m = arg.match(/^-([^=]+)=([\s\S]*)$/);
                if (m !== null && Array.isArray(m) && m.length >= 3) ***REMOVED***
                    setArg(m[1], m[2]);
            ***REMOVED***
                // dot-notation flag separated by space.
        ***REMOVED***
            else if (arg.match(/^-.\..+/) && !arg.match(negative)) ***REMOVED***
                next = args[i + 1];
                m = arg.match(/^-(.\..+)/);
                if (m !== null && Array.isArray(m) && m.length >= 2) ***REMOVED***
                    key = m[1];
                    if (next !== undefined && !next.match(/^-/) &&
                        !checkAllAliases(key, flags.bools) &&
                        !checkAllAliases(key, flags.counts)) ***REMOVED***
                        setArg(key, next);
                        i++;
                ***REMOVED***
                    else ***REMOVED***
                        setArg(key, defaultValue(key));
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
            else if (arg.match(/^-[^-]+/) && !arg.match(negative)) ***REMOVED***
                letters = arg.slice(1, -1).split('');
                broken = false;
                for (let j = 0; j < letters.length; j++) ***REMOVED***
                    next = arg.slice(j + 2);
                    if (letters[j + 1] && letters[j + 1] === '=') ***REMOVED***
                        value = arg.slice(j + 3);
                        key = letters[j];
                        if (checkAllAliases(key, flags.arrays)) ***REMOVED***
                            // array format = '-f=a b c'
                            i = eatArray(i, key, args, value);
                    ***REMOVED***
                        else if (checkAllAliases(key, flags.nargs) !== false) ***REMOVED***
                            // nargs format = '-f=monkey washing cat'
                            i = eatNargs(i, key, args, value);
                    ***REMOVED***
                        else ***REMOVED***
                            setArg(key, value);
                    ***REMOVED***
                        broken = true;
                        break;
                ***REMOVED***
                    if (next === '-') ***REMOVED***
                        setArg(letters[j], next);
                        continue;
                ***REMOVED***
                    // current letter is an alphabetic character and next value is a number
                    if (/[A-Za-z]/.test(letters[j]) &&
                        /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) &&
                        checkAllAliases(next, flags.bools) === false) ***REMOVED***
                        setArg(letters[j], next);
                        broken = true;
                        break;
                ***REMOVED***
                    if (letters[j + 1] && letters[j + 1].match(/\W/)) ***REMOVED***
                        setArg(letters[j], next);
                        broken = true;
                        break;
                ***REMOVED***
                    else ***REMOVED***
                        setArg(letters[j], defaultValue(letters[j]));
                ***REMOVED***
            ***REMOVED***
                key = arg.slice(-1)[0];
                if (!broken && key !== '-') ***REMOVED***
                    if (checkAllAliases(key, flags.arrays)) ***REMOVED***
                        // array format = '-f a b c'
                        i = eatArray(i, key, args);
                ***REMOVED***
                    else if (checkAllAliases(key, flags.nargs) !== false) ***REMOVED***
                        // nargs format = '-f a b c'
                        // should be truthy even if: flags.nargs[key] === 0
                        i = eatNargs(i, key, args);
                ***REMOVED***
                    else ***REMOVED***
                        next = args[i + 1];
                        if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||
                            next.match(negative)) &&
                            !checkAllAliases(key, flags.bools) &&
                            !checkAllAliases(key, flags.counts)) ***REMOVED***
                            setArg(key, next);
                            i++;
                    ***REMOVED***
                        else if (/^(true|false)$/.test(next)) ***REMOVED***
                            setArg(key, next);
                            i++;
                    ***REMOVED***
                        else ***REMOVED***
                            setArg(key, defaultValue(key));
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
            else if (arg.match(/^-[0-9]$/) &&
                arg.match(negative) &&
                checkAllAliases(arg.slice(1), flags.bools)) ***REMOVED***
                // single-digit boolean alias, e.g: xargs -0
                key = arg.slice(1);
                setArg(key, defaultValue(key));
        ***REMOVED***
            else if (arg === '--') ***REMOVED***
                notFlags = args.slice(i + 1);
                break;
        ***REMOVED***
            else if (configuration['halt-at-non-option']) ***REMOVED***
                notFlags = args.slice(i);
                break;
        ***REMOVED***
            else ***REMOVED***
                pushPositional(arg);
        ***REMOVED***
    ***REMOVED***
        // order of precedence:
        // 1. command line arg
        // 2. value from env var
        // 3. value from config file
        // 4. value from config objects
        // 5. configured default value
        applyEnvVars(argv, true); // special case: check env vars that point to config file
        applyEnvVars(argv, false);
        setConfig(argv);
        setConfigObjects();
        applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
        applyCoercions(argv);
        if (configuration['set-placeholder-key'])
            setPlaceholderKeys(argv);
        // for any counts either not in args or without an explicit default, set to 0
        Object.keys(flags.counts).forEach(function (key) ***REMOVED***
            if (!hasKey(argv, key.split('.')))
                setArg(key, 0);
    ***REMOVED***);
        // '--' defaults to undefined.
        if (notFlagsOption && notFlags.length)
            argv[notFlagsArgv] = [];
        notFlags.forEach(function (key) ***REMOVED***
            argv[notFlagsArgv].push(key);
    ***REMOVED***);
        if (configuration['camel-case-expansion'] && configuration['strip-dashed']) ***REMOVED***
            Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => ***REMOVED***
                delete argv[key];
        ***REMOVED***);
    ***REMOVED***
        if (configuration['strip-aliased']) ***REMOVED***
            ;
            [].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => ***REMOVED***
                if (configuration['camel-case-expansion'] && alias.includes('-')) ***REMOVED***
                    delete argv[alias.split('.').map(prop => camelCase(prop)).join('.')];
            ***REMOVED***
                delete argv[alias];
        ***REMOVED***);
    ***REMOVED***
        // Push argument into positional array, applying numeric coercion:
        function pushPositional(arg) ***REMOVED***
            const maybeCoercedNumber = maybeCoerceNumber('_', arg);
            if (typeof maybeCoercedNumber === 'string' || typeof maybeCoercedNumber === 'number') ***REMOVED***
                argv._.push(maybeCoercedNumber);
        ***REMOVED***
    ***REMOVED***
        // how many arguments should we consume, based
        // on the nargs option?
        function eatNargs(i, key, args, argAfterEqualSign) ***REMOVED***
            let ii;
            let toEat = checkAllAliases(key, flags.nargs);
            // NaN has a special meaning for the array type, indicating that one or
            // more values are expected.
            toEat = typeof toEat !== 'number' || isNaN(toEat) ? 1 : toEat;
            if (toEat === 0) ***REMOVED***
                if (!isUndefined(argAfterEqualSign)) ***REMOVED***
                    error = Error(__('Argument unexpected for: %s', key));
            ***REMOVED***
                setArg(key, defaultValue(key));
                return i;
        ***REMOVED***
            let available = isUndefined(argAfterEqualSign) ? 0 : 1;
            if (configuration['nargs-eats-options']) ***REMOVED***
                // classic behavior, yargs eats positional and dash arguments.
                if (args.length - (i + 1) + available < toEat) ***REMOVED***
                    error = Error(__('Not enough arguments following: %s', key));
            ***REMOVED***
                available = toEat;
        ***REMOVED***
            else ***REMOVED***
                // nargs will not consume flag arguments, e.g., -abc, --foo,
                // and terminates when one is observed.
                for (ii = i + 1; ii < args.length; ii++) ***REMOVED***
                    if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii]))
                        available++;
                    else
                        break;
            ***REMOVED***
                if (available < toEat)
                    error = Error(__('Not enough arguments following: %s', key));
        ***REMOVED***
            let consumed = Math.min(available, toEat);
            if (!isUndefined(argAfterEqualSign) && consumed > 0) ***REMOVED***
                setArg(key, argAfterEqualSign);
                consumed--;
        ***REMOVED***
            for (ii = i + 1; ii < (consumed + i + 1); ii++) ***REMOVED***
                setArg(key, args[ii]);
        ***REMOVED***
            return (i + consumed);
    ***REMOVED***
        // if an option is an array, eat all non-hyphenated arguments
        // following it... YUM!
        // e.g., --foo apple banana cat becomes ["apple", "banana", "cat"]
        function eatArray(i, key, args, argAfterEqualSign) ***REMOVED***
            let argsToSet = [];
            let next = argAfterEqualSign || args[i + 1];
            // If both array and nargs are configured, enforce the nargs count:
            const nargsCount = checkAllAliases(key, flags.nargs);
            if (checkAllAliases(key, flags.bools) && !(/^(true|false)$/.test(next))) ***REMOVED***
                argsToSet.push(true);
        ***REMOVED***
            else if (isUndefined(next) ||
                (isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))) ***REMOVED***
                // for keys without value ==> argsToSet remains an empty []
                // set user default value, if available
                if (defaults[key] !== undefined) ***REMOVED***
                    const defVal = defaults[key];
                    argsToSet = Array.isArray(defVal) ? defVal : [defVal];
            ***REMOVED***
        ***REMOVED***
            else ***REMOVED***
                // value in --option=value is eaten as is
                if (!isUndefined(argAfterEqualSign)) ***REMOVED***
                    argsToSet.push(processValue(key, argAfterEqualSign, true));
            ***REMOVED***
                for (let ii = i + 1; ii < args.length; ii++) ***REMOVED***
                    if ((!configuration['greedy-arrays'] && argsToSet.length > 0) ||
                        (nargsCount && typeof nargsCount === 'number' && argsToSet.length >= nargsCount))
                        break;
                    next = args[ii];
                    if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
                        break;
                    i = ii;
                    argsToSet.push(processValue(key, next, inputIsString));
            ***REMOVED***
        ***REMOVED***
            // If both array and nargs are configured, create an error if less than
            // nargs positionals were found. NaN has special meaning, indicating
            // that at least one value is required (more are okay).
            if (typeof nargsCount === 'number' && ((nargsCount && argsToSet.length < nargsCount) ||
                (isNaN(nargsCount) && argsToSet.length === 0))) ***REMOVED***
                error = Error(__('Not enough arguments following: %s', key));
        ***REMOVED***
            setArg(key, argsToSet);
            return i;
    ***REMOVED***
        function setArg(key, val, shouldStripQuotes = inputIsString) ***REMOVED***
            if (/-/.test(key) && configuration['camel-case-expansion']) ***REMOVED***
                const alias = key.split('.').map(function (prop) ***REMOVED***
                    return camelCase(prop);
            ***REMOVED***).join('.');
                addNewAlias(key, alias);
        ***REMOVED***
            const value = processValue(key, val, shouldStripQuotes);
            const splitKey = key.split('.');
            setKey(argv, splitKey, value);
            // handle populating aliases of the full key
            if (flags.aliases[key]) ***REMOVED***
                flags.aliases[key].forEach(function (x) ***REMOVED***
                    const keyProperties = x.split('.');
                    setKey(argv, keyProperties, value);
            ***REMOVED***);
        ***REMOVED***
            // handle populating aliases of the first element of the dot-notation key
            if (splitKey.length > 1 && configuration['dot-notation']) ***REMOVED***
                ;
                (flags.aliases[splitKey[0]] || []).forEach(function (x) ***REMOVED***
                    let keyProperties = x.split('.');
                    // expand alias with nested objects in key
                    const a = [].concat(splitKey);
                    a.shift(); // nuke the old key.
                    keyProperties = keyProperties.concat(a);
                    // populate alias only if is not already an alias of the full key
                    // (already populated above)
                    if (!(flags.aliases[key] || []).includes(keyProperties.join('.'))) ***REMOVED***
                        setKey(argv, keyProperties, value);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***
            // Set normalize getter and setter when key is in 'normalize' but isn't an array
            if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) ***REMOVED***
                const keys = [key].concat(flags.aliases[key] || []);
                keys.forEach(function (key) ***REMOVED***
                    Object.defineProperty(argvReturn, key, ***REMOVED***
                        enumerable: true,
                        get() ***REMOVED***
                            return val;
                    ***REMOVED***,
                        set(value) ***REMOVED***
                            val = typeof value === 'string' ? mixin.normalize(value) : value;
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***);
        ***REMOVED***
    ***REMOVED***
        function addNewAlias(key, alias) ***REMOVED***
            if (!(flags.aliases[key] && flags.aliases[key].length)) ***REMOVED***
                flags.aliases[key] = [alias];
                newAliases[alias] = true;
        ***REMOVED***
            if (!(flags.aliases[alias] && flags.aliases[alias].length)) ***REMOVED***
                addNewAlias(alias, key);
        ***REMOVED***
    ***REMOVED***
        function processValue(key, val, shouldStripQuotes) ***REMOVED***
            // strings may be quoted, clean this up as we assign values.
            if (shouldStripQuotes) ***REMOVED***
                val = stripQuotes(val);
        ***REMOVED***
            // handle parsing boolean arguments --foo=true --bar false.
            if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) ***REMOVED***
                if (typeof val === 'string')
                    val = val === 'true';
        ***REMOVED***
            let value = Array.isArray(val)
                ? val.map(function (v) ***REMOVED*** return maybeCoerceNumber(key, v); ***REMOVED***)
                : maybeCoerceNumber(key, val);
            // increment a count given as arg (either no value or value parsed as boolean)
            if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) ***REMOVED***
                value = increment();
        ***REMOVED***
            // Set normalized value when key is in 'normalize' and in 'arrays'
            if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) ***REMOVED***
                if (Array.isArray(val))
                    value = val.map((val) => ***REMOVED*** return mixin.normalize(val); ***REMOVED***);
                else
                    value = mixin.normalize(val);
        ***REMOVED***
            return value;
    ***REMOVED***
        function maybeCoerceNumber(key, value) ***REMOVED***
            if (!configuration['parse-positional-numbers'] && key === '_')
                return value;
            if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) ***REMOVED***
                const shouldCoerceNumber = looksLikeNumber(value) && configuration['parse-numbers'] && (Number.isSafeInteger(Math.floor(parseFloat(`$***REMOVED***value***REMOVED***`))));
                if (shouldCoerceNumber || (!isUndefined(value) && checkAllAliases(key, flags.numbers))) ***REMOVED***
                    value = Number(value);
            ***REMOVED***
        ***REMOVED***
            return value;
    ***REMOVED***
        // set args from config.json file, this should be
        // applied last so that defaults can be applied.
        function setConfig(argv) ***REMOVED***
            const configLookup = Object.create(null);
            // expand defaults/aliases, in-case any happen to reference
            // the config.json file.
            applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
            Object.keys(flags.configs).forEach(function (configKey) ***REMOVED***
                const configPath = argv[configKey] || configLookup[configKey];
                if (configPath) ***REMOVED***
                    try ***REMOVED***
                        let config = null;
                        const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);
                        const resolveConfig = flags.configs[configKey];
                        if (typeof resolveConfig === 'function') ***REMOVED***
                            try ***REMOVED***
                                config = resolveConfig(resolvedConfigPath);
                        ***REMOVED***
                            catch (e) ***REMOVED***
                                config = e;
                        ***REMOVED***
                            if (config instanceof Error) ***REMOVED***
                                error = config;
                                return;
                        ***REMOVED***
                    ***REMOVED***
                        else ***REMOVED***
                            config = mixin.require(resolvedConfigPath);
                    ***REMOVED***
                        setConfigObject(config);
                ***REMOVED***
                    catch (ex) ***REMOVED***
                        // Deno will receive a PermissionDenied error if an attempt is
                        // made to load config without the --allow-read flag:
                        if (ex.name === 'PermissionDenied')
                            error = ex;
                        else if (argv[configKey])
                            error = Error(__('Invalid JSON config file: %s', configPath));
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***
        // set args from config object.
        // it recursively checks nested objects.
        function setConfigObject(config, prev) ***REMOVED***
            Object.keys(config).forEach(function (key) ***REMOVED***
                const value = config[key];
                const fullKey = prev ? prev + '.' + key : key;
                // if the value is an inner object and we have dot-notation
                // enabled, treat inner objects in config the same as
                // heavily nested dot notations (foo.bar.apple).
                if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) ***REMOVED***
                    // if the value is an object but not an array, check nested object
                    setConfigObject(value, fullKey);
            ***REMOVED***
                else ***REMOVED***
                    // setting arguments via CLI takes precedence over
                    // values within the config file.
                    if (!hasKey(argv, fullKey.split('.')) || (checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays'])) ***REMOVED***
                        setArg(fullKey, value);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***
        // set all config objects passed in opts
        function setConfigObjects() ***REMOVED***
            if (typeof configObjects !== 'undefined') ***REMOVED***
                configObjects.forEach(function (configObject) ***REMOVED***
                    setConfigObject(configObject);
            ***REMOVED***);
        ***REMOVED***
    ***REMOVED***
        function applyEnvVars(argv, configOnly) ***REMOVED***
            if (typeof envPrefix === 'undefined')
                return;
            const prefix = typeof envPrefix === 'string' ? envPrefix : '';
            const env = mixin.env();
            Object.keys(env).forEach(function (envVar) ***REMOVED***
                if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) ***REMOVED***
                    // get array of nested keys and convert them to camel case
                    const keys = envVar.split('__').map(function (key, i) ***REMOVED***
                        if (i === 0) ***REMOVED***
                            key = key.substring(prefix.length);
                    ***REMOVED***
                        return camelCase(key);
                ***REMOVED***);
                    if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && !hasKey(argv, keys)) ***REMOVED***
                        setArg(keys.join('.'), env[envVar]);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***
        function applyCoercions(argv) ***REMOVED***
            let coerce;
            const applied = new Set();
            Object.keys(argv).forEach(function (key) ***REMOVED***
                if (!applied.has(key)) ***REMOVED*** // If we haven't already coerced this option via one of its aliases
                    coerce = checkAllAliases(key, flags.coercions);
                    if (typeof coerce === 'function') ***REMOVED***
                        try ***REMOVED***
                            const value = maybeCoerceNumber(key, coerce(argv[key]));
                            ([].concat(flags.aliases[key] || [], key)).forEach(ali => ***REMOVED***
                                applied.add(ali);
                                argv[ali] = value;
                        ***REMOVED***);
                    ***REMOVED***
                        catch (err) ***REMOVED***
                            error = err;
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***
        function setPlaceholderKeys(argv) ***REMOVED***
            flags.keys.forEach((key) => ***REMOVED***
                // don't set placeholder keys for dot notation options 'foo.bar'.
                if (~key.indexOf('.'))
                    return;
                if (typeof argv[key] === 'undefined')
                    argv[key] = undefined;
        ***REMOVED***);
            return argv;
    ***REMOVED***
        function applyDefaultsAndAliases(obj, aliases, defaults, canLog = false) ***REMOVED***
            Object.keys(defaults).forEach(function (key) ***REMOVED***
                if (!hasKey(obj, key.split('.'))) ***REMOVED***
                    setKey(obj, key.split('.'), defaults[key]);
                    if (canLog)
                        defaulted[key] = true;
                    (aliases[key] || []).forEach(function (x) ***REMOVED***
                        if (hasKey(obj, x.split('.')))
                            return;
                        setKey(obj, x.split('.'), defaults[key]);
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***
        function hasKey(obj, keys) ***REMOVED***
            let o = obj;
            if (!configuration['dot-notation'])
                keys = [keys.join('.')];
            keys.slice(0, -1).forEach(function (key) ***REMOVED***
                o = (o[key] || ***REMOVED******REMOVED***);
        ***REMOVED***);
            const key = keys[keys.length - 1];
            if (typeof o !== 'object')
                return false;
            else
                return key in o;
    ***REMOVED***
        function setKey(obj, keys, value) ***REMOVED***
            let o = obj;
            if (!configuration['dot-notation'])
                keys = [keys.join('.')];
            keys.slice(0, -1).forEach(function (key) ***REMOVED***
                // TODO(bcoe): in the next major version of yargs, switch to
                // Object.create(null) for dot notation:
                key = sanitizeKey(key);
                if (typeof o === 'object' && o[key] === undefined) ***REMOVED***
                    o[key] = ***REMOVED******REMOVED***;
            ***REMOVED***
                if (typeof o[key] !== 'object' || Array.isArray(o[key])) ***REMOVED***
                    // ensure that o[key] is an array, and that the last item is an empty object.
                    if (Array.isArray(o[key])) ***REMOVED***
                        o[key].push(***REMOVED******REMOVED***);
                ***REMOVED***
                    else ***REMOVED***
                        o[key] = [o[key], ***REMOVED******REMOVED***];
                ***REMOVED***
                    // we want to update the empty object at the end of the o[key] array, so set o to that object
                    o = o[key][o[key].length - 1];
            ***REMOVED***
                else ***REMOVED***
                    o = o[key];
            ***REMOVED***
        ***REMOVED***);
            // TODO(bcoe): in the next major version of yargs, switch to
            // Object.create(null) for dot notation:
            const key = sanitizeKey(keys[keys.length - 1]);
            const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);
            const isValueArray = Array.isArray(value);
            let duplicate = configuration['duplicate-arguments-array'];
            // nargs has higher priority than duplicate
            if (!duplicate && checkAllAliases(key, flags.nargs)) ***REMOVED***
                duplicate = true;
                if ((!isUndefined(o[key]) && flags.nargs[key] === 1) || (Array.isArray(o[key]) && o[key].length === flags.nargs[key])) ***REMOVED***
                    o[key] = undefined;
            ***REMOVED***
        ***REMOVED***
            if (value === increment()) ***REMOVED***
                o[key] = increment(o[key]);
        ***REMOVED***
            else if (Array.isArray(o[key])) ***REMOVED***
                if (duplicate && isTypeArray && isValueArray) ***REMOVED***
                    o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
            ***REMOVED***
                else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) ***REMOVED***
                    o[key] = value;
            ***REMOVED***
                else ***REMOVED***
                    o[key] = o[key].concat([value]);
            ***REMOVED***
        ***REMOVED***
            else if (o[key] === undefined && isTypeArray) ***REMOVED***
                o[key] = isValueArray ? value : [value];
        ***REMOVED***
            else if (duplicate && !(o[key] === undefined ||
                checkAllAliases(key, flags.counts) ||
                checkAllAliases(key, flags.bools))) ***REMOVED***
                o[key] = [o[key], value];
        ***REMOVED***
            else ***REMOVED***
                o[key] = value;
        ***REMOVED***
    ***REMOVED***
        // extend the aliases list with inferred aliases.
        function extendAliases(...args) ***REMOVED***
            args.forEach(function (obj) ***REMOVED***
                Object.keys(obj || ***REMOVED******REMOVED***).forEach(function (key) ***REMOVED***
                    // short-circuit if we've already added a key
                    // to the aliases array, for example it might
                    // exist in both 'opts.default' and 'opts.key'.
                    if (flags.aliases[key])
                        return;
                    flags.aliases[key] = [].concat(aliases[key] || []);
                    // For "--option-name", also set argv.optionName
                    flags.aliases[key].concat(key).forEach(function (x) ***REMOVED***
                        if (/-/.test(x) && configuration['camel-case-expansion']) ***REMOVED***
                            const c = camelCase(x);
                            if (c !== key && flags.aliases[key].indexOf(c) === -1) ***REMOVED***
                                flags.aliases[key].push(c);
                                newAliases[c] = true;
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***);
                    // For "--optionName", also set argv['option-name']
                    flags.aliases[key].concat(key).forEach(function (x) ***REMOVED***
                        if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) ***REMOVED***
                            const c = decamelize(x, '-');
                            if (c !== key && flags.aliases[key].indexOf(c) === -1) ***REMOVED***
                                flags.aliases[key].push(c);
                                newAliases[c] = true;
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***);
                    flags.aliases[key].forEach(function (x) ***REMOVED***
                        flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) ***REMOVED***
                            return x !== y;
                    ***REMOVED***));
                ***REMOVED***);
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***
        function checkAllAliases(key, flag) ***REMOVED***
            const toCheck = [].concat(flags.aliases[key] || [], key);
            const keys = Object.keys(flag);
            const setAlias = toCheck.find(key => keys.includes(key));
            return setAlias ? flag[setAlias] : false;
    ***REMOVED***
        function hasAnyFlag(key) ***REMOVED***
            const flagsKeys = Object.keys(flags);
            const toCheck = [].concat(flagsKeys.map(k => flags[k]));
            return toCheck.some(function (flag) ***REMOVED***
                return Array.isArray(flag) ? flag.includes(key) : flag[key];
        ***REMOVED***);
    ***REMOVED***
        function hasFlagsMatching(arg, ...patterns) ***REMOVED***
            const toCheck = [].concat(...patterns);
            return toCheck.some(function (pattern) ***REMOVED***
                const match = arg.match(pattern);
                return match && hasAnyFlag(match[1]);
        ***REMOVED***);
    ***REMOVED***
        // based on a simplified version of the short flag group parsing logic
        function hasAllShortFlags(arg) ***REMOVED***
            // if this is a negative number, or doesn't start with a single hyphen, it's not a short flag group
            if (arg.match(negative) || !arg.match(/^-[^-]+/)) ***REMOVED***
                return false;
        ***REMOVED***
            let hasAllFlags = true;
            let next;
            const letters = arg.slice(1).split('');
            for (let j = 0; j < letters.length; j++) ***REMOVED***
                next = arg.slice(j + 2);
                if (!hasAnyFlag(letters[j])) ***REMOVED***
                    hasAllFlags = false;
                    break;
            ***REMOVED***
                if ((letters[j + 1] && letters[j + 1] === '=') ||
                    next === '-' ||
                    (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) ||
                    (letters[j + 1] && letters[j + 1].match(/\W/))) ***REMOVED***
                    break;
            ***REMOVED***
        ***REMOVED***
            return hasAllFlags;
    ***REMOVED***
        function isUnknownOptionAsArg(arg) ***REMOVED***
            return configuration['unknown-options-as-args'] && isUnknownOption(arg);
    ***REMOVED***
        function isUnknownOption(arg) ***REMOVED***
            arg = arg.replace(/^-***REMOVED***3,***REMOVED***/, '--');
            // ignore negative numbers
            if (arg.match(negative)) ***REMOVED***
                return false;
        ***REMOVED***
            // if this is a short option group and all of them are configured, it isn't unknown
            if (hasAllShortFlags(arg)) ***REMOVED***
                return false;
        ***REMOVED***
            // e.g. '--count=2'
            const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
            // e.g. '-a' or '--arg'
            const normalFlag = /^-+([^=]+?)$/;
            // e.g. '-a-'
            const flagEndingInHyphen = /^-+([^=]+?)-$/;
            // e.g. '-abc123'
            const flagEndingInDigits = /^-+([^=]+?\d+)$/;
            // e.g. '-a/usr/local'
            const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
            // check the different types of flag styles, including negatedBoolean, a pattern defined near the start of the parse method
            return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
    ***REMOVED***
        // make a best effort to pick a default value
        // for an option based on name and type.
        function defaultValue(key) ***REMOVED***
            if (!checkAllAliases(key, flags.bools) &&
                !checkAllAliases(key, flags.counts) &&
                `$***REMOVED***key***REMOVED***` in defaults) ***REMOVED***
                return defaults[key];
        ***REMOVED***
            else ***REMOVED***
                return defaultForType(guessType(key));
        ***REMOVED***
    ***REMOVED***
        // return a default value, given the type of a flag.,
        function defaultForType(type) ***REMOVED***
            const def = ***REMOVED***
                [DefaultValuesForTypeKey.BOOLEAN]: true,
                [DefaultValuesForTypeKey.STRING]: '',
                [DefaultValuesForTypeKey.NUMBER]: undefined,
                [DefaultValuesForTypeKey.ARRAY]: []
        ***REMOVED***;
            return def[type];
    ***REMOVED***
        // given a flag, enforce a default type.
        function guessType(key) ***REMOVED***
            let type = DefaultValuesForTypeKey.BOOLEAN;
            if (checkAllAliases(key, flags.strings))
                type = DefaultValuesForTypeKey.STRING;
            else if (checkAllAliases(key, flags.numbers))
                type = DefaultValuesForTypeKey.NUMBER;
            else if (checkAllAliases(key, flags.bools))
                type = DefaultValuesForTypeKey.BOOLEAN;
            else if (checkAllAliases(key, flags.arrays))
                type = DefaultValuesForTypeKey.ARRAY;
            return type;
    ***REMOVED***
        function isUndefined(num) ***REMOVED***
            return num === undefined;
    ***REMOVED***
        // check user configuration settings for inconsistencies
        function checkConfiguration() ***REMOVED***
            // count keys should not be set as array/narg
            Object.keys(flags.counts).find(key => ***REMOVED***
                if (checkAllAliases(key, flags.arrays)) ***REMOVED***
                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));
                    return true;
            ***REMOVED***
                else if (checkAllAliases(key, flags.nargs)) ***REMOVED***
                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));
                    return true;
            ***REMOVED***
                return false;
        ***REMOVED***);
    ***REMOVED***
        return ***REMOVED***
            aliases: Object.assign(***REMOVED******REMOVED***, flags.aliases),
            argv: Object.assign(argvReturn, argv),
            configuration: configuration,
            defaulted: Object.assign(***REMOVED******REMOVED***, defaulted),
            error: error,
            newAliases: Object.assign(***REMOVED******REMOVED***, newAliases)
    ***REMOVED***;
***REMOVED***
***REMOVED***
// if any aliases reference each other, we should
// merge them together.
function combineAliases(aliases) ***REMOVED***
    const aliasArrays = [];
    const combined = Object.create(null);
    let change = true;
    // turn alias lookup hash ***REMOVED***key: ['alias1', 'alias2']***REMOVED*** into
    // a simple array ['key', 'alias1', 'alias2']
    Object.keys(aliases).forEach(function (key) ***REMOVED***
        aliasArrays.push([].concat(aliases[key], key));
***REMOVED***);
    // combine arrays until zero changes are
    // made in an iteration.
    while (change) ***REMOVED***
        change = false;
        for (let i = 0; i < aliasArrays.length; i++) ***REMOVED***
            for (let ii = i + 1; ii < aliasArrays.length; ii++) ***REMOVED***
                const intersect = aliasArrays[i].filter(function (v) ***REMOVED***
                    return aliasArrays[ii].indexOf(v) !== -1;
            ***REMOVED***);
                if (intersect.length) ***REMOVED***
                    aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
                    aliasArrays.splice(ii, 1);
                    change = true;
                    break;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
***REMOVED***
    // map arrays back to the hash-lookup (de-dupe while
    // we're at it).
    aliasArrays.forEach(function (aliasArray) ***REMOVED***
        aliasArray = aliasArray.filter(function (v, i, self) ***REMOVED***
            return self.indexOf(v) === i;
    ***REMOVED***);
        const lastAlias = aliasArray.pop();
        if (lastAlias !== undefined && typeof lastAlias === 'string') ***REMOVED***
            combined[lastAlias] = aliasArray;
    ***REMOVED***
***REMOVED***);
    return combined;
***REMOVED***
// this function should only be called when a count is given as an arg
// it is NOT called to set a default value
// thus we can start the count at 1 instead of 0
function increment(orig) ***REMOVED***
    return orig !== undefined ? orig + 1 : 1;
***REMOVED***
// TODO(bcoe): in the next major version of yargs, switch to
// Object.create(null) for dot notation:
function sanitizeKey(key) ***REMOVED***
    if (key === '__proto__')
        return '___proto___';
    return key;
***REMOVED***
function stripQuotes(val) ***REMOVED***
    return (typeof val === 'string' &&
        (val[0] === "'" || val[0] === '"') &&
        val[val.length - 1] === val[0])
        ? val.substring(1, val.length - 1)
        : val;
***REMOVED***
