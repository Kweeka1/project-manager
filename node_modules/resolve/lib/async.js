var fs = require('fs');
var getHomedir = require('./homedir');
var path = require('path');
var caller = require('./caller');
var nodeModulesPaths = require('./node-modules-paths');
var normalizeOptions = require('./normalize-options');
var isCore = require('is-core-module');

var realpathFS = fs.realpath && typeof fs.realpath.native === 'function' ? fs.realpath.native : fs.realpath;

var homedir = getHomedir();
var defaultPaths = function () ***REMOVED***
    return [
        path.join(homedir, '.node_modules'),
        path.join(homedir, '.node_libraries')
    ];
***REMOVED***;

var defaultIsFile = function isFile(file, cb) ***REMOVED***
    fs.stat(file, function (err, stat) ***REMOVED***
        if (!err) ***REMOVED***
            return cb(null, stat.isFile() || stat.isFIFO());
    ***REMOVED***
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
***REMOVED***);
***REMOVED***;

var defaultIsDir = function isDirectory(dir, cb) ***REMOVED***
    fs.stat(dir, function (err, stat) ***REMOVED***
        if (!err) ***REMOVED***
            return cb(null, stat.isDirectory());
    ***REMOVED***
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
***REMOVED***);
***REMOVED***;

var defaultRealpath = function realpath(x, cb) ***REMOVED***
    realpathFS(x, function (realpathErr, realPath) ***REMOVED***
        if (realpathErr && realpathErr.code !== 'ENOENT') cb(realpathErr);
        else cb(null, realpathErr ? x : realPath);
***REMOVED***);
***REMOVED***;

var maybeRealpath = function maybeRealpath(realpath, x, opts, cb) ***REMOVED***
    if (opts && opts.preserveSymlinks === false) ***REMOVED***
        realpath(x, cb);
***REMOVED*** else ***REMOVED***
        cb(null, x);
***REMOVED***
***REMOVED***;

var defaultReadPackage = function defaultReadPackage(readFile, pkgfile, cb) ***REMOVED***
    readFile(pkgfile, function (readFileErr, body) ***REMOVED***
        if (readFileErr) cb(readFileErr);
        else ***REMOVED***
            try ***REMOVED***
                var pkg = JSON.parse(body);
                cb(null, pkg);
        ***REMOVED*** catch (jsonErr) ***REMOVED***
                cb(null);
        ***REMOVED***
    ***REMOVED***
***REMOVED***);
***REMOVED***;

var getPackageCandidates = function getPackageCandidates(x, start, opts) ***REMOVED***
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) ***REMOVED***
        dirs[i] = path.join(dirs[i], x);
***REMOVED***
    return dirs;
***REMOVED***;

module.exports = function resolve(x, options, callback) ***REMOVED***
    var cb = callback;
    var opts = options;
    if (typeof options === 'function') ***REMOVED***
        cb = opts;
        opts = ***REMOVED******REMOVED***;
***REMOVED***
    if (typeof x !== 'string') ***REMOVED***
        var err = new TypeError('Path must be a string.');
        return process.nextTick(function () ***REMOVED***
            cb(err);
    ***REMOVED***);
***REMOVED***

    opts = normalizeOptions(x, opts);

    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile = opts.readFile || fs.readFile;
    var realpath = opts.realpath || defaultRealpath;
    var readPackage = opts.readPackage || defaultReadPackage;
    if (opts.readFile && opts.readPackage) ***REMOVED***
        var conflictErr = new TypeError('`readFile` and `readPackage` are mutually exclusive.');
        return process.nextTick(function () ***REMOVED***
            cb(conflictErr);
    ***REMOVED***);
***REMOVED***
    var packageIterator = opts.packageIterator;

    var extensions = opts.extensions || ['.js'];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;

    opts.paths = opts.paths || defaultPaths();

    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = path.resolve(basedir);

    maybeRealpath(
        realpath,
        absoluteStart,
        opts,
        function (err, realStart) ***REMOVED***
            if (err) cb(err);
            else init(realStart);
    ***REMOVED***
    );

    var res;
    function init(basedir) ***REMOVED***
        if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) ***REMOVED***
            res = path.resolve(basedir, x);
            if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';
            if ((/\/$/).test(x) && res === basedir) ***REMOVED***
                loadAsDirectory(res, opts.package, onfile);
        ***REMOVED*** else loadAsFile(res, opts.package, onfile);
    ***REMOVED*** else if (includeCoreModules && isCore(x)) ***REMOVED***
            return cb(null, x);
    ***REMOVED*** else loadNodeModules(x, basedir, function (err, n, pkg) ***REMOVED***
            if (err) cb(err);
            else if (n) ***REMOVED***
                return maybeRealpath(realpath, n, opts, function (err, realN) ***REMOVED***
                    if (err) ***REMOVED***
                        cb(err);
                ***REMOVED*** else ***REMOVED***
                        cb(null, realN, pkg);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED*** else ***REMOVED***
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb(moduleError);
        ***REMOVED***
    ***REMOVED***);
***REMOVED***

    function onfile(err, m, pkg) ***REMOVED***
        if (err) cb(err);
        else if (m) cb(null, m, pkg);
        else loadAsDirectory(res, function (err, d, pkg) ***REMOVED***
            if (err) cb(err);
            else if (d) ***REMOVED***
                maybeRealpath(realpath, d, opts, function (err, realD) ***REMOVED***
                    if (err) ***REMOVED***
                        cb(err);
                ***REMOVED*** else ***REMOVED***
                        cb(null, realD, pkg);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED*** else ***REMOVED***
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb(moduleError);
        ***REMOVED***
    ***REMOVED***);
***REMOVED***

    function loadAsFile(x, thePackage, callback) ***REMOVED***
        var loadAsFilePackage = thePackage;
        var cb = callback;
        if (typeof loadAsFilePackage === 'function') ***REMOVED***
            cb = loadAsFilePackage;
            loadAsFilePackage = undefined;
    ***REMOVED***

        var exts = [''].concat(extensions);
        load(exts, x, loadAsFilePackage);

        function load(exts, x, loadPackage) ***REMOVED***
            if (exts.length === 0) return cb(null, undefined, loadPackage);
            var file = x + exts[0];

            var pkg = loadPackage;
            if (pkg) onpkg(null, pkg);
            else loadpkg(path.dirname(file), onpkg);

            function onpkg(err, pkg_, dir) ***REMOVED***
                pkg = pkg_;
                if (err) return cb(err);
                if (dir && pkg && opts.pathFilter) ***REMOVED***
                    var rfile = path.relative(dir, file);
                    var rel = rfile.slice(0, rfile.length - exts[0].length);
                    var r = opts.pathFilter(pkg, x, rel);
                    if (r) return load(
                        [''].concat(extensions.slice()),
                        path.resolve(dir, r),
                        pkg
                    );
            ***REMOVED***
                isFile(file, onex);
        ***REMOVED***
            function onex(err, ex) ***REMOVED***
                if (err) return cb(err);
                if (ex) return cb(null, file, pkg);
                load(exts.slice(1), x, pkg);
        ***REMOVED***
    ***REMOVED***
***REMOVED***

    function loadpkg(dir, cb) ***REMOVED***
        if (dir === '' || dir === '/') return cb(null);
        if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) ***REMOVED***
            return cb(null);
    ***REMOVED***
        if ((/[/\\]node_modules[/\\]*$/).test(dir)) return cb(null);

        maybeRealpath(realpath, dir, opts, function (unwrapErr, pkgdir) ***REMOVED***
            if (unwrapErr) return loadpkg(path.dirname(dir), cb);
            var pkgfile = path.join(pkgdir, 'package.json');
            isFile(pkgfile, function (err, ex) ***REMOVED***
                // on err, ex is false
                if (!ex) return loadpkg(path.dirname(dir), cb);

                readPackage(readFile, pkgfile, function (err, pkgParam) ***REMOVED***
                    if (err) cb(err);

                    var pkg = pkgParam;

                    if (pkg && opts.packageFilter) ***REMOVED***
                        pkg = opts.packageFilter(pkg, pkgfile);
                ***REMOVED***
                    cb(null, pkg, dir);
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***);
***REMOVED***

    function loadAsDirectory(x, loadAsDirectoryPackage, callback) ***REMOVED***
        var cb = callback;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === 'function') ***REMOVED***
            cb = fpkg;
            fpkg = opts.package;
    ***REMOVED***

        maybeRealpath(realpath, x, opts, function (unwrapErr, pkgdir) ***REMOVED***
            if (unwrapErr) return cb(unwrapErr);
            var pkgfile = path.join(pkgdir, 'package.json');
            isFile(pkgfile, function (err, ex) ***REMOVED***
                if (err) return cb(err);
                if (!ex) return loadAsFile(path.join(x, 'index'), fpkg, cb);

                readPackage(readFile, pkgfile, function (err, pkgParam) ***REMOVED***
                    if (err) return cb(err);

                    var pkg = pkgParam;

                    if (pkg && opts.packageFilter) ***REMOVED***
                        pkg = opts.packageFilter(pkg, pkgfile);
                ***REMOVED***

                    if (pkg && pkg.main) ***REMOVED***
                        if (typeof pkg.main !== 'string') ***REMOVED***
                            var mainError = new TypeError('package “' + pkg.name + '” `main` must be a string');
                            mainError.code = 'INVALID_PACKAGE_MAIN';
                            return cb(mainError);
                    ***REMOVED***
                        if (pkg.main === '.' || pkg.main === './') ***REMOVED***
                            pkg.main = 'index';
                    ***REMOVED***
                        loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) ***REMOVED***
                            if (err) return cb(err);
                            if (m) return cb(null, m, pkg);
                            if (!pkg) return loadAsFile(path.join(x, 'index'), pkg, cb);

                            var dir = path.resolve(x, pkg.main);
                            loadAsDirectory(dir, pkg, function (err, n, pkg) ***REMOVED***
                                if (err) return cb(err);
                                if (n) return cb(null, n, pkg);
                                loadAsFile(path.join(x, 'index'), pkg, cb);
                        ***REMOVED***);
                    ***REMOVED***);
                        return;
                ***REMOVED***

                    loadAsFile(path.join(x, '/index'), pkg, cb);
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***);
***REMOVED***

    function processDirs(cb, dirs) ***REMOVED***
        if (dirs.length === 0) return cb(null, undefined);
        var dir = dirs[0];

        isDirectory(path.dirname(dir), isdir);

        function isdir(err, isdir) ***REMOVED***
            if (err) return cb(err);
            if (!isdir) return processDirs(cb, dirs.slice(1));
            loadAsFile(dir, opts.package, onfile);
    ***REMOVED***

        function onfile(err, m, pkg) ***REMOVED***
            if (err) return cb(err);
            if (m) return cb(null, m, pkg);
            loadAsDirectory(dir, opts.package, ondir);
    ***REMOVED***

        function ondir(err, n, pkg) ***REMOVED***
            if (err) return cb(err);
            if (n) return cb(null, n, pkg);
            processDirs(cb, dirs.slice(1));
    ***REMOVED***
***REMOVED***
    function loadNodeModules(x, start, cb) ***REMOVED***
        var thunk = function () ***REMOVED*** return getPackageCandidates(x, start, opts); ***REMOVED***;
        processDirs(
            cb,
            packageIterator ? packageIterator(x, start, thunk, opts) : thunk()
        );
***REMOVED***
***REMOVED***;
