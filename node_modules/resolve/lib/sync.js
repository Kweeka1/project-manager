var isCore = require('is-core-module');
var fs = require('fs');
var path = require('path');
var getHomedir = require('./homedir');
var caller = require('./caller');
var nodeModulesPaths = require('./node-modules-paths');
var normalizeOptions = require('./normalize-options');

var realpathFS = fs.realpathSync && typeof fs.realpathSync.native === 'function' ? fs.realpathSync.native : fs.realpathSync;

var homedir = getHomedir();
var defaultPaths = function () ***REMOVED***
    return [
        path.join(homedir, '.node_modules'),
        path.join(homedir, '.node_libraries')
    ];
***REMOVED***;

var defaultIsFile = function isFile(file) ***REMOVED***
    try ***REMOVED***
        var stat = fs.statSync(file, ***REMOVED*** throwIfNoEntry: false ***REMOVED***);
***REMOVED*** catch (e) ***REMOVED***
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
***REMOVED***
    return !!stat && (stat.isFile() || stat.isFIFO());
***REMOVED***;

var defaultIsDir = function isDirectory(dir) ***REMOVED***
    try ***REMOVED***
        var stat = fs.statSync(dir, ***REMOVED*** throwIfNoEntry: false ***REMOVED***);
***REMOVED*** catch (e) ***REMOVED***
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
***REMOVED***
    return !!stat && stat.isDirectory();
***REMOVED***;

var defaultRealpathSync = function realpathSync(x) ***REMOVED***
    try ***REMOVED***
        return realpathFS(x);
***REMOVED*** catch (realpathErr) ***REMOVED***
        if (realpathErr.code !== 'ENOENT') ***REMOVED***
            throw realpathErr;
    ***REMOVED***
***REMOVED***
    return x;
***REMOVED***;

var maybeRealpathSync = function maybeRealpathSync(realpathSync, x, opts) ***REMOVED***
    if (opts && opts.preserveSymlinks === false) ***REMOVED***
        return realpathSync(x);
***REMOVED***
    return x;
***REMOVED***;

var defaultReadPackageSync = function defaultReadPackageSync(readFileSync, pkgfile) ***REMOVED***
    var body = readFileSync(pkgfile);
    try ***REMOVED***
        var pkg = JSON.parse(body);
        return pkg;
***REMOVED*** catch (jsonErr) ***REMOVED******REMOVED***
***REMOVED***;

var getPackageCandidates = function getPackageCandidates(x, start, opts) ***REMOVED***
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) ***REMOVED***
        dirs[i] = path.join(dirs[i], x);
***REMOVED***
    return dirs;
***REMOVED***;

module.exports = function resolveSync(x, options) ***REMOVED***
    if (typeof x !== 'string') ***REMOVED***
        throw new TypeError('Path must be a string.');
***REMOVED***
    var opts = normalizeOptions(x, options);

    var isFile = opts.isFile || defaultIsFile;
    var readFileSync = opts.readFileSync || fs.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var realpathSync = opts.realpathSync || defaultRealpathSync;
    var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
    if (opts.readFileSync && opts.readPackageSync) ***REMOVED***
        throw new TypeError('`readFileSync` and `readPackageSync` are mutually exclusive.');
***REMOVED***
    var packageIterator = opts.packageIterator;

    var extensions = opts.extensions || ['.js'];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;

    opts.paths = opts.paths || defaultPaths();

    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);

    if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) ***REMOVED***
        var res = path.resolve(absoluteStart, x);
        if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m) return maybeRealpathSync(realpathSync, m, opts);
***REMOVED*** else if (includeCoreModules && isCore(x)) ***REMOVED***
        return x;
***REMOVED*** else ***REMOVED***
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n) return maybeRealpathSync(realpathSync, n, opts);
***REMOVED***

    var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;

    function loadAsFileSync(x) ***REMOVED***
        var pkg = loadpkg(path.dirname(x));

        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) ***REMOVED***
            var rfile = path.relative(pkg.dir, x);
            var r = opts.pathFilter(pkg.pkg, x, rfile);
            if (r) ***REMOVED***
                x = path.resolve(pkg.dir, r); // eslint-disable-line no-param-reassign
        ***REMOVED***
    ***REMOVED***

        if (isFile(x)) ***REMOVED***
            return x;
    ***REMOVED***

        for (var i = 0; i < extensions.length; i++) ***REMOVED***
            var file = x + extensions[i];
            if (isFile(file)) ***REMOVED***
                return file;
        ***REMOVED***
    ***REMOVED***
***REMOVED***

    function loadpkg(dir) ***REMOVED***
        if (dir === '' || dir === '/') return;
        if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) ***REMOVED***
            return;
    ***REMOVED***
        if ((/[/\\]node_modules[/\\]*$/).test(dir)) return;

        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), 'package.json');

        if (!isFile(pkgfile)) ***REMOVED***
            return loadpkg(path.dirname(dir));
    ***REMOVED***

        var pkg = readPackageSync(readFileSync, pkgfile);

        if (pkg && opts.packageFilter) ***REMOVED***
            // v2 will pass pkgfile
            pkg = opts.packageFilter(pkg, /*pkgfile,*/ dir); // eslint-disable-line spaced-comment
    ***REMOVED***

        return ***REMOVED*** pkg: pkg, dir: dir ***REMOVED***;
***REMOVED***

    function loadAsDirectorySync(x) ***REMOVED***
        var pkgfile = path.join(maybeRealpathSync(realpathSync, x, opts), '/package.json');
        if (isFile(pkgfile)) ***REMOVED***
            try ***REMOVED***
                var pkg = readPackageSync(readFileSync, pkgfile);
        ***REMOVED*** catch (e) ***REMOVED******REMOVED***

            if (pkg && opts.packageFilter) ***REMOVED***
                // v2 will pass pkgfile
                pkg = opts.packageFilter(pkg, /*pkgfile,*/ x); // eslint-disable-line spaced-comment
        ***REMOVED***

            if (pkg && pkg.main) ***REMOVED***
                if (typeof pkg.main !== 'string') ***REMOVED***
                    var mainError = new TypeError('package “' + pkg.name + '” `main` must be a string');
                    mainError.code = 'INVALID_PACKAGE_MAIN';
                    throw mainError;
            ***REMOVED***
                if (pkg.main === '.' || pkg.main === './') ***REMOVED***
                    pkg.main = 'index';
            ***REMOVED***
                try ***REMOVED***
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                    var n = loadAsDirectorySync(path.resolve(x, pkg.main));
                    if (n) return n;
            ***REMOVED*** catch (e) ***REMOVED******REMOVED***
        ***REMOVED***
    ***REMOVED***

        return loadAsFileSync(path.join(x, '/index'));
***REMOVED***

    function loadNodeModulesSync(x, start) ***REMOVED***
        var thunk = function () ***REMOVED*** return getPackageCandidates(x, start, opts); ***REMOVED***;
        var dirs = packageIterator ? packageIterator(x, start, thunk, opts) : thunk();

        for (var i = 0; i < dirs.length; i++) ***REMOVED***
            var dir = dirs[i];
            if (isDirectory(path.dirname(dir))) ***REMOVED***
                var m = loadAsFileSync(dir);
                if (m) return m;
                var n = loadAsDirectorySync(dir);
                if (n) return n;
        ***REMOVED***
    ***REMOVED***
***REMOVED***
***REMOVED***;
