"use strict";
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
exports.lilconfigSync = exports.lilconfig = exports.defaultLoaders = void 0;
const path = require("path");
const fs = require("fs");
const os = require("os");
const fsReadFileAsync = fs.promises.readFile;
function getDefaultSearchPlaces(name) ***REMOVED***
    return [
        'package.json',
        `.$***REMOVED***name***REMOVED***rc.json`,
        `.$***REMOVED***name***REMOVED***rc.js`,
        `$***REMOVED***name***REMOVED***.config.js`,
        `.$***REMOVED***name***REMOVED***rc.cjs`,
        `$***REMOVED***name***REMOVED***.config.cjs`,
    ];
***REMOVED***
function getSearchPaths(startDir, stopDir) ***REMOVED***
    return startDir
        .split(path.sep)
        .reduceRight((acc, _, ind, arr) => ***REMOVED***
        const currentPath = arr.slice(0, ind + 1).join(path.sep);
        if (!acc.passedStopDir)
            acc.searchPlaces.push(currentPath || path.sep);
        if (currentPath === stopDir)
            acc.passedStopDir = true;
        return acc;
***REMOVED***, ***REMOVED*** searchPlaces: [], passedStopDir: false ***REMOVED***).searchPlaces;
***REMOVED***
exports.defaultLoaders = Object.freeze(***REMOVED***
    '.js': require,
    '.json': require,
    '.cjs': require,
    noExt(_, content) ***REMOVED***
        return JSON.parse(content);
***REMOVED***,
***REMOVED***);
function getExtDesc(ext) ***REMOVED***
    return ext === 'noExt' ? 'files without extensions' : `extension "$***REMOVED***ext***REMOVED***"`;
***REMOVED***
function getOptions(name, options = ***REMOVED******REMOVED***) ***REMOVED***
    const conf = ***REMOVED***
        stopDir: os.homedir(),
        searchPlaces: getDefaultSearchPlaces(name),
        ignoreEmptySearchPlaces: true,
        transform: (x) => x,
        packageProp: [name],
        ...options,
        loaders: ***REMOVED*** ...exports.defaultLoaders, ...options.loaders ***REMOVED***,
***REMOVED***;
    conf.searchPlaces.forEach(place => ***REMOVED***
        const key = path.extname(place) || 'noExt';
        const loader = conf.loaders[key];
        if (!loader) ***REMOVED***
            throw new Error(`No loader specified for $***REMOVED***getExtDesc(key)***REMOVED***, so searchPlaces item "$***REMOVED***place***REMOVED***" is invalid`);
    ***REMOVED***
        if (typeof loader !== 'function') ***REMOVED***
            throw new Error(`loader for $***REMOVED***getExtDesc(key)***REMOVED*** is not a function (type provided: "$***REMOVED***typeof loader***REMOVED***"), so searchPlaces item "$***REMOVED***place***REMOVED***" is invalid`);
    ***REMOVED***
***REMOVED***);
    return conf;
***REMOVED***
function getPackageProp(props, obj) ***REMOVED***
    if (typeof props === 'string' && props in obj)
        return obj[props];
    return ((Array.isArray(props) ? props : props.split('.')).reduce((acc, prop) => (acc === undefined ? acc : acc[prop]), obj) || null);
***REMOVED***
function getSearchItems(searchPlaces, searchPaths) ***REMOVED***
    return searchPaths.reduce((acc, searchPath) => ***REMOVED***
        searchPlaces.forEach(fileName => acc.push(***REMOVED***
            fileName,
            filepath: path.join(searchPath, fileName),
            loaderKey: path.extname(fileName) || 'noExt',
    ***REMOVED***));
        return acc;
***REMOVED***, []);
***REMOVED***
function validateFilePath(filepath) ***REMOVED***
    if (!filepath)
        throw new Error('load must pass a non-empty string');
***REMOVED***
function validateLoader(loader, ext) ***REMOVED***
    if (!loader)
        throw new Error(`No loader specified for extension "$***REMOVED***ext***REMOVED***"`);
    if (typeof loader !== 'function')
        throw new Error('loader is not a function');
***REMOVED***
function lilconfig(name, options) ***REMOVED***
    const ***REMOVED*** ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform, ***REMOVED*** = getOptions(name, options);
    return ***REMOVED***
        async search(searchFrom = process.cwd()) ***REMOVED***
            const searchPaths = getSearchPaths(searchFrom, stopDir);
            const result = ***REMOVED***
                config: null,
                filepath: '',
        ***REMOVED***;
            const searchItems = getSearchItems(searchPlaces, searchPaths);
            for (const ***REMOVED*** fileName, filepath, loaderKey ***REMOVED*** of searchItems) ***REMOVED***
                try ***REMOVED***
                    await fs.promises.access(filepath);
            ***REMOVED***
                catch (_a) ***REMOVED***
                    continue;
            ***REMOVED***
                const content = String(await fsReadFileAsync(filepath));
                const loader = loaders[loaderKey];
                if (fileName === 'package.json') ***REMOVED***
                    const pkg = await loader(filepath, content);
                    const maybeConfig = getPackageProp(packageProp, pkg);
                    if (maybeConfig != null) ***REMOVED***
                        result.config = maybeConfig;
                        result.filepath = filepath;
                        break;
                ***REMOVED***
                    continue;
            ***REMOVED***
                const isEmpty = content.trim() === '';
                if (isEmpty && ignoreEmptySearchPlaces)
                    continue;
                if (isEmpty) ***REMOVED***
                    result.isEmpty = true;
                    result.config = undefined;
            ***REMOVED***
                else ***REMOVED***
                    validateLoader(loader, loaderKey);
                    result.config = await loader(filepath, content);
            ***REMOVED***
                result.filepath = filepath;
                break;
        ***REMOVED***
            if (result.filepath === '' && result.config === null)
                return transform(null);
            return transform(result);
    ***REMOVED***,
        async load(filepath) ***REMOVED***
            validateFilePath(filepath);
            const absPath = path.resolve(process.cwd(), filepath);
            const ***REMOVED*** base, ext ***REMOVED*** = path.parse(absPath);
            const loaderKey = ext || 'noExt';
            const loader = loaders[loaderKey];
            validateLoader(loader, loaderKey);
            const content = String(await fsReadFileAsync(absPath));
            if (base === 'package.json') ***REMOVED***
                const pkg = await loader(absPath, content);
                return transform(***REMOVED***
                    config: getPackageProp(packageProp, pkg),
                    filepath: absPath,
            ***REMOVED***);
        ***REMOVED***
            const result = ***REMOVED***
                config: null,
                filepath: absPath,
        ***REMOVED***;
            const isEmpty = content.trim() === '';
            if (isEmpty && ignoreEmptySearchPlaces)
                return transform(***REMOVED***
                    config: undefined,
                    filepath: absPath,
                    isEmpty: true,
            ***REMOVED***);
            result.config = isEmpty
                ? undefined
                : await loader(absPath, content);
            return transform(isEmpty ? ***REMOVED*** ...result, isEmpty, config: undefined ***REMOVED*** : result);
    ***REMOVED***,
***REMOVED***;
***REMOVED***
exports.lilconfig = lilconfig;
function lilconfigSync(name, options) ***REMOVED***
    const ***REMOVED*** ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform, ***REMOVED*** = getOptions(name, options);
    return ***REMOVED***
        search(searchFrom = process.cwd()) ***REMOVED***
            const searchPaths = getSearchPaths(searchFrom, stopDir);
            const result = ***REMOVED***
                config: null,
                filepath: '',
        ***REMOVED***;
            const searchItems = getSearchItems(searchPlaces, searchPaths);
            for (const ***REMOVED*** fileName, filepath, loaderKey ***REMOVED*** of searchItems) ***REMOVED***
                try ***REMOVED***
                    fs.accessSync(filepath);
            ***REMOVED***
                catch (_a) ***REMOVED***
                    continue;
            ***REMOVED***
                const loader = loaders[loaderKey];
                const content = String(fs.readFileSync(filepath));
                if (fileName === 'package.json') ***REMOVED***
                    const pkg = loader(filepath, content);
                    const maybeConfig = getPackageProp(packageProp, pkg);
                    if (maybeConfig != null) ***REMOVED***
                        result.config = maybeConfig;
                        result.filepath = filepath;
                        break;
                ***REMOVED***
                    continue;
            ***REMOVED***
                const isEmpty = content.trim() === '';
                if (isEmpty && ignoreEmptySearchPlaces)
                    continue;
                if (isEmpty) ***REMOVED***
                    result.isEmpty = true;
                    result.config = undefined;
            ***REMOVED***
                else ***REMOVED***
                    validateLoader(loader, loaderKey);
                    result.config = loader(filepath, content);
            ***REMOVED***
                result.filepath = filepath;
                break;
        ***REMOVED***
            if (result.filepath === '' && result.config === null)
                return transform(null);
            return transform(result);
    ***REMOVED***,
        load(filepath) ***REMOVED***
            validateFilePath(filepath);
            const absPath = path.resolve(process.cwd(), filepath);
            const ***REMOVED*** base, ext ***REMOVED*** = path.parse(absPath);
            const loaderKey = ext || 'noExt';
            const loader = loaders[loaderKey];
            validateLoader(loader, loaderKey);
            const content = String(fs.readFileSync(absPath));
            if (base === 'package.json') ***REMOVED***
                const pkg = loader(absPath, content);
                return transform(***REMOVED***
                    config: getPackageProp(packageProp, pkg),
                    filepath: absPath,
            ***REMOVED***);
        ***REMOVED***
            const result = ***REMOVED***
                config: null,
                filepath: absPath,
        ***REMOVED***;
            const isEmpty = content.trim() === '';
            if (isEmpty && ignoreEmptySearchPlaces)
                return transform(***REMOVED***
                    filepath: absPath,
                    config: undefined,
                    isEmpty: true,
            ***REMOVED***);
            result.config = isEmpty ? undefined : loader(absPath, content);
            return transform(isEmpty ? ***REMOVED*** ...result, isEmpty, config: undefined ***REMOVED*** : result);
    ***REMOVED***,
***REMOVED***;
***REMOVED***
exports.lilconfigSync = lilconfigSync;
