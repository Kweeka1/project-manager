'use strict';

class QuickLRU ***REMOVED***
	constructor(options = ***REMOVED******REMOVED***) ***REMOVED***
		if (!(options.maxSize && options.maxSize > 0)) ***REMOVED***
			throw new TypeError('`maxSize` must be a number greater than 0');
		***REMOVED***

		this.maxSize = options.maxSize;
		this.onEviction = options.onEviction;
		this.cache = new Map();
		this.oldCache = new Map();
		this._size = 0;
	***REMOVED***

	_set(key, value) ***REMOVED***
		this.cache.set(key, value);
		this._size++;

		if (this._size >= this.maxSize) ***REMOVED***
			this._size = 0;

			if (typeof this.onEviction === 'function') ***REMOVED***
				for (const [key, value] of this.oldCache.entries()) ***REMOVED***
					this.onEviction(key, value);
				***REMOVED***
			***REMOVED***

			this.oldCache = this.cache;
			this.cache = new Map();
		***REMOVED***
	***REMOVED***

	get(key) ***REMOVED***
		if (this.cache.has(key)) ***REMOVED***
			return this.cache.get(key);
		***REMOVED***

		if (this.oldCache.has(key)) ***REMOVED***
			const value = this.oldCache.get(key);
			this.oldCache.delete(key);
			this._set(key, value);
			return value;
		***REMOVED***
	***REMOVED***

	set(key, value) ***REMOVED***
		if (this.cache.has(key)) ***REMOVED***
			this.cache.set(key, value);
		***REMOVED*** else ***REMOVED***
			this._set(key, value);
		***REMOVED***

		return this;
	***REMOVED***

	has(key) ***REMOVED***
		return this.cache.has(key) || this.oldCache.has(key);
	***REMOVED***

	peek(key) ***REMOVED***
		if (this.cache.has(key)) ***REMOVED***
			return this.cache.get(key);
		***REMOVED***

		if (this.oldCache.has(key)) ***REMOVED***
			return this.oldCache.get(key);
		***REMOVED***
	***REMOVED***

	delete(key) ***REMOVED***
		const deleted = this.cache.delete(key);
		if (deleted) ***REMOVED***
			this._size--;
		***REMOVED***

		return this.oldCache.delete(key) || deleted;
	***REMOVED***

	clear() ***REMOVED***
		this.cache.clear();
		this.oldCache.clear();
		this._size = 0;
	***REMOVED***

	* keys() ***REMOVED***
		for (const [key] of this) ***REMOVED***
			yield key;
		***REMOVED***
	***REMOVED***

	* values() ***REMOVED***
		for (const [, value] of this) ***REMOVED***
			yield value;
		***REMOVED***
	***REMOVED***

	* [Symbol.iterator]() ***REMOVED***
		for (const item of this.cache) ***REMOVED***
			yield item;
		***REMOVED***

		for (const item of this.oldCache) ***REMOVED***
			const [key] = item;
			if (!this.cache.has(key)) ***REMOVED***
				yield item;
			***REMOVED***
		***REMOVED***
	***REMOVED***

	get size() ***REMOVED***
		let oldCacheSize = 0;
		for (const key of this.oldCache.keys()) ***REMOVED***
			if (!this.cache.has(key)) ***REMOVED***
				oldCacheSize++;
			***REMOVED***
		***REMOVED***

		return Math.min(this._size + oldCacheSize, this.maxSize);
	***REMOVED***
***REMOVED***

module.exports = QuickLRU;
