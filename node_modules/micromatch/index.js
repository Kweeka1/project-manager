'use strict';

const util = require('util');
const braces = require('braces');
const picomatch = require('picomatch');
const utils = require('picomatch/lib/utils');
const isEmptyString = val => val === '' || val === './';

/**
 * Returns an array of strings that match one or more glob patterns.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm(list, patterns[, options]);
 *
 * console.log(mm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param ***REMOVED***String|Array<string>***REMOVED*** `list` List of strings to match.
 * @param ***REMOVED***String|Array<string>***REMOVED*** `patterns` One or more glob patterns to use for matching.
 * @param ***REMOVED***Object***REMOVED*** `options` See available [options](#options)
 * @return ***REMOVED***Array***REMOVED*** Returns an array of matches
 * @summary false
 * @api public
 */

const micromatch = (list, patterns, options) => ***REMOVED***
  patterns = [].concat(patterns);
  list = [].concat(list);

  let omit = new Set();
  let keep = new Set();
  let items = new Set();
  let negatives = 0;

  let onResult = state => ***REMOVED***
    items.add(state.output);
    if (options && options.onResult) ***REMOVED***
      options.onResult(state);
***REMOVED***
***REMOVED***;

  for (let i = 0; i < patterns.length; i++) ***REMOVED***
    let isMatch = picomatch(String(patterns[i]), ***REMOVED*** ...options, onResult ***REMOVED***, true);
    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
    if (negated) negatives++;

    for (let item of list) ***REMOVED***
      let matched = isMatch(item, true);

      let match = negated ? !matched.isMatch : matched.isMatch;
      if (!match) continue;

      if (negated) ***REMOVED***
        omit.add(matched.output);
  ***REMOVED*** else ***REMOVED***
        omit.delete(matched.output);
        keep.add(matched.output);
  ***REMOVED***
***REMOVED***
***REMOVED***

  let result = negatives === patterns.length ? [...items] : [...keep];
  let matches = result.filter(item => !omit.has(item));

  if (options && matches.length === 0) ***REMOVED***
    if (options.failglob === true) ***REMOVED***
      throw new Error(`No matches found for "$***REMOVED***patterns.join(', ')***REMOVED***"`);
***REMOVED***

    if (options.nonull === true || options.nullglob === true) ***REMOVED***
      return options.unescape ? patterns.map(p => p.replace(/\\/g, '')) : patterns;
***REMOVED***
***REMOVED***

  return matches;
***REMOVED***;

/**
 * Backwards compatibility
 */

micromatch.match = micromatch;

/**
 * Returns a matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matcher(pattern[, options]);
 *
 * const isMatch = mm.matcher('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @param ***REMOVED***String***REMOVED*** `pattern` Glob pattern
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***Function***REMOVED*** Returns a matcher function.
 * @api public
 */

micromatch.matcher = (pattern, options) => picomatch(pattern, options);

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.isMatch(string, patterns[, options]);
 *
 * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(mm.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param ***REMOVED***String***REMOVED*** `str` The string to test.
 * @param ***REMOVED***String|Array***REMOVED*** `patterns` One or more glob patterns to use for matching.
 * @param ***REMOVED***Object***REMOVED*** `[options]` See available [options](#options).
 * @return ***REMOVED***Boolean***REMOVED*** Returns true if any patterns match `str`
 * @api public
 */

micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Backwards compatibility
 */

micromatch.any = micromatch.isMatch;

/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.not(list, patterns[, options]);
 *
 * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param ***REMOVED***Array***REMOVED*** `list` Array of strings to match.
 * @param ***REMOVED***String|Array***REMOVED*** `patterns` One or more glob pattern to use for matching.
 * @param ***REMOVED***Object***REMOVED*** `options` See available [options](#options) for changing how matches are performed
 * @return ***REMOVED***Array***REMOVED*** Returns an array of strings that **do not match** the given patterns.
 * @api public
 */

micromatch.not = (list, patterns, options = ***REMOVED******REMOVED***) => ***REMOVED***
  patterns = [].concat(patterns).map(String);
  let result = new Set();
  let items = [];

  let onResult = state => ***REMOVED***
    if (options.onResult) options.onResult(state);
    items.push(state.output);
***REMOVED***;

  let matches = new Set(micromatch(list, patterns, ***REMOVED*** ...options, onResult ***REMOVED***));

  for (let item of items) ***REMOVED***
    if (!matches.has(item)) ***REMOVED***
      result.add(item);
***REMOVED***
***REMOVED***
  return [...result];
***REMOVED***;

/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var mm = require('micromatch');
 * // mm.contains(string, pattern[, options]);
 *
 * console.log(mm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(mm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param ***REMOVED***String***REMOVED*** `str` The string to match.
 * @param ***REMOVED***String|Array***REMOVED*** `patterns` Glob pattern to use for matching.
 * @param ***REMOVED***Object***REMOVED*** `options` See available [options](#options) for changing how matches are performed
 * @return ***REMOVED***Boolean***REMOVED*** Returns true if any of the patterns matches any part of `str`.
 * @api public
 */

micromatch.contains = (str, pattern, options) => ***REMOVED***
  if (typeof str !== 'string') ***REMOVED***
    throw new TypeError(`Expected a string: "$***REMOVED***util.inspect(str)***REMOVED***"`);
***REMOVED***

  if (Array.isArray(pattern)) ***REMOVED***
    return pattern.some(p => micromatch.contains(str, p, options));
***REMOVED***

  if (typeof pattern === 'string') ***REMOVED***
    if (isEmptyString(str) || isEmptyString(pattern)) ***REMOVED***
      return false;
***REMOVED***

    if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) ***REMOVED***
      return true;
***REMOVED***
***REMOVED***

  return micromatch.isMatch(str, pattern, ***REMOVED*** ...options, contains: true ***REMOVED***);
***REMOVED***;

/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matchKeys(object, patterns[, options]);
 *
 * const obj = ***REMOVED*** aa: 'a', ab: 'b', ac: 'c' ***REMOVED***;
 * console.log(mm.matchKeys(obj, '*b'));
 * //=> ***REMOVED*** ab: 'b' ***REMOVED***
 * ```
 * @param ***REMOVED***Object***REMOVED*** `object` The object with keys to filter.
 * @param ***REMOVED***String|Array***REMOVED*** `patterns` One or more glob patterns to use for matching.
 * @param ***REMOVED***Object***REMOVED*** `options` See available [options](#options) for changing how matches are performed
 * @return ***REMOVED***Object***REMOVED*** Returns an object with only keys that match the given patterns.
 * @api public
 */

micromatch.matchKeys = (obj, patterns, options) => ***REMOVED***
  if (!utils.isObject(obj)) ***REMOVED***
    throw new TypeError('Expected the first argument to be an object');
***REMOVED***
  let keys = micromatch(Object.keys(obj), patterns, options);
  let res = ***REMOVED******REMOVED***;
  for (let key of keys) res[key] = obj[key];
  return res;
***REMOVED***;

/**
 * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.some(list, patterns[, options]);
 *
 * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param ***REMOVED***String|Array***REMOVED*** `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param ***REMOVED***String|Array***REMOVED*** `patterns` One or more glob patterns to use for matching.
 * @param ***REMOVED***Object***REMOVED*** `options` See available [options](#options) for changing how matches are performed
 * @return ***REMOVED***Boolean***REMOVED*** Returns true if any `patterns` matches any of the strings in `list`
 * @api public
 */

micromatch.some = (list, patterns, options) => ***REMOVED***
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) ***REMOVED***
    let isMatch = picomatch(String(pattern), options);
    if (items.some(item => isMatch(item))) ***REMOVED***
      return true;
***REMOVED***
***REMOVED***
  return false;
***REMOVED***;

/**
 * Returns true if every string in the given `list` matches
 * any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.every(list, patterns[, options]);
 *
 * console.log(mm.every('foo.js', ['foo.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // false
 * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param ***REMOVED***String|Array***REMOVED*** `list` The string or array of strings to test.
 * @param ***REMOVED***String|Array***REMOVED*** `patterns` One or more glob patterns to use for matching.
 * @param ***REMOVED***Object***REMOVED*** `options` See available [options](#options) for changing how matches are performed
 * @return ***REMOVED***Boolean***REMOVED*** Returns true if all `patterns` matches all of the strings in `list`
 * @api public
 */

micromatch.every = (list, patterns, options) => ***REMOVED***
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) ***REMOVED***
    let isMatch = picomatch(String(pattern), options);
    if (!items.every(item => isMatch(item))) ***REMOVED***
      return false;
***REMOVED***
***REMOVED***
  return true;
***REMOVED***;

/**
 * Returns true if **all** of the given `patterns` match
 * the specified string.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.all(string, patterns[, options]);
 *
 * console.log(mm.all('foo.js', ['foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
 * // false
 *
 * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
 * // true
 * ```
 * @param ***REMOVED***String|Array***REMOVED*** `str` The string to test.
 * @param ***REMOVED***String|Array***REMOVED*** `patterns` One or more glob patterns to use for matching.
 * @param ***REMOVED***Object***REMOVED*** `options` See available [options](#options) for changing how matches are performed
 * @return ***REMOVED***Boolean***REMOVED*** Returns true if any patterns match `str`
 * @api public
 */

micromatch.all = (str, patterns, options) => ***REMOVED***
  if (typeof str !== 'string') ***REMOVED***
    throw new TypeError(`Expected a string: "$***REMOVED***util.inspect(str)***REMOVED***"`);
***REMOVED***

  return [].concat(patterns).every(p => picomatch(p, options)(str));
***REMOVED***;

/**
 * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.capture(pattern, string[, options]);
 *
 * console.log(mm.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(mm.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param ***REMOVED***String***REMOVED*** `glob` Glob pattern to use for matching.
 * @param ***REMOVED***String***REMOVED*** `input` String to match
 * @param ***REMOVED***Object***REMOVED*** `options` See available [options](#options) for changing how matches are performed
 * @return ***REMOVED***Array|null***REMOVED*** Returns an array of captures if the input matches the glob pattern, otherwise `null`.
 * @api public
 */

micromatch.capture = (glob, input, options) => ***REMOVED***
  let posix = utils.isWindows(options);
  let regex = picomatch.makeRe(String(glob), ***REMOVED*** ...options, capture: true ***REMOVED***);
  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);

  if (match) ***REMOVED***
    return match.slice(1).map(v => v === void 0 ? '' : v);
***REMOVED***
***REMOVED***;

/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.makeRe(pattern[, options]);
 *
 * console.log(mm.makeRe('*.js'));
 * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param ***REMOVED***String***REMOVED*** `pattern` A glob pattern to convert to regex.
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***RegExp***REMOVED*** Returns a regex created from the given pattern.
 * @api public
 */

micromatch.makeRe = (...args) => picomatch.makeRe(...args);

/**
 * Scan a glob pattern to separate the pattern into segments. Used
 * by the [split](#split) method.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm.scan(pattern[, options]);
 * ```
 * @param ***REMOVED***String***REMOVED*** `pattern`
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***Object***REMOVED*** Returns an object with
 * @api public
 */

micromatch.scan = (...args) => picomatch.scan(...args);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm.parse(pattern[, options]);
 * ```
 * @param ***REMOVED***String***REMOVED*** `glob`
 * @param ***REMOVED***Object***REMOVED*** `options`
 * @return ***REMOVED***Object***REMOVED*** Returns an object with useful properties and output to be used as regex source string.
 * @api public
 */

micromatch.parse = (patterns, options) => ***REMOVED***
  let res = [];
  for (let pattern of [].concat(patterns || [])) ***REMOVED***
    for (let str of braces(String(pattern), options)) ***REMOVED***
      res.push(picomatch.parse(str, options));
***REMOVED***
***REMOVED***
  return res;
***REMOVED***;

/**
 * Process the given brace `pattern`.
 *
 * ```js
 * const ***REMOVED*** braces ***REMOVED*** = require('micromatch');
 * console.log(braces('foo/***REMOVED***a,b,c***REMOVED***/bar'));
 * //=> [ 'foo/(a|b|c)/bar' ]
 *
 * console.log(braces('foo/***REMOVED***a,b,c***REMOVED***/bar', ***REMOVED*** expand: true ***REMOVED***));
 * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]
 * ```
 * @param ***REMOVED***String***REMOVED*** `pattern` String with brace pattern to process.
 * @param ***REMOVED***Object***REMOVED*** `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
 * @return ***REMOVED***Array***REMOVED***
 * @api public
 */

micromatch.braces = (pattern, options) => ***REMOVED***
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  if ((options && options.nobrace === true) || !/\***REMOVED***.*\***REMOVED***/.test(pattern)) ***REMOVED***
    return [pattern];
***REMOVED***
  return braces(pattern, options);
***REMOVED***;

/**
 * Expand braces
 */

micromatch.braceExpand = (pattern, options) => ***REMOVED***
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  return micromatch.braces(pattern, ***REMOVED*** ...options, expand: true ***REMOVED***);
***REMOVED***;

/**
 * Expose micromatch
 */

module.exports = micromatch;
