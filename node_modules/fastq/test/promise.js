'use strict'

const test = require('tape')
const buildQueue = require('../').promise
const ***REMOVED*** promisify ***REMOVED*** = require('util')
const sleep = promisify(setTimeout)
const immediate = promisify(setImmediate)

test('concurrency', function (t) ***REMOVED***
  t.plan(2)
  t.throws(buildQueue.bind(null, worker, 0))
  t.doesNotThrow(buildQueue.bind(null, worker, 1))

  async function worker (arg) ***REMOVED***
    return true
***REMOVED***
***REMOVED***)

test('worker execution', async function (t) ***REMOVED***
  const queue = buildQueue(worker, 1)

  const result = await queue.push(42)

  t.equal(result, true, 'result matches')

  async function worker (arg) ***REMOVED***
    t.equal(arg, 42)
    return true
***REMOVED***
***REMOVED***)

test('limit', async function (t) ***REMOVED***
  const queue = buildQueue(worker, 1)

  const [res1, res2] = await Promise.all([queue.push(10), queue.push(0)])
  t.equal(res1, 10, 'the result matches')
  t.equal(res2, 0, 'the result matches')

  async function worker (arg) ***REMOVED***
    await sleep(arg)
    return arg
***REMOVED***
***REMOVED***)

test('multiple executions', async function (t) ***REMOVED***
  const queue = buildQueue(worker, 1)
  const toExec = [1, 2, 3, 4, 5]
  const expected = ['a', 'b', 'c', 'd', 'e']
  let count = 0

  await Promise.all(toExec.map(async function (task, i) ***REMOVED***
    const result = await queue.push(task)
    t.equal(result, expected[i], 'the result matches')
***REMOVED***))

  async function worker (arg) ***REMOVED***
    t.equal(arg, toExec[count], 'arg matches')
    return expected[count++]
***REMOVED***
***REMOVED***)

test('drained', async function (t) ***REMOVED***
  const queue = buildQueue(worker, 2)

  const toExec = new Array(10).fill(10)
  let count = 0

  async function worker (arg) ***REMOVED***
    await sleep(arg)
    count++
***REMOVED***

  toExec.forEach(function (i) ***REMOVED***
    queue.push(i)
***REMOVED***)

  await queue.drained()

  t.equal(count, toExec.length)

  toExec.forEach(function (i) ***REMOVED***
    queue.push(i)
***REMOVED***)

  await queue.drained()

  t.equal(count, toExec.length * 2)
***REMOVED***)

test('drained with exception should not throw', async function (t) ***REMOVED***
  const queue = buildQueue(worker, 2)

  const toExec = new Array(10).fill(10)

  async function worker () ***REMOVED***
    throw new Error('foo')
***REMOVED***

  toExec.forEach(function (i) ***REMOVED***
    queue.push(i)
***REMOVED***)

  await queue.drained()
***REMOVED***)

test('drained with drain function', async function (t) ***REMOVED***
  let drainCalled = false
  const queue = buildQueue(worker, 2)

  queue.drain = function () ***REMOVED***
    drainCalled = true
***REMOVED***

  const toExec = new Array(10).fill(10)
  let count = 0

  async function worker (arg) ***REMOVED***
    await sleep(arg)
    count++
***REMOVED***

  toExec.forEach(function () ***REMOVED***
    queue.push()
***REMOVED***)

  await queue.drained()

  t.equal(count, toExec.length)
  t.equal(drainCalled, true)
***REMOVED***)

test('set this', async function (t) ***REMOVED***
  t.plan(1)
  const that = ***REMOVED******REMOVED***
  const queue = buildQueue(that, worker, 1)

  await queue.push(42)

  async function worker (arg) ***REMOVED***
    t.equal(this, that, 'this matches')
***REMOVED***
***REMOVED***)

test('unshift', async function (t) ***REMOVED***
  const queue = buildQueue(worker, 1)
  const expected = [1, 2, 3, 4]

  await Promise.all([
    queue.push(1),
    queue.push(4),
    queue.unshift(3),
    queue.unshift(2)
  ])

  t.is(expected.length, 0)

  async function worker (arg) ***REMOVED***
    t.equal(expected.shift(), arg, 'tasks come in order')
***REMOVED***
***REMOVED***)

test('push with worker throwing error', async function (t) ***REMOVED***
  t.plan(5)
  const q = buildQueue(async function (task, cb) ***REMOVED***
    throw new Error('test error')
***REMOVED*** 1)
  q.error(function (err, task) ***REMOVED***
    t.ok(err instanceof Error, 'global error handler should catch the error')
    t.match(err.message, /test error/, 'error message should be "test error"')
    t.equal(task, 42, 'The task executed should be passed')
***REMOVED***)
  try ***REMOVED***
    await q.push(42)
***REMOVED*** catch (err) ***REMOVED***
    t.ok(err instanceof Error, 'push callback should catch the error')
    t.match(err.message, /test error/, 'error message should be "test error"')
***REMOVED***
***REMOVED***)

test('unshift with worker throwing error', async function (t) ***REMOVED***
  t.plan(2)
  const q = buildQueue(async function (task, cb) ***REMOVED***
    throw new Error('test error')
***REMOVED*** 1)
  try ***REMOVED***
    await q.unshift(42)
***REMOVED*** catch (err) ***REMOVED***
    t.ok(err instanceof Error, 'push callback should catch the error')
    t.match(err.message, /test error/, 'error message should be "test error"')
***REMOVED***
***REMOVED***)

test('no unhandledRejection (push)', async function (t) ***REMOVED***
  function handleRejection () ***REMOVED***
    t.fail('unhandledRejection')
***REMOVED***
  process.once('unhandledRejection', handleRejection)
  const q = buildQueue(async function (task, cb) ***REMOVED***
    throw new Error('test error')
***REMOVED*** 1)

  q.push(42)

  await immediate()
  process.removeListener('unhandledRejection', handleRejection)
***REMOVED***)

test('no unhandledRejection (unshift)', async function (t) ***REMOVED***
  function handleRejection () ***REMOVED***
    t.fail('unhandledRejection')
***REMOVED***
  process.once('unhandledRejection', handleRejection)
  const q = buildQueue(async function (task, cb) ***REMOVED***
    throw new Error('test error')
***REMOVED*** 1)

  q.unshift(42)

  await immediate()
  process.removeListener('unhandledRejection', handleRejection)
***REMOVED***)
