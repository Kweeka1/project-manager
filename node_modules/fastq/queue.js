'use strict'

/* eslint-disable no-var */

var reusify = require('reusify')

function fastqueue (context, worker, concurrency) ***REMOVED***
  if (typeof context === 'function') ***REMOVED***
    concurrency = worker
    worker = context
    context = null
***REMOVED***

  if (concurrency < 1) ***REMOVED***
    throw new Error('fastqueue concurrency must be greater than 1')
***REMOVED***

  var cache = reusify(Task)
  var queueHead = null
  var queueTail = null
  var _running = 0
  var errorHandler = null

  var self = ***REMOVED***
    push: push,
    drain: noop,
    saturated: noop,
    pause: pause,
    paused: false,
    concurrency: concurrency,
    running: running,
    resume: resume,
    idle: idle,
    length: length,
    getQueue: getQueue,
    unshift: unshift,
    empty: noop,
    kill: kill,
    killAndDrain: killAndDrain,
    error: error
***REMOVED***

  return self

  function running () ***REMOVED***
    return _running
***REMOVED***

  function pause () ***REMOVED***
    self.paused = true
***REMOVED***

  function length () ***REMOVED***
    var current = queueHead
    var counter = 0

    while (current) ***REMOVED***
      current = current.next
      counter++
***REMOVED***

    return counter
***REMOVED***

  function getQueue () ***REMOVED***
    var current = queueHead
    var tasks = []

    while (current) ***REMOVED***
      tasks.push(current.value)
      current = current.next
***REMOVED***

    return tasks
***REMOVED***

  function resume () ***REMOVED***
    if (!self.paused) return
    self.paused = false
    for (var i = 0; i < self.concurrency; i++) ***REMOVED***
      _running++
      release()
***REMOVED***
***REMOVED***

  function idle () ***REMOVED***
    return _running === 0 && self.length() === 0
***REMOVED***

  function push (value, done) ***REMOVED***
    var current = cache.get()

    current.context = context
    current.release = release
    current.value = value
    current.callback = done || noop
    current.errorHandler = errorHandler

    if (_running === self.concurrency || self.paused) ***REMOVED***
      if (queueTail) ***REMOVED***
        queueTail.next = current
        queueTail = current
  ***REMOVED*** else ***REMOVED***
        queueHead = current
        queueTail = current
        self.saturated()
  ***REMOVED***
***REMOVED*** else ***REMOVED***
      _running++
      worker.call(context, current.value, current.worked)
***REMOVED***
***REMOVED***

  function unshift (value, done) ***REMOVED***
    var current = cache.get()

    current.context = context
    current.release = release
    current.value = value
    current.callback = done || noop

    if (_running === self.concurrency || self.paused) ***REMOVED***
      if (queueHead) ***REMOVED***
        current.next = queueHead
        queueHead = current
  ***REMOVED*** else ***REMOVED***
        queueHead = current
        queueTail = current
        self.saturated()
  ***REMOVED***
***REMOVED*** else ***REMOVED***
      _running++
      worker.call(context, current.value, current.worked)
***REMOVED***
***REMOVED***

  function release (holder) ***REMOVED***
    if (holder) ***REMOVED***
      cache.release(holder)
***REMOVED***
    var next = queueHead
    if (next) ***REMOVED***
      if (!self.paused) ***REMOVED***
        if (queueTail === queueHead) ***REMOVED***
          queueTail = null
    ***REMOVED***
        queueHead = next.next
        next.next = null
        worker.call(context, next.value, next.worked)
        if (queueTail === null) ***REMOVED***
          self.empty()
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
        _running--
  ***REMOVED***
***REMOVED*** else if (--_running === 0) ***REMOVED***
      self.drain()
***REMOVED***
***REMOVED***

  function kill () ***REMOVED***
    queueHead = null
    queueTail = null
    self.drain = noop
***REMOVED***

  function killAndDrain () ***REMOVED***
    queueHead = null
    queueTail = null
    self.drain()
    self.drain = noop
***REMOVED***

  function error (handler) ***REMOVED***
    errorHandler = handler
***REMOVED***
***REMOVED***

function noop () ***REMOVED******REMOVED***

function Task () ***REMOVED***
  this.value = null
  this.callback = noop
  this.next = null
  this.release = noop
  this.context = null
  this.errorHandler = null

  var self = this

  this.worked = function worked (err, result) ***REMOVED***
    var callback = self.callback
    var errorHandler = self.errorHandler
    var val = self.value
    self.value = null
    self.callback = noop
    if (self.errorHandler) ***REMOVED***
      errorHandler(err, val)
***REMOVED***
    callback.call(self.context, err, result)
    self.release(self)
***REMOVED***
***REMOVED***

function queueAsPromised (context, worker, concurrency) ***REMOVED***
  if (typeof context === 'function') ***REMOVED***
    concurrency = worker
    worker = context
    context = null
***REMOVED***

  function asyncWrapper (arg, cb) ***REMOVED***
    worker.call(this, arg)
      .then(function (res) ***REMOVED***
        cb(null, res)
  ***REMOVED***, cb)
***REMOVED***

  var queue = fastqueue(context, asyncWrapper, concurrency)

  var pushCb = queue.push
  var unshiftCb = queue.unshift

  queue.push = push
  queue.unshift = unshift
  queue.drained = drained

  return queue

  function push (value) ***REMOVED***
    var p = new Promise(function (resolve, reject) ***REMOVED***
      pushCb(value, function (err, result) ***REMOVED***
        if (err) ***REMOVED***
          reject(err)
          return
    ***REMOVED***
        resolve(result)
  ***REMOVED***)
***REMOVED***)

    // Let's fork the promise chain to
    // make the error bubble up to the user but
    // not lead to a unhandledRejection
    p.catch(noop)

    return p
***REMOVED***

  function unshift (value) ***REMOVED***
    var p = new Promise(function (resolve, reject) ***REMOVED***
      unshiftCb(value, function (err, result) ***REMOVED***
        if (err) ***REMOVED***
          reject(err)
          return
    ***REMOVED***
        resolve(result)
  ***REMOVED***)
***REMOVED***)

    // Let's fork the promise chain to
    // make the error bubble up to the user but
    // not lead to a unhandledRejection
    p.catch(noop)

    return p
***REMOVED***

  function drained () ***REMOVED***
    var previousDrain = queue.drain

    var p = new Promise(function (resolve) ***REMOVED***
      queue.drain = function () ***REMOVED***
        previousDrain()
        resolve()
  ***REMOVED***
***REMOVED***)

    return p
***REMOVED***
***REMOVED***

module.exports = fastqueue
module.exports.promise = queueAsPromised
