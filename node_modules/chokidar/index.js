'use strict';

const ***REMOVED*** EventEmitter ***REMOVED*** = require('events');
const fs = require('fs');
const sysPath = require('path');
const ***REMOVED*** promisify ***REMOVED*** = require('util');
const readdirp = require('readdirp');
const anymatch = require('anymatch').default;
const globParent = require('glob-parent');
const isGlob = require('is-glob');
const braces = require('braces');
const normalizePath = require('normalize-path');

const NodeFsHandler = require('./lib/nodefs-handler');
const FsEventsHandler = require('./lib/fsevents-handler');
const ***REMOVED***
  EV_ALL,
  EV_READY,
  EV_ADD,
  EV_CHANGE,
  EV_UNLINK,
  EV_ADD_DIR,
  EV_UNLINK_DIR,
  EV_RAW,
  EV_ERROR,

  STR_CLOSE,
  STR_END,

  BACK_SLASH_RE,
  DOUBLE_SLASH_RE,
  SLASH_OR_BACK_SLASH_RE,
  DOT_RE,
  REPLACER_RE,

  SLASH,
  SLASH_SLASH,
  BRACE_START,
  BANG,
  ONE_DOT,
  TWO_DOTS,
  GLOBSTAR,
  SLASH_GLOBSTAR,
  ANYMATCH_OPTS,
  STRING_TYPE,
  FUNCTION_TYPE,
  EMPTY_STR,
  EMPTY_FN,

  isWindows,
  isMacos,
  isIBMi
***REMOVED*** = require('./lib/constants');

const stat = promisify(fs.stat);
const readdir = promisify(fs.readdir);

/**
 * @typedef ***REMOVED***String***REMOVED*** Path
 * @typedef ***REMOVED***'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'***REMOVED*** EventName
 * @typedef ***REMOVED***'readdir'|'watch'|'add'|'remove'|'change'***REMOVED*** ThrottleType
 */

/**
 *
 * @typedef ***REMOVED***Object***REMOVED*** WatchHelpers
 * @property ***REMOVED***Boolean***REMOVED*** followSymlinks
 * @property ***REMOVED***'stat'|'lstat'***REMOVED*** statMethod
 * @property ***REMOVED***Path***REMOVED*** path
 * @property ***REMOVED***Path***REMOVED*** watchPath
 * @property ***REMOVED***Function***REMOVED*** entryPath
 * @property ***REMOVED***Boolean***REMOVED*** hasGlob
 * @property ***REMOVED***Object***REMOVED*** globFilter
 * @property ***REMOVED***Function***REMOVED*** filterPath
 * @property ***REMOVED***Function***REMOVED*** filterDir
 */

const arrify = (value = []) => Array.isArray(value) ? value : [value];
const flatten = (list, result = []) => ***REMOVED***
  list.forEach(item => ***REMOVED***
    if (Array.isArray(item)) ***REMOVED***
      flatten(item, result);
***REMOVED*** else ***REMOVED***
      result.push(item);
***REMOVED***
***REMOVED***);
  return result;
***REMOVED***;

const unifyPaths = (paths_) => ***REMOVED***
  /**
   * @type ***REMOVED***Array<String>***REMOVED***
   */
  const paths = flatten(arrify(paths_));
  if (!paths.every(p => typeof p === STRING_TYPE)) ***REMOVED***
    throw new TypeError(`Non-string provided as watch path: $***REMOVED***paths***REMOVED***`);
***REMOVED***
  return paths.map(normalizePathToUnix);
***REMOVED***;

// If SLASH_SLASH occurs at the beginning of path, it is not replaced
//     because "//StoragePC/DrivePool/Movies" is a valid network path
const toUnix = (string) => ***REMOVED***
  let str = string.replace(BACK_SLASH_RE, SLASH);
  let prepend = false;
  if (str.startsWith(SLASH_SLASH)) ***REMOVED***
    prepend = true;
***REMOVED***
  while (str.match(DOUBLE_SLASH_RE)) ***REMOVED***
    str = str.replace(DOUBLE_SLASH_RE, SLASH);
***REMOVED***
  if (prepend) ***REMOVED***
    str = SLASH + str;
***REMOVED***
  return str;
***REMOVED***;

// Our version of upath.normalize
// TODO: this is not equal to path-normalize module - investigate why
const normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));

const normalizeIgnored = (cwd = EMPTY_STR) => (path) => ***REMOVED***
  if (typeof path !== STRING_TYPE) return path;
  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));
***REMOVED***;

const getAbsolutePath = (path, cwd) => ***REMOVED***
  if (sysPath.isAbsolute(path)) ***REMOVED***
    return path;
***REMOVED***
  if (path.startsWith(BANG)) ***REMOVED***
    return BANG + sysPath.join(cwd, path.slice(1));
***REMOVED***
  return sysPath.join(cwd, path);
***REMOVED***;

const undef = (opts, key) => opts[key] === undefined;

/**
 * Directory entry.
 * @property ***REMOVED***Path***REMOVED*** path
 * @property ***REMOVED***Set<Path>***REMOVED*** items
 */
class DirEntry ***REMOVED***
  /**
   * @param ***REMOVED***Path***REMOVED*** dir
   * @param ***REMOVED***Function***REMOVED*** removeWatcher
   */
  constructor(dir, removeWatcher) ***REMOVED***
    this.path = dir;
    this._removeWatcher = removeWatcher;
    /** @type ***REMOVED***Set<Path>***REMOVED*** */
    this.items = new Set();
***REMOVED***

  add(item) ***REMOVED***
    const ***REMOVED***items***REMOVED*** = this;
    if (!items) return;
    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);
***REMOVED***

  async remove(item) ***REMOVED***
    const ***REMOVED***items***REMOVED*** = this;
    if (!items) return;
    items.delete(item);
    if (items.size > 0) return;

    const dir = this.path;
    try ***REMOVED***
      await readdir(dir);
***REMOVED*** catch (err) ***REMOVED***
      if (this._removeWatcher) ***REMOVED***
        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
  ***REMOVED***
***REMOVED***
***REMOVED***

  has(item) ***REMOVED***
    const ***REMOVED***items***REMOVED*** = this;
    if (!items) return;
    return items.has(item);
***REMOVED***

  /**
   * @returns ***REMOVED***Array<String>***REMOVED***
   */
  getChildren() ***REMOVED***
    const ***REMOVED***items***REMOVED*** = this;
    if (!items) return;
    return [...items.values()];
***REMOVED***

  dispose() ***REMOVED***
    this.items.clear();
    delete this.path;
    delete this._removeWatcher;
    delete this.items;
    Object.freeze(this);
***REMOVED***
***REMOVED***

const STAT_METHOD_F = 'stat';
const STAT_METHOD_L = 'lstat';
class WatchHelper ***REMOVED***
  constructor(path, watchPath, follow, fsw) ***REMOVED***
    this.fsw = fsw;
    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);
    this.watchPath = watchPath;
    this.fullWatchPath = sysPath.resolve(watchPath);
    this.hasGlob = watchPath !== path;
    /** @type ***REMOVED***object|boolean***REMOVED*** */
    if (path === EMPTY_STR) this.hasGlob = false;
    this.globSymlink = this.hasGlob && follow ? undefined : false;
    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;
    this.dirParts = this.getDirParts(path);
    this.dirParts.forEach((parts) => ***REMOVED***
      if (parts.length > 1) parts.pop();
***REMOVED***);
    this.followSymlinks = follow;
    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
***REMOVED***

  checkGlobSymlink(entry) ***REMOVED***
    // only need to resolve once
    // first entry should always have entry.parentDir === EMPTY_STR
    if (this.globSymlink === undefined) ***REMOVED***
      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?
        false : ***REMOVED***realPath: entry.fullParentDir, linkPath: this.fullWatchPath***REMOVED***;
***REMOVED***

    if (this.globSymlink) ***REMOVED***
      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
***REMOVED***

    return entry.fullPath;
***REMOVED***

  entryPath(entry) ***REMOVED***
    return sysPath.join(this.watchPath,
      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))
    );
***REMOVED***

  filterPath(entry) ***REMOVED***
    const ***REMOVED***stats***REMOVED*** = entry;
    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);
    const resolvedPath = this.entryPath(entry);
    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ?
      this.globFilter(resolvedPath) : true;
    return matchesGlob &&
      this.fsw._isntIgnored(resolvedPath, stats) &&
      this.fsw._hasReadPermissions(stats);
***REMOVED***

  getDirParts(path) ***REMOVED***
    if (!this.hasGlob) return [];
    const parts = [];
    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];
    expandedPath.forEach((path) => ***REMOVED***
      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));
***REMOVED***);
    return parts;
***REMOVED***

  filterDir(entry) ***REMOVED***
    if (this.hasGlob) ***REMOVED***
      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));
      let globstar = false;
      this.unmatchedGlob = !this.dirParts.some((parts) => ***REMOVED***
        return parts.every((part, i) => ***REMOVED***
          if (part === GLOBSTAR) globstar = true;
          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***
    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
***REMOVED***
***REMOVED***

/**
 * Watches files & directories for changes. Emitted events:
 * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
 *
 *     new FSWatcher()
 *       .add(directories)
 *       .on('add', path => log('File', path, 'was added'))
 */
class FSWatcher extends EventEmitter ***REMOVED***
// Not indenting methods for history sake; for now.
constructor(_opts) ***REMOVED***
  super();

  const opts = ***REMOVED******REMOVED***;
  if (_opts) Object.assign(opts, _opts); // for frozen objects

  /** @type ***REMOVED***Map<String, DirEntry>***REMOVED*** */
  this._watched = new Map();
  /** @type ***REMOVED***Map<String, Array>***REMOVED*** */
  this._closers = new Map();
  /** @type ***REMOVED***Set<String>***REMOVED*** */
  this._ignoredPaths = new Set();

  /** @type ***REMOVED***Map<ThrottleType, Map>***REMOVED*** */
  this._throttled = new Map();

  /** @type ***REMOVED***Map<Path, String|Boolean>***REMOVED*** */
  this._symlinkPaths = new Map();

  this._streams = new Set();
  this.closed = false;

  // Set up default options.
  if (undef(opts, 'persistent')) opts.persistent = true;
  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;
  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;
  if (undef(opts, 'interval')) opts.interval = 100;
  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;
  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;
  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;

  // Enable fsevents on OS X when polling isn't explicitly enabled.
  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;

  // If we can't use fsevents, ensure the options reflect it's disabled.
  const canUseFsEvents = FsEventsHandler.canUse();
  if (!canUseFsEvents) opts.useFsEvents = false;

  // Use polling on Mac if not using fsevents.
  // Other platforms use non-polling fs_watch.
  if (undef(opts, 'usePolling') && !opts.useFsEvents) ***REMOVED***
    opts.usePolling = isMacos;
***REMOVED***

  // Always default to polling on IBM i because fs.watch() is not available on IBM i.
  if(isIBMi) ***REMOVED***
    opts.usePolling = true;
***REMOVED***

  // Global override (useful for end-developers that need to force polling for all
  // instances of chokidar, regardless of usage/dependency depth)
  const envPoll = process.env.CHOKIDAR_USEPOLLING;
  if (envPoll !== undefined) ***REMOVED***
    const envLower = envPoll.toLowerCase();

    if (envLower === 'false' || envLower === '0') ***REMOVED***
      opts.usePolling = false;
***REMOVED*** else if (envLower === 'true' || envLower === '1') ***REMOVED***
      opts.usePolling = true;
***REMOVED*** else ***REMOVED***
      opts.usePolling = !!envLower;
***REMOVED***
***REMOVED***
  const envInterval = process.env.CHOKIDAR_INTERVAL;
  if (envInterval) ***REMOVED***
    opts.interval = Number.parseInt(envInterval, 10);
***REMOVED***

  // Editor atomic write normalization enabled by default with fs.watch
  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;
  if (opts.atomic) this._pendingUnlinks = new Map();

  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;

  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;
  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = ***REMOVED******REMOVED***;
  const awf = opts.awaitWriteFinish;
  if (awf) ***REMOVED***
    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;
    if (!awf.pollInterval) awf.pollInterval = 100;
    this._pendingWrites = new Map();
***REMOVED***
  if (opts.ignored) opts.ignored = arrify(opts.ignored);

  let readyCalls = 0;
  this._emitReady = () => ***REMOVED***
    readyCalls++;
    if (readyCalls >= this._readyCount) ***REMOVED***
      this._emitReady = EMPTY_FN;
      this._readyEmitted = true;
      // use process.nextTick to allow time for listener to be bound
      process.nextTick(() => this.emit(EV_READY));
***REMOVED***
***REMOVED***;
  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);
  this._readyEmitted = false;
  this.options = opts;

  // Initialize with proper watcher.
  if (opts.useFsEvents) ***REMOVED***
    this._fsEventsHandler = new FsEventsHandler(this);
***REMOVED*** else ***REMOVED***
    this._nodeFsHandler = new NodeFsHandler(this);
***REMOVED***

  // You’re frozen when your heart’s not open.
  Object.freeze(opts);
***REMOVED***

// Public methods

/**
 * Adds paths to be watched on an existing FSWatcher instance
 * @param ***REMOVED***Path|Array<Path>***REMOVED*** paths_
 * @param ***REMOVED***String=***REMOVED*** _origAdd private; for handling non-existent paths to be watched
 * @param ***REMOVED***Boolean=***REMOVED*** _internal private; indicates a non-user add
 * @returns ***REMOVED***FSWatcher***REMOVED*** for chaining
 */
add(paths_, _origAdd, _internal) ***REMOVED***
  const ***REMOVED***cwd, disableGlobbing***REMOVED*** = this.options;
  this.closed = false;
  let paths = unifyPaths(paths_);
  if (cwd) ***REMOVED***
    paths = paths.map((path) => ***REMOVED***
      const absPath = getAbsolutePath(path, cwd);

      // Check `path` instead of `absPath` because the cwd portion can't be a glob
      if (disableGlobbing || !isGlob(path)) ***REMOVED***
        return absPath;
  ***REMOVED***
      return normalizePath(absPath);
***REMOVED***);
***REMOVED***

  // set aside negated glob strings
  paths = paths.filter((path) => ***REMOVED***
    if (path.startsWith(BANG)) ***REMOVED***
      this._ignoredPaths.add(path.slice(1));
      return false;
***REMOVED***

    // if a path is being added that was previously ignored, stop ignoring it
    this._ignoredPaths.delete(path);
    this._ignoredPaths.delete(path + SLASH_GLOBSTAR);

    // reset the cached userIgnored anymatch fn
    // to make ignoredPaths changes effective
    this._userIgnored = undefined;

    return true;
***REMOVED***);

  if (this.options.useFsEvents && this._fsEventsHandler) ***REMOVED***
    if (!this._readyCount) this._readyCount = paths.length;
    if (this.options.persistent) this._readyCount *= 2;
    paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));
***REMOVED*** else ***REMOVED***
    if (!this._readyCount) this._readyCount = 0;
    this._readyCount += paths.length;
    Promise.all(
      paths.map(async path => ***REMOVED***
        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);
        if (res) this._emitReady();
        return res;
  ***REMOVED***)
    ).then(results => ***REMOVED***
      if (this.closed) return;
      results.filter(item => item).forEach(item => ***REMOVED***
        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
  ***REMOVED***);
***REMOVED***);
***REMOVED***

  return this;
***REMOVED***

/**
 * Close watchers or start ignoring events from specified paths.
 * @param ***REMOVED***Path|Array<Path>***REMOVED*** paths_ - string or array of strings, file/directory paths and/or globs
 * @returns ***REMOVED***FSWatcher***REMOVED*** for chaining
*/
unwatch(paths_) ***REMOVED***
  if (this.closed) return this;
  const paths = unifyPaths(paths_);
  const ***REMOVED***cwd***REMOVED*** = this.options;

  paths.forEach((path) => ***REMOVED***
    // convert to absolute path unless relative path already matches
    if (!sysPath.isAbsolute(path) && !this._closers.has(path)) ***REMOVED***
      if (cwd) path = sysPath.join(cwd, path);
      path = sysPath.resolve(path);
***REMOVED***

    this._closePath(path);

    this._ignoredPaths.add(path);
    if (this._watched.has(path)) ***REMOVED***
      this._ignoredPaths.add(path + SLASH_GLOBSTAR);
***REMOVED***

    // reset the cached userIgnored anymatch fn
    // to make ignoredPaths changes effective
    this._userIgnored = undefined;
***REMOVED***);

  return this;
***REMOVED***

/**
 * Close watchers and remove all listeners from watched paths.
 * @returns ***REMOVED***Promise<void>***REMOVED***.
*/
close() ***REMOVED***
  if (this.closed) return this._closePromise;
  this.closed = true;

  // Memory management.
  this.removeAllListeners();
  const closers = [];
  this._closers.forEach(closerList => closerList.forEach(closer => ***REMOVED***
    const promise = closer();
    if (promise instanceof Promise) closers.push(promise);
***REMOVED***));
  this._streams.forEach(stream => stream.destroy());
  this._userIgnored = undefined;
  this._readyCount = 0;
  this._readyEmitted = false;
  this._watched.forEach(dirent => dirent.dispose());
  ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => ***REMOVED***
    this[`_$***REMOVED***key***REMOVED***`].clear();
***REMOVED***);

  this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();
  return this._closePromise;
***REMOVED***

/**
 * Expose list of watched paths
 * @returns ***REMOVED***Object***REMOVED*** for chaining
*/
getWatched() ***REMOVED***
  const watchList = ***REMOVED******REMOVED***;
  this._watched.forEach((entry, dir) => ***REMOVED***
    const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
    watchList[key || ONE_DOT] = entry.getChildren().sort();
***REMOVED***);
  return watchList;
***REMOVED***

emitWithAll(event, args) ***REMOVED***
  this.emit(...args);
  if (event !== EV_ERROR) this.emit(EV_ALL, ...args);
***REMOVED***

// Common helpers
// --------------

/**
 * Normalize and emit events.
 * Calling _emit DOES NOT MEAN emit() would be called!
 * @param ***REMOVED***EventName***REMOVED*** event Type of event
 * @param ***REMOVED***Path***REMOVED*** path File or directory path
 * @param ***REMOVED****=***REMOVED*** val1 arguments to be passed with event
 * @param ***REMOVED****=***REMOVED*** val2
 * @param ***REMOVED****=***REMOVED*** val3
 * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
 */
async _emit(event, path, val1, val2, val3) ***REMOVED***
  if (this.closed) return;

  const opts = this.options;
  if (isWindows) path = sysPath.normalize(path);
  if (opts.cwd) path = sysPath.relative(opts.cwd, path);
  /** @type Array<any> */
  const args = [event, path];
  if (val3 !== undefined) args.push(val1, val2, val3);
  else if (val2 !== undefined) args.push(val1, val2);
  else if (val1 !== undefined) args.push(val1);

  const awf = opts.awaitWriteFinish;
  let pw;
  if (awf && (pw = this._pendingWrites.get(path))) ***REMOVED***
    pw.lastChange = new Date();
    return this;
***REMOVED***

  if (opts.atomic) ***REMOVED***
    if (event === EV_UNLINK) ***REMOVED***
      this._pendingUnlinks.set(path, args);
      setTimeout(() => ***REMOVED***
        this._pendingUnlinks.forEach((entry, path) => ***REMOVED***
          this.emit(...entry);
          this.emit(EV_ALL, ...entry);
          this._pendingUnlinks.delete(path);
    ***REMOVED***);
  ***REMOVED***, typeof opts.atomic === 'number' ? opts.atomic : 100);
      return this;
***REMOVED***
    if (event === EV_ADD && this._pendingUnlinks.has(path)) ***REMOVED***
      event = args[0] = EV_CHANGE;
      this._pendingUnlinks.delete(path);
***REMOVED***
***REMOVED***

  if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) ***REMOVED***
    const awfEmit = (err, stats) => ***REMOVED***
      if (err) ***REMOVED***
        event = args[0] = EV_ERROR;
        args[1] = err;
        this.emitWithAll(event, args);
  ***REMOVED*** else if (stats) ***REMOVED***
        // if stats doesn't exist the file must have been deleted
        if (args.length > 2) ***REMOVED***
          args[2] = stats;
    ***REMOVED*** else ***REMOVED***
          args.push(stats);
    ***REMOVED***
        this.emitWithAll(event, args);
  ***REMOVED***
***REMOVED***;

    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);
    return this;
***REMOVED***

  if (event === EV_CHANGE) ***REMOVED***
    const isThrottled = !this._throttle(EV_CHANGE, path, 50);
    if (isThrottled) return this;
***REMOVED***

  if (opts.alwaysStat && val1 === undefined &&
    (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)
  ) ***REMOVED***
    const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;
    let stats;
    try ***REMOVED***
      stats = await stat(fullPath);
***REMOVED*** catch (err) ***REMOVED******REMOVED***
    // Suppress event when fs_stat fails, to avoid sending undefined 'stat'
    if (!stats || this.closed) return;
    args.push(stats);
***REMOVED***
  this.emitWithAll(event, args);

  return this;
***REMOVED***

/**
 * Common handler for errors
 * @param ***REMOVED***Error***REMOVED*** error
 * @returns ***REMOVED***Error|Boolean***REMOVED*** The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
 */
_handleError(error) ***REMOVED***
  const code = error && error.code;
  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&
    (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))
  ) ***REMOVED***
    this.emit(EV_ERROR, error);
***REMOVED***
  return error || this.closed;
***REMOVED***

/**
 * Helper utility for throttling
 * @param ***REMOVED***ThrottleType***REMOVED*** actionType type being throttled
 * @param ***REMOVED***Path***REMOVED*** path being acted upon
 * @param ***REMOVED***Number***REMOVED*** timeout duration of time to suppress duplicate actions
 * @returns ***REMOVED***Object|false***REMOVED*** tracking object or false if action should be suppressed
 */
_throttle(actionType, path, timeout) ***REMOVED***
  if (!this._throttled.has(actionType)) ***REMOVED***
    this._throttled.set(actionType, new Map());
***REMOVED***

  /** @type ***REMOVED***Map<Path, Object>***REMOVED*** */
  const action = this._throttled.get(actionType);
  /** @type ***REMOVED***Object***REMOVED*** */
  const actionPath = action.get(path);

  if (actionPath) ***REMOVED***
    actionPath.count++;
    return false;
***REMOVED***

  let timeoutObject;
  const clear = () => ***REMOVED***
    const item = action.get(path);
    const count = item ? item.count : 0;
    action.delete(path);
    clearTimeout(timeoutObject);
    if (item) clearTimeout(item.timeoutObject);
    return count;
***REMOVED***;
  timeoutObject = setTimeout(clear, timeout);
  const thr = ***REMOVED***timeoutObject, clear, count: 0***REMOVED***;
  action.set(path, thr);
  return thr;
***REMOVED***

_incrReadyCount() ***REMOVED***
  return this._readyCount++;
***REMOVED***

/**
 * Awaits write operation to finish.
 * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
 * @param ***REMOVED***Path***REMOVED*** path being acted upon
 * @param ***REMOVED***Number***REMOVED*** threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
 * @param ***REMOVED***EventName***REMOVED*** event
 * @param ***REMOVED***Function***REMOVED*** awfEmit Callback to be called when ready for event to be emitted.
 */
_awaitWriteFinish(path, threshold, event, awfEmit) ***REMOVED***
  let timeoutHandler;

  let fullPath = path;
  if (this.options.cwd && !sysPath.isAbsolute(path)) ***REMOVED***
    fullPath = sysPath.join(this.options.cwd, path);
***REMOVED***

  const now = new Date();

  const awaitWriteFinish = (prevStat) => ***REMOVED***
    fs.stat(fullPath, (err, curStat) => ***REMOVED***
      if (err || !this._pendingWrites.has(path)) ***REMOVED***
        if (err && err.code !== 'ENOENT') awfEmit(err);
        return;
  ***REMOVED***

      const now = Number(new Date());

      if (prevStat && curStat.size !== prevStat.size) ***REMOVED***
        this._pendingWrites.get(path).lastChange = now;
  ***REMOVED***
      const pw = this._pendingWrites.get(path);
      const df = now - pw.lastChange;

      if (df >= threshold) ***REMOVED***
        this._pendingWrites.delete(path);
        awfEmit(undefined, curStat);
  ***REMOVED*** else ***REMOVED***
        timeoutHandler = setTimeout(
          awaitWriteFinish,
          this.options.awaitWriteFinish.pollInterval,
          curStat
        );
  ***REMOVED***
***REMOVED***);
***REMOVED***;

  if (!this._pendingWrites.has(path)) ***REMOVED***
    this._pendingWrites.set(path, ***REMOVED***
      lastChange: now,
      cancelWait: () => ***REMOVED***
        this._pendingWrites.delete(path);
        clearTimeout(timeoutHandler);
        return event;
  ***REMOVED***
***REMOVED***);
    timeoutHandler = setTimeout(
      awaitWriteFinish,
      this.options.awaitWriteFinish.pollInterval
    );
***REMOVED***
***REMOVED***

_getGlobIgnored() ***REMOVED***
  return [...this._ignoredPaths.values()];
***REMOVED***

/**
 * Determines whether user has asked to ignore this path.
 * @param ***REMOVED***Path***REMOVED*** path filepath or dir
 * @param ***REMOVED***fs.Stats=***REMOVED*** stats result of fs.stat
 * @returns ***REMOVED***Boolean***REMOVED***
 */
_isIgnored(path, stats) ***REMOVED***
  if (this.options.atomic && DOT_RE.test(path)) return true;
  if (!this._userIgnored) ***REMOVED***
    const ***REMOVED***cwd***REMOVED*** = this.options;
    const ign = this.options.ignored;

    const ignored = ign && ign.map(normalizeIgnored(cwd));
    const paths = arrify(ignored)
      .filter((path) => typeof path === STRING_TYPE && !isGlob(path))
      .map((path) => path + SLASH_GLOBSTAR);
    const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);
    this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);
***REMOVED***

  return this._userIgnored([path, stats]);
***REMOVED***

_isntIgnored(path, stat) ***REMOVED***
  return !this._isIgnored(path, stat);
***REMOVED***

/**
 * Provides a set of common helpers and properties relating to symlink and glob handling.
 * @param ***REMOVED***Path***REMOVED*** path file, directory, or glob pattern being watched
 * @param ***REMOVED***Number=***REMOVED*** depth at any depth > 0, this isn't a glob
 * @returns ***REMOVED***WatchHelper***REMOVED*** object containing helpers for this path
 */
_getWatchHelpers(path, depth) ***REMOVED***
  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);
  const follow = this.options.followSymlinks;

  return new WatchHelper(path, watchPath, follow, this);
***REMOVED***

// Directory helpers
// -----------------

/**
 * Provides directory tracking objects
 * @param ***REMOVED***String***REMOVED*** directory path of the directory
 * @returns ***REMOVED***DirEntry***REMOVED*** the directory's tracking object
 */
_getWatchedDir(directory) ***REMOVED***
  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);
  const dir = sysPath.resolve(directory);
  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));
  return this._watched.get(dir);
***REMOVED***

// File helpers
// ------------

/**
 * Check for read permissions.
 * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
 * @param ***REMOVED***fs.Stats***REMOVED*** stats - object, result of fs_stat
 * @returns ***REMOVED***Boolean***REMOVED*** indicates whether the file can be read
*/
_hasReadPermissions(stats) ***REMOVED***
  if (this.options.ignorePermissionErrors) return true;

  // stats.mode may be bigint
  const md = stats && Number.parseInt(stats.mode, 10);
  const st = md & 0o777;
  const it = Number.parseInt(st.toString(8)[0], 10);
  return Boolean(4 & it);
***REMOVED***

/**
 * Handles emitting unlink events for
 * files and directories, and via recursion, for
 * files and directories within directories that are unlinked
 * @param ***REMOVED***String***REMOVED*** directory within which the following item is located
 * @param ***REMOVED***String***REMOVED*** item      base path of item/directory
 * @returns ***REMOVED***void***REMOVED***
*/
_remove(directory, item, isDirectory) ***REMOVED***
  // if what is being deleted is a directory, get that directory's paths
  // for recursive deleting and cleaning of watched object
  // if it is not a directory, nestedDirectoryChildren will be empty array
  const path = sysPath.join(directory, item);
  const fullPath = sysPath.resolve(path);
  isDirectory = isDirectory != null
    ? isDirectory
    : this._watched.has(path) || this._watched.has(fullPath);

  // prevent duplicate handling in case of arriving here nearly simultaneously
  // via multiple paths (such as _handleFile and _handleDir)
  if (!this._throttle('remove', path, 100)) return;

  // if the only watched file is removed, watch for its return
  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) ***REMOVED***
    this.add(directory, item, true);
***REMOVED***

  // This will create a new entry in the watched object in either case
  // so we got to do the directory check beforehand
  const wp = this._getWatchedDir(path);
  const nestedDirectoryChildren = wp.getChildren();

  // Recursively remove children directories / files.
  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));

  // Check if item was on the watched list and remove it
  const parent = this._getWatchedDir(directory);
  const wasTracked = parent.has(item);
  parent.remove(item);

  // Fixes issue #1042 -> Relative paths were detected and added as symlinks
  // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),
  // but never removed from the map in case the path was deleted.
  // This leads to an incorrect state if the path was recreated:
  // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553
  if (this._symlinkPaths.has(fullPath)) ***REMOVED***
    this._symlinkPaths.delete(fullPath);
***REMOVED***

  // If we wait for this file to be fully written, cancel the wait.
  let relPath = path;
  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);
  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) ***REMOVED***
    const event = this._pendingWrites.get(relPath).cancelWait();
    if (event === EV_ADD) return;
***REMOVED***

  // The Entry will either be a directory that just got removed
  // or a bogus entry to a file, in either case we have to remove it
  this._watched.delete(path);
  this._watched.delete(fullPath);
  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;
  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);

  // Avoid conflicts if we later create another file with the same name
  if (!this.options.useFsEvents) ***REMOVED***
    this._closePath(path);
***REMOVED***
***REMOVED***

/**
 * Closes all watchers for a path
 * @param ***REMOVED***Path***REMOVED*** path
 */
_closePath(path) ***REMOVED***
  this._closeFile(path)
  const dir = sysPath.dirname(path);
  this._getWatchedDir(dir).remove(sysPath.basename(path));
***REMOVED***

/**
 * Closes only file-specific watchers
 * @param ***REMOVED***Path***REMOVED*** path
 */
_closeFile(path) ***REMOVED***
  const closers = this._closers.get(path);
  if (!closers) return;
  closers.forEach(closer => closer());
  this._closers.delete(path);
***REMOVED***

/**
 *
 * @param ***REMOVED***Path***REMOVED*** path
 * @param ***REMOVED***Function***REMOVED*** closer
 */
_addPathCloser(path, closer) ***REMOVED***
  if (!closer) return;
  let list = this._closers.get(path);
  if (!list) ***REMOVED***
    list = [];
    this._closers.set(path, list);
***REMOVED***
  list.push(closer);
***REMOVED***

_readdirp(root, opts) ***REMOVED***
  if (this.closed) return;
  const options = ***REMOVED***type: EV_ALL, alwaysStat: true, lstat: true, ...opts***REMOVED***;
  let stream = readdirp(root, options);
  this._streams.add(stream);
  stream.once(STR_CLOSE, () => ***REMOVED***
    stream = undefined;
***REMOVED***);
  stream.once(STR_END, () => ***REMOVED***
    if (stream) ***REMOVED***
      this._streams.delete(stream);
      stream = undefined;
***REMOVED***
***REMOVED***);
  return stream;
***REMOVED***

***REMOVED***

// Export FSWatcher class
exports.FSWatcher = FSWatcher;

/**
 * Instantiates watcher with paths to be tracked.
 * @param ***REMOVED***String|Array<String>***REMOVED*** paths file/directory paths and/or globs
 * @param ***REMOVED***Object=***REMOVED*** options chokidar opts
 * @returns an instance of FSWatcher for chaining.
 */
const watch = (paths, options) => ***REMOVED***
  const watcher = new FSWatcher(options);
  watcher.add(paths);
  return watcher;
***REMOVED***;

exports.watch = watch;
