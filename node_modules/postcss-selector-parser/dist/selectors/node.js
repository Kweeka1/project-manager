"use strict";

exports.__esModule = true;
exports["default"] = void 0;

var _util = require("../util");

function _defineProperties(target, props) ***REMOVED*** for (var i = 0; i < props.length; i++) ***REMOVED*** var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); ***REMOVED*** ***REMOVED***

function _createClass(Constructor, protoProps, staticProps) ***REMOVED*** if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; ***REMOVED***

var cloneNode = function cloneNode(obj, parent) ***REMOVED***
  if (typeof obj !== 'object' || obj === null) ***REMOVED***
    return obj;
***REMOVED***

  var cloned = new obj.constructor();

  for (var i in obj) ***REMOVED***
    if (!obj.hasOwnProperty(i)) ***REMOVED***
      continue;
***REMOVED***

    var value = obj[i];
    var type = typeof value;

    if (i === 'parent' && type === 'object') ***REMOVED***
      if (parent) ***REMOVED***
        cloned[i] = parent;
  ***REMOVED***
***REMOVED*** else if (value instanceof Array) ***REMOVED***
      cloned[i] = value.map(function (j) ***REMOVED***
        return cloneNode(j, cloned);
  ***REMOVED***);
***REMOVED*** else ***REMOVED***
      cloned[i] = cloneNode(value, cloned);
***REMOVED***
***REMOVED***

  return cloned;
***REMOVED***;

var Node = /*#__PURE__*/function () ***REMOVED***
  function Node(opts) ***REMOVED***
    if (opts === void 0) ***REMOVED***
      opts = ***REMOVED******REMOVED***;
***REMOVED***

    Object.assign(this, opts);
    this.spaces = this.spaces || ***REMOVED******REMOVED***;
    this.spaces.before = this.spaces.before || '';
    this.spaces.after = this.spaces.after || '';
***REMOVED***

  var _proto = Node.prototype;

  _proto.remove = function remove() ***REMOVED***
    if (this.parent) ***REMOVED***
      this.parent.removeChild(this);
***REMOVED***

    this.parent = undefined;
    return this;
***REMOVED***;

  _proto.replaceWith = function replaceWith() ***REMOVED***
    if (this.parent) ***REMOVED***
      for (var index in arguments) ***REMOVED***
        this.parent.insertBefore(this, arguments[index]);
  ***REMOVED***

      this.remove();
***REMOVED***

    return this;
***REMOVED***;

  _proto.next = function next() ***REMOVED***
    return this.parent.at(this.parent.index(this) + 1);
***REMOVED***;

  _proto.prev = function prev() ***REMOVED***
    return this.parent.at(this.parent.index(this) - 1);
***REMOVED***;

  _proto.clone = function clone(overrides) ***REMOVED***
    if (overrides === void 0) ***REMOVED***
      overrides = ***REMOVED******REMOVED***;
***REMOVED***

    var cloned = cloneNode(this);

    for (var name in overrides) ***REMOVED***
      cloned[name] = overrides[name];
***REMOVED***

    return cloned;
***REMOVED***
  /**
   * Some non-standard syntax doesn't follow normal escaping rules for css.
   * This allows non standard syntax to be appended to an existing property
   * by specifying the escaped value. By specifying the escaped value,
   * illegal characters are allowed to be directly inserted into css output.
   * @param ***REMOVED***string***REMOVED*** name the property to set
   * @param ***REMOVED***any***REMOVED*** value the unescaped value of the property
   * @param ***REMOVED***string***REMOVED*** valueEscaped optional. the escaped value of the property.
   */
  ;

  _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) ***REMOVED***
    if (!this.raws) ***REMOVED***
      this.raws = ***REMOVED******REMOVED***;
***REMOVED***

    var originalValue = this[name];
    var originalEscaped = this.raws[name];
    this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.

    if (originalEscaped || valueEscaped !== value) ***REMOVED***
      this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
***REMOVED*** else ***REMOVED***
      delete this.raws[name]; // delete any escaped value that was created by the setter.
***REMOVED***
***REMOVED***
  /**
   * Some non-standard syntax doesn't follow normal escaping rules for css.
   * This allows the escaped value to be specified directly, allowing illegal
   * characters to be directly inserted into css output.
   * @param ***REMOVED***string***REMOVED*** name the property to set
   * @param ***REMOVED***any***REMOVED*** value the unescaped value of the property
   * @param ***REMOVED***string***REMOVED*** valueEscaped the escaped value of the property.
   */
  ;

  _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) ***REMOVED***
    if (!this.raws) ***REMOVED***
      this.raws = ***REMOVED******REMOVED***;
***REMOVED***

    this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.

    this.raws[name] = valueEscaped;
***REMOVED***
  /**
   * When you want a value to passed through to CSS directly. This method
   * deletes the corresponding raw value causing the stringifier to fallback
   * to the unescaped value.
   * @param ***REMOVED***string***REMOVED*** name the property to set.
   * @param ***REMOVED***any***REMOVED*** value The value that is both escaped and unescaped.
   */
  ;

  _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) ***REMOVED***
    this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.

    if (this.raws) ***REMOVED***
      delete this.raws[name];
***REMOVED***
***REMOVED***
  /**
   *
   * @param ***REMOVED***number***REMOVED*** line The number (starting with 1)
   * @param ***REMOVED***number***REMOVED*** column The column number (starting with 1)
   */
  ;

  _proto.isAtPosition = function isAtPosition(line, column) ***REMOVED***
    if (this.source && this.source.start && this.source.end) ***REMOVED***
      if (this.source.start.line > line) ***REMOVED***
        return false;
  ***REMOVED***

      if (this.source.end.line < line) ***REMOVED***
        return false;
  ***REMOVED***

      if (this.source.start.line === line && this.source.start.column > column) ***REMOVED***
        return false;
  ***REMOVED***

      if (this.source.end.line === line && this.source.end.column < column) ***REMOVED***
        return false;
  ***REMOVED***

      return true;
***REMOVED***

    return undefined;
***REMOVED***;

  _proto.stringifyProperty = function stringifyProperty(name) ***REMOVED***
    return this.raws && this.raws[name] || this[name];
***REMOVED***;

  _proto.valueToString = function valueToString() ***REMOVED***
    return String(this.stringifyProperty("value"));
***REMOVED***;

  _proto.toString = function toString() ***REMOVED***
    return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join('');
***REMOVED***;

  _createClass(Node, [***REMOVED***
    key: "rawSpaceBefore",
    get: function get() ***REMOVED***
      var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;

      if (rawSpace === undefined) ***REMOVED***
        rawSpace = this.spaces && this.spaces.before;
  ***REMOVED***

      return rawSpace || "";
***REMOVED***,
    set: function set(raw) ***REMOVED***
      (0, _util.ensureObject)(this, "raws", "spaces");
      this.raws.spaces.before = raw;
***REMOVED***
***REMOVED*** ***REMOVED***
    key: "rawSpaceAfter",
    get: function get() ***REMOVED***
      var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;

      if (rawSpace === undefined) ***REMOVED***
        rawSpace = this.spaces.after;
  ***REMOVED***

      return rawSpace || "";
***REMOVED***,
    set: function set(raw) ***REMOVED***
      (0, _util.ensureObject)(this, "raws", "spaces");
      this.raws.spaces.after = raw;
***REMOVED***
***REMOVED***]);

  return Node;
***REMOVED***();

exports["default"] = Node;
module.exports = exports.default;