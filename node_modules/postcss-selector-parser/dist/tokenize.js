"use strict";

exports.__esModule = true;
exports["default"] = tokenize;
exports.FIELDS = void 0;

var t = _interopRequireWildcard(require("./tokenTypes"));

var _unescapable, _wordDelimiters;

function _getRequireWildcardCache() ***REMOVED*** if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() ***REMOVED*** return cache; ***REMOVED***; return cache; ***REMOVED***

function _interopRequireWildcard(obj) ***REMOVED*** if (obj && obj.__esModule) ***REMOVED*** return obj; ***REMOVED*** if (obj === null || typeof obj !== "object" && typeof obj !== "function") ***REMOVED*** return ***REMOVED*** "default": obj ***REMOVED***; ***REMOVED*** var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) ***REMOVED*** return cache.get(obj); ***REMOVED*** var newObj = ***REMOVED******REMOVED***; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) ***REMOVED*** if (Object.prototype.hasOwnProperty.call(obj, key)) ***REMOVED*** var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) ***REMOVED*** Object.defineProperty(newObj, key, desc); ***REMOVED*** else ***REMOVED*** newObj[key] = obj[key]; ***REMOVED*** ***REMOVED*** ***REMOVED*** newObj["default"] = obj; if (cache) ***REMOVED*** cache.set(obj, newObj); ***REMOVED*** return newObj; ***REMOVED***

var unescapable = (_unescapable = ***REMOVED******REMOVED***, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
var wordDelimiters = (_wordDelimiters = ***REMOVED******REMOVED***, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);
var hex = ***REMOVED******REMOVED***;
var hexChars = "0123456789abcdefABCDEF";

for (var i = 0; i < hexChars.length; i++) ***REMOVED***
  hex[hexChars.charCodeAt(i)] = true;
***REMOVED***
/**
 *  Returns the last index of the bar css word
 * @param ***REMOVED***string***REMOVED*** css The string in which the word begins
 * @param ***REMOVED***number***REMOVED*** start The index into the string where word's first letter occurs
 */


function consumeWord(css, start) ***REMOVED***
  var next = start;
  var code;

  do ***REMOVED***
    code = css.charCodeAt(next);

    if (wordDelimiters[code]) ***REMOVED***
      return next - 1;
***REMOVED*** else if (code === t.backslash) ***REMOVED***
      next = consumeEscape(css, next) + 1;
***REMOVED*** else ***REMOVED***
      // All other characters are part of the word
      next++;
***REMOVED***
***REMOVED*** while (next < css.length);

  return next - 1;
***REMOVED***
/**
 *  Returns the last index of the escape sequence
 * @param ***REMOVED***string***REMOVED*** css The string in which the sequence begins
 * @param ***REMOVED***number***REMOVED*** start The index into the string where escape character (`\`) occurs.
 */


function consumeEscape(css, start) ***REMOVED***
  var next = start;
  var code = css.charCodeAt(next + 1);

  if (unescapable[code]) ***REMOVED***// just consume the escape char
***REMOVED*** else if (hex[code]) ***REMOVED***
    var hexDigits = 0; // consume up to 6 hex chars

    do ***REMOVED***
      next++;
      hexDigits++;
      code = css.charCodeAt(next + 1);
***REMOVED*** while (hex[code] && hexDigits < 6); // if fewer than 6 hex chars, a trailing space ends the escape


    if (hexDigits < 6 && code === t.space) ***REMOVED***
      next++;
***REMOVED***
***REMOVED*** else ***REMOVED***
    // the next char is part of the current word
    next++;
***REMOVED***

  return next;
***REMOVED***

var FIELDS = ***REMOVED***
  TYPE: 0,
  START_LINE: 1,
  START_COL: 2,
  END_LINE: 3,
  END_COL: 4,
  START_POS: 5,
  END_POS: 6
***REMOVED***;
exports.FIELDS = FIELDS;

function tokenize(input) ***REMOVED***
  var tokens = [];
  var css = input.css.valueOf();
  var _css = css,
      length = _css.length;
  var offset = -1;
  var line = 1;
  var start = 0;
  var end = 0;
  var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;

  function unclosed(what, fix) ***REMOVED***
    if (input.safe) ***REMOVED***
      // fyi: this is never set to true.
      css += fix;
      next = css.length - 1;
***REMOVED*** else ***REMOVED***
      throw input.error('Unclosed ' + what, line, start - offset, start);
***REMOVED***
***REMOVED***

  while (start < length) ***REMOVED***
    code = css.charCodeAt(start);

    if (code === t.newline) ***REMOVED***
      offset = start;
      line += 1;
***REMOVED***

    switch (code) ***REMOVED***
      case t.space:
      case t.tab:
      case t.newline:
      case t.cr:
      case t.feed:
        next = start;

        do ***REMOVED***
          next += 1;
          code = css.charCodeAt(next);

          if (code === t.newline) ***REMOVED***
            offset = next;
            line += 1;
      ***REMOVED***
    ***REMOVED*** while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);

        tokenType = t.space;
        endLine = line;
        endColumn = next - offset - 1;
        end = next;
        break;

      case t.plus:
      case t.greaterThan:
      case t.tilde:
      case t.pipe:
        next = start;

        do ***REMOVED***
          next += 1;
          code = css.charCodeAt(next);
    ***REMOVED*** while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);

        tokenType = t.combinator;
        endLine = line;
        endColumn = start - offset;
        end = next;
        break;
      // Consume these characters as single tokens.

      case t.asterisk:
      case t.ampersand:
      case t.bang:
      case t.comma:
      case t.equals:
      case t.dollar:
      case t.caret:
      case t.openSquare:
      case t.closeSquare:
      case t.colon:
      case t.semicolon:
      case t.openParenthesis:
      case t.closeParenthesis:
        next = start;
        tokenType = code;
        endLine = line;
        endColumn = start - offset;
        end = next + 1;
        break;

      case t.singleQuote:
      case t.doubleQuote:
        quote = code === t.singleQuote ? "'" : '"';
        next = start;

        do ***REMOVED***
          escaped = false;
          next = css.indexOf(quote, next + 1);

          if (next === -1) ***REMOVED***
            unclosed('quote', quote);
      ***REMOVED***

          escapePos = next;

          while (css.charCodeAt(escapePos - 1) === t.backslash) ***REMOVED***
            escapePos -= 1;
            escaped = !escaped;
      ***REMOVED***
    ***REMOVED*** while (escaped);

        tokenType = t.str;
        endLine = line;
        endColumn = start - offset;
        end = next + 1;
        break;

      default:
        if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) ***REMOVED***
          next = css.indexOf('*/', start + 2) + 1;

          if (next === 0) ***REMOVED***
            unclosed('comment', '*/');
      ***REMOVED***

          content = css.slice(start, next + 1);
          lines = content.split('\n');
          last = lines.length - 1;

          if (last > 0) ***REMOVED***
            nextLine = line + last;
            nextOffset = next - lines[last].length;
      ***REMOVED*** else ***REMOVED***
            nextLine = line;
            nextOffset = offset;
      ***REMOVED***

          tokenType = t.comment;
          line = nextLine;
          endLine = nextLine;
          endColumn = next - nextOffset;
    ***REMOVED*** else if (code === t.slash) ***REMOVED***
          next = start;
          tokenType = code;
          endLine = line;
          endColumn = start - offset;
          end = next + 1;
    ***REMOVED*** else ***REMOVED***
          next = consumeWord(css, start);
          tokenType = t.word;
          endLine = line;
          endColumn = next - offset;
    ***REMOVED***

        end = next + 1;
        break;
***REMOVED*** // Ensure that the token structure remains consistent


    tokens.push([tokenType, // [0] Token type
    line, // [1] Starting line
    start - offset, // [2] Starting column
    endLine, // [3] Ending line
    endColumn, // [4] Ending column
    start, // [5] Start position / Source index
    end // [6] End position
    ]); // Reset offset for the next token

    if (nextOffset) ***REMOVED***
      offset = nextOffset;
      nextOffset = null;
***REMOVED***

    start = end;
***REMOVED***

  return tokens;
***REMOVED***