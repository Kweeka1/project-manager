'use strict';
const stringWidth = require('string-width');
const stripAnsi = require('strip-ansi');
const ansiStyles = require('ansi-styles');

const ESCAPES = new Set([
	'\u001B',
	'\u009B'
]);

const END_CODE = 39;

const ANSI_ESCAPE_BELL = '\u0007';
const ANSI_CSI = '[';
const ANSI_OSC = ']';
const ANSI_SGR_TERMINATOR = 'm';
const ANSI_ESCAPE_LINK = `$***REMOVED***ANSI_OSC***REMOVED***8;;`;

const wrapAnsi = code => `$***REMOVED***ESCAPES.values().next().value***REMOVED***$***REMOVED***ANSI_CSI***REMOVED***$***REMOVED***code***REMOVED***$***REMOVED***ANSI_SGR_TERMINATOR***REMOVED***`;
const wrapAnsiHyperlink = uri => `$***REMOVED***ESCAPES.values().next().value***REMOVED***$***REMOVED***ANSI_ESCAPE_LINK***REMOVED***$***REMOVED***uri***REMOVED***$***REMOVED***ANSI_ESCAPE_BELL***REMOVED***`;

// Calculate the length of words split on ' ', ignoring
// the extra characters added by ansi escape codes
const wordLengths = string => string.split(' ').map(character => stringWidth(character));

// Wrap a long word across multiple rows
// Ansi escape codes do not count towards length
const wrapWord = (rows, word, columns) => ***REMOVED***
	const characters = [...word];

	let isInsideEscape = false;
	let isInsideLinkEscape = false;
	let visible = stringWidth(stripAnsi(rows[rows.length - 1]));

	for (const [index, character] of characters.entries()) ***REMOVED***
		const characterLength = stringWidth(character);

		if (visible + characterLength <= columns) ***REMOVED***
			rows[rows.length - 1] += character;
		***REMOVED*** else ***REMOVED***
			rows.push(character);
			visible = 0;
		***REMOVED***

		if (ESCAPES.has(character)) ***REMOVED***
			isInsideEscape = true;
			isInsideLinkEscape = characters.slice(index + 1).join('').startsWith(ANSI_ESCAPE_LINK);
		***REMOVED***

		if (isInsideEscape) ***REMOVED***
			if (isInsideLinkEscape) ***REMOVED***
				if (character === ANSI_ESCAPE_BELL) ***REMOVED***
					isInsideEscape = false;
					isInsideLinkEscape = false;
				***REMOVED***
			***REMOVED*** else if (character === ANSI_SGR_TERMINATOR) ***REMOVED***
				isInsideEscape = false;
			***REMOVED***

			continue;
		***REMOVED***

		visible += characterLength;

		if (visible === columns && index < characters.length - 1) ***REMOVED***
			rows.push('');
			visible = 0;
		***REMOVED***
	***REMOVED***

	// It's possible that the last row we copy over is only
	// ansi escape characters, handle this edge-case
	if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) ***REMOVED***
		rows[rows.length - 2] += rows.pop();
	***REMOVED***
***REMOVED***;

// Trims spaces from a string ignoring invisible sequences
const stringVisibleTrimSpacesRight = string => ***REMOVED***
	const words = string.split(' ');
	let last = words.length;

	while (last > 0) ***REMOVED***
		if (stringWidth(words[last - 1]) > 0) ***REMOVED***
			break;
		***REMOVED***

		last--;
	***REMOVED***

	if (last === words.length) ***REMOVED***
		return string;
	***REMOVED***

	return words.slice(0, last).join(' ') + words.slice(last).join('');
***REMOVED***;

// The wrap-ansi module can be invoked in either 'hard' or 'soft' wrap mode
//
// 'hard' will never allow a string to take up more than columns characters
//
// 'soft' allows long words to expand past the column length
const exec = (string, columns, options = ***REMOVED******REMOVED***) => ***REMOVED***
	if (options.trim !== false && string.trim() === '') ***REMOVED***
		return '';
	***REMOVED***

	let returnValue = '';
	let escapeCode;
	let escapeUrl;

	const lengths = wordLengths(string);
	let rows = [''];

	for (const [index, word] of string.split(' ').entries()) ***REMOVED***
		if (options.trim !== false) ***REMOVED***
			rows[rows.length - 1] = rows[rows.length - 1].trimStart();
		***REMOVED***

		let rowLength = stringWidth(rows[rows.length - 1]);

		if (index !== 0) ***REMOVED***
			if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) ***REMOVED***
				// If we start with a new word but the current row length equals the length of the columns, add a new row
				rows.push('');
				rowLength = 0;
			***REMOVED***

			if (rowLength > 0 || options.trim === false) ***REMOVED***
				rows[rows.length - 1] += ' ';
				rowLength++;
			***REMOVED***
		***REMOVED***

		// In 'hard' wrap mode, the length of a line is never allowed to extend past 'columns'
		if (options.hard && lengths[index] > columns) ***REMOVED***
			const remainingColumns = (columns - rowLength);
			const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
			const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
			if (breaksStartingNextLine < breaksStartingThisLine) ***REMOVED***
				rows.push('');
			***REMOVED***

			wrapWord(rows, word, columns);
			continue;
		***REMOVED***

		if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) ***REMOVED***
			if (options.wordWrap === false && rowLength < columns) ***REMOVED***
				wrapWord(rows, word, columns);
				continue;
			***REMOVED***

			rows.push('');
		***REMOVED***

		if (rowLength + lengths[index] > columns && options.wordWrap === false) ***REMOVED***
			wrapWord(rows, word, columns);
			continue;
		***REMOVED***

		rows[rows.length - 1] += word;
	***REMOVED***

	if (options.trim !== false) ***REMOVED***
		rows = rows.map(stringVisibleTrimSpacesRight);
	***REMOVED***

	const pre = [...rows.join('\n')];

	for (const [index, character] of pre.entries()) ***REMOVED***
		returnValue += character;

		if (ESCAPES.has(character)) ***REMOVED***
			const ***REMOVED***groups***REMOVED*** = new RegExp(`(?:\\$***REMOVED***ANSI_CSI***REMOVED***(?<code>\\d+)m|\\$***REMOVED***ANSI_ESCAPE_LINK***REMOVED***(?<uri>.*)$***REMOVED***ANSI_ESCAPE_BELL***REMOVED***)`).exec(pre.slice(index).join('')) || ***REMOVED***groups: ***REMOVED******REMOVED******REMOVED***;
			if (groups.code !== undefined) ***REMOVED***
				const code = Number.parseFloat(groups.code);
				escapeCode = code === END_CODE ? undefined : code;
			***REMOVED*** else if (groups.uri !== undefined) ***REMOVED***
				escapeUrl = groups.uri.length === 0 ? undefined : groups.uri;
			***REMOVED***
		***REMOVED***

		const code = ansiStyles.codes.get(Number(escapeCode));

		if (pre[index + 1] === '\n') ***REMOVED***
			if (escapeUrl) ***REMOVED***
				returnValue += wrapAnsiHyperlink('');
			***REMOVED***

			if (escapeCode && code) ***REMOVED***
				returnValue += wrapAnsi(code);
			***REMOVED***
		***REMOVED*** else if (character === '\n') ***REMOVED***
			if (escapeCode && code) ***REMOVED***
				returnValue += wrapAnsi(escapeCode);
			***REMOVED***

			if (escapeUrl) ***REMOVED***
				returnValue += wrapAnsiHyperlink(escapeUrl);
			***REMOVED***
		***REMOVED***
	***REMOVED***

	return returnValue;
***REMOVED***;

// For each newline, invoke the method separately
module.exports = (string, columns, options) => ***REMOVED***
	return String(string)
		.normalize()
		.replace(/\r\n/g, '\n')
		.split('\n')
		.map(line => exec(line, columns, options))
		.join('\n');
***REMOVED***;
