/**
 * @license Fraction.js v4.2.0 05/03/2022
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2021, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/


/**
 *
 * This class offers the possibility to calculate fractions.
 * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.
 *
 * Array/Object form
 * [ 0 => <nominator>, 1 => <denominator> ]
 * [ n => <nominator>, d => <denominator> ]
 *
 * Integer form
 * - Single integer value
 *
 * Double form
 * - Single double value
 *
 * String form
 * 123.456 - a simple double
 * 123/456 - a string fraction
 * 123.'456' - a double with repeating decimal places
 * 123.(456) - synonym
 * 123.45'6' - a double with repeating last place
 * 123.45(6) - synonym
 *
 * Example:
 *
 * var f = new Fraction("9.4'31'");
 * f.mul([-4, 3]).div(4.9);
 *
 */

(function(root) ***REMOVED***

  "use strict";

  // Maximum search depth for cyclic rational numbers. 2000 should be more than enough.
  // Example: 1/7 = 0.(142857) has 6 repeating decimal places.
  // If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits
  var MAX_CYCLE_LEN = 2000;

  // Parsed data to avoid calling "new" all the time
  var P = ***REMOVED***
    "s": 1,
    "n": 0,
    "d": 1
***REMOVED***;

  function assign(n, s) ***REMOVED***

    if (isNaN(n = parseInt(n, 10))) ***REMOVED***
      throw Fraction['InvalidParameter'];
***REMOVED***
    return n * s;
***REMOVED***

  // Creates a new Fraction internally without the need of the bulky constructor
  function newFraction(n, d) ***REMOVED***

    if (d === 0) ***REMOVED***
      throw Fraction['DivisionByZero'];
***REMOVED***

    var f = Object.create(Fraction.prototype);
    f["s"] = n < 0 ? -1 : 1;

    n = n < 0 ? -n : n;

    var a = gcd(n, d);

    f["n"] = n / a;
    f["d"] = d / a;
    return f;
***REMOVED***

  function factorize(num) ***REMOVED***

    var factors = ***REMOVED******REMOVED***;

    var n = num;
    var i = 2;
    var s = 4;

    while (s <= n) ***REMOVED***

      while (n % i === 0) ***REMOVED***
        n/= i;
        factors[i] = (factors[i] || 0) + 1;
  ***REMOVED***
      s+= 1 + 2 * i++;
***REMOVED***

    if (n !== num) ***REMOVED***
      if (n > 1)
        factors[n] = (factors[n] || 0) + 1;
***REMOVED*** else ***REMOVED***
      factors[num] = (factors[num] || 0) + 1;
***REMOVED***
    return factors;
***REMOVED***

  var parse = function(p1, p2) ***REMOVED***

    var n = 0, d = 1, s = 1;
    var v = 0, w = 0, x = 0, y = 1, z = 1;

    var A = 0, B = 1;
    var C = 1, D = 1;

    var N = 10000000;
    var M;

    if (p1 === undefined || p1 === null) ***REMOVED***
      /* void */
***REMOVED*** else if (p2 !== undefined) ***REMOVED***
      n = p1;
      d = p2;
      s = n * d;

      if (n % 1 !== 0 || d % 1 !== 0) ***REMOVED***
        throw Fraction['NonIntegerParameter'];
  ***REMOVED***

***REMOVED*** else
      switch (typeof p1) ***REMOVED***

        case "object":
          ***REMOVED***
            if ("d" in p1 && "n" in p1) ***REMOVED***
              n = p1["n"];
              d = p1["d"];
              if ("s" in p1)
                n*= p1["s"];
        ***REMOVED*** else if (0 in p1) ***REMOVED***
              n = p1[0];
              if (1 in p1)
                d = p1[1];
        ***REMOVED*** else ***REMOVED***
              throw Fraction['InvalidParameter'];
        ***REMOVED***
            s = n * d;
            break;
      ***REMOVED***
        case "number":
          ***REMOVED***
            if (p1 < 0) ***REMOVED***
              s = p1;
              p1 = -p1;
        ***REMOVED***

            if (p1 % 1 === 0) ***REMOVED***
              n = p1;
        ***REMOVED*** else if (p1 > 0) ***REMOVED*** // check for != 0, scale would become NaN (log(0)), which converges really slow

              if (p1 >= 1) ***REMOVED***
                z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                p1/= z;
          ***REMOVED***

              // Using Farey Sequences
              // http://www.johndcook.com/blog/2010/10/20/best-rational-approximation/

              while (B <= N && D <= N) ***REMOVED***
                M = (A + C) / (B + D);

                if (p1 === M) ***REMOVED***
                  if (B + D <= N) ***REMOVED***
                    n = A + C;
                    d = B + D;
              ***REMOVED*** else if (D > B) ***REMOVED***
                    n = C;
                    d = D;
              ***REMOVED*** else ***REMOVED***
                    n = A;
                    d = B;
              ***REMOVED***
                  break;

            ***REMOVED*** else ***REMOVED***

                  if (p1 > M) ***REMOVED***
                    A+= C;
                    B+= D;
              ***REMOVED*** else ***REMOVED***
                    C+= A;
                    D+= B;
              ***REMOVED***

                  if (B > N) ***REMOVED***
                    n = C;
                    d = D;
              ***REMOVED*** else ***REMOVED***
                    n = A;
                    d = B;
              ***REMOVED***
            ***REMOVED***
          ***REMOVED***
              n*= z;
        ***REMOVED*** else if (isNaN(p1) || isNaN(p2)) ***REMOVED***
              d = n = NaN;
        ***REMOVED***
            break;
      ***REMOVED***
        case "string":
          ***REMOVED***
            B = p1.match(/\d+|./g);

            if (B === null)
              throw Fraction['InvalidParameter'];

            if (B[A] === '-') ***REMOVED***// Check for minus sign at the beginning
              s = -1;
              A++;
        ***REMOVED*** else if (B[A] === '+') ***REMOVED***// Check for plus sign at the beginning
              A++;
        ***REMOVED***

            if (B.length === A + 1) ***REMOVED*** // Check if it's just a simple number "1234"
              w = assign(B[A++], s);
        ***REMOVED*** else if (B[A + 1] === '.' || B[A] === '.') ***REMOVED*** // Check if it's a decimal number

              if (B[A] !== '.') ***REMOVED*** // Handle 0.5 and .5
                v = assign(B[A++], s);
          ***REMOVED***
              A++;

              // Check for decimal places
              if (A + 1 === B.length || B[A + 1] === '(' && B[A + 3] === ')' || B[A + 1] === "'" && B[A + 3] === "'") ***REMOVED***
                w = assign(B[A], s);
                y = Math.pow(10, B[A].length);
                A++;
          ***REMOVED***

              // Check for repeating places
              if (B[A] === '(' && B[A + 2] === ')' || B[A] === "'" && B[A + 2] === "'") ***REMOVED***
                x = assign(B[A + 1], s);
                z = Math.pow(10, B[A + 1].length) - 1;
                A+= 3;
          ***REMOVED***

        ***REMOVED*** else if (B[A + 1] === '/' || B[A + 1] === ':') ***REMOVED*** // Check for a simple fraction "123/456" or "123:456"
              w = assign(B[A], s);
              y = assign(B[A + 2], 1);
              A+= 3;
        ***REMOVED*** else if (B[A + 3] === '/' && B[A + 1] === ' ') ***REMOVED*** // Check for a complex fraction "123 1/2"
              v = assign(B[A], s);
              w = assign(B[A + 2], s);
              y = assign(B[A + 4], 1);
              A+= 5;
        ***REMOVED***

            if (B.length <= A) ***REMOVED*** // Check for more tokens on the stack
              d = y * z;
              s = /* void */
              n = x + d * v + z * w;
              break;
        ***REMOVED***

            /* Fall through on error */
      ***REMOVED***
        default:
          throw Fraction['InvalidParameter'];
  ***REMOVED***

    if (d === 0) ***REMOVED***
      throw Fraction['DivisionByZero'];
***REMOVED***

    P["s"] = s < 0 ? -1 : 1;
    P["n"] = Math.abs(n);
    P["d"] = Math.abs(d);
***REMOVED***;

  function modpow(b, e, m) ***REMOVED***

    var r = 1;
    for (; e > 0; b = (b * b) % m, e >>= 1) ***REMOVED***

      if (e & 1) ***REMOVED***
        r = (r * b) % m;
  ***REMOVED***
***REMOVED***
    return r;
***REMOVED***


  function cycleLen(n, d) ***REMOVED***

    for (; d % 2 === 0;
      d/= 2) ***REMOVED***
***REMOVED***

    for (; d % 5 === 0;
      d/= 5) ***REMOVED***
***REMOVED***

    if (d === 1) // Catch non-cyclic numbers
      return 0;

    // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:
    // 10^(d-1) % d == 1
    // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,
    // as we want to translate the numbers to strings.

    var rem = 10 % d;
    var t = 1;

    for (; rem !== 1; t++) ***REMOVED***
      rem = rem * 10 % d;

      if (t > MAX_CYCLE_LEN)
        return 0; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`
***REMOVED***
    return t;
***REMOVED***


  function cycleStart(n, d, len) ***REMOVED***

    var rem1 = 1;
    var rem2 = modpow(10, len, d);

    for (var t = 0; t < 300; t++) ***REMOVED*** // s < ~log10(Number.MAX_VALUE)
      // Solve 10^s == 10^(s+t) (mod d)

      if (rem1 === rem2)
        return t;

      rem1 = rem1 * 10 % d;
      rem2 = rem2 * 10 % d;
***REMOVED***
    return 0;
***REMOVED***

  function gcd(a, b) ***REMOVED***

    if (!a)
      return b;
    if (!b)
      return a;

    while (1) ***REMOVED***
      a%= b;
      if (!a)
        return b;
      b%= a;
      if (!b)
        return a;
***REMOVED***
***REMOVED***;

  /**
   * Module constructor
   *
   * @constructor
   * @param ***REMOVED***number|Fraction=***REMOVED*** a
   * @param ***REMOVED***number=***REMOVED*** b
   */
  function Fraction(a, b) ***REMOVED***

    parse(a, b);

    if (this instanceof Fraction) ***REMOVED***
      a = gcd(P["d"], P["n"]); // Abuse variable a
      this["s"] = P["s"];
      this["n"] = P["n"] / a;
      this["d"] = P["d"] / a;
***REMOVED*** else ***REMOVED***
      return newFraction(P['s'] * P['n'], P['d']);
***REMOVED***
***REMOVED***

  Fraction['DivisionByZero'] = new Error("Division by Zero");
  Fraction['InvalidParameter'] = new Error("Invalid argument");
  Fraction['NonIntegerParameter'] = new Error("Parameters must be integer");

  Fraction.prototype = ***REMOVED***

    "s": 1,
    "n": 0,
    "d": 1,

    /**
     * Calculates the absolute value
     *
     * Ex: new Fraction(-4).abs() => 4
     **/
    "abs": function() ***REMOVED***

      return newFraction(this["n"], this["d"]);
***REMOVED***,

    /**
     * Inverts the sign of the current fraction
     *
     * Ex: new Fraction(-4).neg() => 4
     **/
    "neg": function() ***REMOVED***

      return newFraction(-this["s"] * this["n"], this["d"]);
***REMOVED***,

    /**
     * Adds two rational numbers
     *
     * Ex: new Fraction(***REMOVED***n: 2, d: 3***REMOVED***).add("14.9") => 467 / 30
     **/
    "add": function(a, b) ***REMOVED***

      parse(a, b);
      return newFraction(
        this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"],
        this["d"] * P["d"]
      );
***REMOVED***,

    /**
     * Subtracts two rational numbers
     *
     * Ex: new Fraction(***REMOVED***n: 2, d: 3***REMOVED***).add("14.9") => -427 / 30
     **/
    "sub": function(a, b) ***REMOVED***

      parse(a, b);
      return newFraction(
        this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"],
        this["d"] * P["d"]
      );
***REMOVED***,

    /**
     * Multiplies two rational numbers
     *
     * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
     **/
    "mul": function(a, b) ***REMOVED***

      parse(a, b);
      return newFraction(
        this["s"] * P["s"] * this["n"] * P["n"],
        this["d"] * P["d"]
      );
***REMOVED***,

    /**
     * Divides two rational numbers
     *
     * Ex: new Fraction("-17.(345)").inverse().div(3)
     **/
    "div": function(a, b) ***REMOVED***

      parse(a, b);
      return newFraction(
        this["s"] * P["s"] * this["n"] * P["d"],
        this["d"] * P["n"]
      );
***REMOVED***,

    /**
     * Clones the actual object
     *
     * Ex: new Fraction("-17.(345)").clone()
     **/
    "clone": function() ***REMOVED***
      return newFraction(this['s'] * this['n'], this['d']);
***REMOVED***,

    /**
     * Calculates the modulo of two rational numbers - a more precise fmod
     *
     * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
     **/
    "mod": function(a, b) ***REMOVED***

      if (isNaN(this['n']) || isNaN(this['d'])) ***REMOVED***
        return new Fraction(NaN);
  ***REMOVED***

      if (a === undefined) ***REMOVED***
        return newFraction(this["s"] * this["n"] % this["d"], 1);
  ***REMOVED***

      parse(a, b);
      if (0 === P["n"] && 0 === this["d"]) ***REMOVED***
        throw Fraction['DivisionByZero'];
  ***REMOVED***

      /*
       * First silly attempt, kinda slow
       *
       return that["sub"](***REMOVED***
       "n": num["n"] * Math.floor((this.n / this.d) / (num.n / num.d)),
       "d": num["d"],
       "s": this["s"]
   ***REMOVED***);*/

      /*
       * New attempt: a1 / b1 = a2 / b2 * q + r
       * => b2 * a1 = a2 * b1 * q + b1 * b2 * r
       * => (b2 * a1 % a2 * b1) / (b1 * b2)
       */
      return newFraction(
        this["s"] * (P["d"] * this["n"]) % (P["n"] * this["d"]),
        P["d"] * this["d"]
      );
***REMOVED***,

    /**
     * Calculates the fractional gcd of two rational numbers
     *
     * Ex: new Fraction(5,8).gcd(3,7) => 1/56
     */
    "gcd": function(a, b) ***REMOVED***

      parse(a, b);

      // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)

      return newFraction(gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]), P["d"] * this["d"]);
***REMOVED***,

    /**
     * Calculates the fractional lcm of two rational numbers
     *
     * Ex: new Fraction(5,8).lcm(3,7) => 15
     */
    "lcm": function(a, b) ***REMOVED***

      parse(a, b);

      // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)

      if (P["n"] === 0 && this["n"] === 0) ***REMOVED***
        return newFraction(0, 1);
  ***REMOVED***
      return newFraction(P["n"] * this["n"], gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]));
***REMOVED***,

    /**
     * Calculates the ceil of a rational number
     *
     * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
     **/
    "ceil": function(places) ***REMOVED***

      places = Math.pow(10, places || 0);

      if (isNaN(this["n"]) || isNaN(this["d"])) ***REMOVED***
        return new Fraction(NaN);
  ***REMOVED***
      return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
***REMOVED***,

    /**
     * Calculates the floor of a rational number
     *
     * Ex: new Fraction('4.(3)').floor() => (4 / 1)
     **/
    "floor": function(places) ***REMOVED***

      places = Math.pow(10, places || 0);

      if (isNaN(this["n"]) || isNaN(this["d"])) ***REMOVED***
        return new Fraction(NaN);
  ***REMOVED***
      return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
***REMOVED***,

    /**
     * Rounds a rational numbers
     *
     * Ex: new Fraction('4.(3)').round() => (4 / 1)
     **/
    "round": function(places) ***REMOVED***

      places = Math.pow(10, places || 0);

      if (isNaN(this["n"]) || isNaN(this["d"])) ***REMOVED***
        return new Fraction(NaN);
  ***REMOVED***
      return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
***REMOVED***,

    /**
     * Gets the inverse of the fraction, means numerator and denominator are exchanged
     *
     * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
     **/
    "inverse": function() ***REMOVED***

      return newFraction(this["s"] * this["d"], this["n"]);
***REMOVED***,

    /**
     * Calculates the fraction to some rational exponent, if possible
     *
     * Ex: new Fraction(-1,2).pow(-3) => -8
     */
    "pow": function(a, b) ***REMOVED***

      parse(a, b);

      // Trivial case when exp is an integer

      if (P['d'] === 1) ***REMOVED***

        if (P['s'] < 0) ***REMOVED***
          return newFraction(Math.pow(this['s'] * this["d"], P['n']), Math.pow(this["n"], P['n']));
    ***REMOVED*** else ***REMOVED***
          return newFraction(Math.pow(this['s'] * this["n"], P['n']), Math.pow(this["d"], P['n']));
    ***REMOVED***
  ***REMOVED***

      // Negative roots become complex
      //     (-a/b)^(c/d) = x
      // <=> (-1)^(c/d) * (a/b)^(c/d) = x
      // <=> (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x         # rotate 1 by 180Â°
      // <=> (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre's formula in Q ( https://proofwiki.org/wiki/De_Moivre%27s_Formula/Rational_Index )
      // From which follows that only for c=0 the root is non-complex. c/d is a reduced fraction, so that sin(c/dpi)=0 occurs for d=1, which is handled by our trivial case.
      if (this['s'] < 0) return null;

      // Now prime factor n and d
      var N = factorize(this['n']);
      var D = factorize(this['d']);

      // Exponentiate and take root for n and d individually
      var n = 1;
      var d = 1;
      for (var k in N) ***REMOVED***
        if (k === '1') continue;
        if (k === '0') ***REMOVED***
          n = 0;
          break;
    ***REMOVED***
        N[k]*= P['n'];

        if (N[k] % P['d'] === 0) ***REMOVED***
          N[k]/= P['d'];
    ***REMOVED*** else return null;
        n*= Math.pow(k, N[k]);
  ***REMOVED***

      for (var k in D) ***REMOVED***
        if (k === '1') continue;
        D[k]*= P['n'];

        if (D[k] % P['d'] === 0) ***REMOVED***
          D[k]/= P['d'];
    ***REMOVED*** else return null;
        d*= Math.pow(k, D[k]);
  ***REMOVED***

      if (P['s'] < 0) ***REMOVED***
        return newFraction(d, n);
  ***REMOVED***
      return newFraction(n, d);
***REMOVED***,

    /**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/
    "equals": function(a, b) ***REMOVED***

      parse(a, b);
      return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"]; // Same as compare() === 0
***REMOVED***,

    /**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/
    "compare": function(a, b) ***REMOVED***

      parse(a, b);
      var t = (this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"]);
      return (0 < t) - (t < 0);
***REMOVED***,

    "simplify": function(eps) ***REMOVED***

      if (isNaN(this['n']) || isNaN(this['d'])) ***REMOVED***
        return this;
  ***REMOVED***

      eps = eps || 0.001;

      var thisABS = this['abs']();
      var cont = thisABS['toContinued']();

      for (var i = 1; i < cont.length; i++) ***REMOVED***

        var s = newFraction(cont[i - 1], 1);
        for (var k = i - 2; k >= 0; k--) ***REMOVED***
          s = s['inverse']()['add'](cont[k]);
    ***REMOVED***

        if (s['sub'](thisABS)['abs']().valueOf() < eps) ***REMOVED***
          return s['mul'](this['s']);
    ***REMOVED***
  ***REMOVED***
      return this;
***REMOVED***,

    /**
     * Check if two rational numbers are divisible
     *
     * Ex: new Fraction(19.6).divisible(1.5);
     */
    "divisible": function(a, b) ***REMOVED***

      parse(a, b);
      return !(!(P["n"] * this["d"]) || ((this["n"] * P["d"]) % (P["n"] * this["d"])));
***REMOVED***,

    /**
     * Returns a decimal representation of the fraction
     *
     * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
     **/
    'valueOf': function() ***REMOVED***

      return this["s"] * this["n"] / this["d"];
***REMOVED***,

    /**
     * Returns a string-fraction representation of a Fraction object
     *
     * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
     **/
    'toFraction': function(excludeWhole) ***REMOVED***

      var whole, str = "";
      var n = this["n"];
      var d = this["d"];
      if (this["s"] < 0) ***REMOVED***
        str+= '-';
  ***REMOVED***

      if (d === 1) ***REMOVED***
        str+= n;
  ***REMOVED*** else ***REMOVED***

        if (excludeWhole && (whole = Math.floor(n / d)) > 0) ***REMOVED***
          str+= whole;
          str+= " ";
          n%= d;
    ***REMOVED***

        str+= n;
        str+= '/';
        str+= d;
  ***REMOVED***
      return str;
***REMOVED***,

    /**
     * Returns a latex representation of a Fraction object
     *
     * Ex: new Fraction("1.'3'").toLatex() => "\frac***REMOVED***4***REMOVED******REMOVED***3***REMOVED***"
     **/
    'toLatex': function(excludeWhole) ***REMOVED***

      var whole, str = "";
      var n = this["n"];
      var d = this["d"];
      if (this["s"] < 0) ***REMOVED***
        str+= '-';
  ***REMOVED***

      if (d === 1) ***REMOVED***
        str+= n;
  ***REMOVED*** else ***REMOVED***

        if (excludeWhole && (whole = Math.floor(n / d)) > 0) ***REMOVED***
          str+= whole;
          n%= d;
    ***REMOVED***

        str+= "\\frac***REMOVED***";
        str+= n;
        str+= '***REMOVED******REMOVED***';
        str+= d;
        str+= '***REMOVED***';
  ***REMOVED***
      return str;
***REMOVED***,

    /**
     * Returns an array of continued fraction elements
     *
     * Ex: new Fraction("7/8").toContinued() => [0,1,7]
     */
    'toContinued': function() ***REMOVED***

      var t;
      var a = this['n'];
      var b = this['d'];
      var res = [];

      if (isNaN(a) || isNaN(b)) ***REMOVED***
        return res;
  ***REMOVED***

      do ***REMOVED***
        res.push(Math.floor(a / b));
        t = a % b;
        a = b;
        b = t;
  ***REMOVED*** while (a !== 1);

      return res;
***REMOVED***,

    /**
     * Creates a string representation of a fraction with all digits
     *
     * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
     **/
    'toString': function(dec) ***REMOVED***

      var N = this["n"];
      var D = this["d"];

      if (isNaN(N) || isNaN(D)) ***REMOVED***
        return "NaN";
  ***REMOVED***

      dec = dec || 15; // 15 = decimal places when no repetation

      var cycLen = cycleLen(N, D); // Cycle length
      var cycOff = cycleStart(N, D, cycLen); // Cycle start

      var str = this['s'] < 0 ? "-" : "";

      str+= N / D | 0;

      N%= D;
      N*= 10;

      if (N)
        str+= ".";

      if (cycLen) ***REMOVED***

        for (var i = cycOff; i--;) ***REMOVED***
          str+= N / D | 0;
          N%= D;
          N*= 10;
    ***REMOVED***
        str+= "(";
        for (var i = cycLen; i--;) ***REMOVED***
          str+= N / D | 0;
          N%= D;
          N*= 10;
    ***REMOVED***
        str+= ")";
  ***REMOVED*** else ***REMOVED***
        for (var i = dec; N && i--;) ***REMOVED***
          str+= N / D | 0;
          N%= D;
          N*= 10;
    ***REMOVED***
  ***REMOVED***
      return str;
***REMOVED***
***REMOVED***;

  if (typeof define === "function" && define["amd"]) ***REMOVED***
    define([], function() ***REMOVED***
      return Fraction;
***REMOVED***);
***REMOVED*** else if (typeof exports === "object") ***REMOVED***
    Object.defineProperty(Fraction, "__esModule", ***REMOVED*** 'value': true ***REMOVED***);
    Fraction['default'] = Fraction;
    Fraction['Fraction'] = Fraction;
    module['exports'] = Fraction;
***REMOVED*** else ***REMOVED***
    root['Fraction'] = Fraction;
***REMOVED***

***REMOVED***)(this);
